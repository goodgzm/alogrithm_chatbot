2024-07-16 10:51:01.334 | DEBUG    | __main__:algorithm_chat:19 - [message]我想要一个处理稀疏图的最小生成树算法
2024-07-16 10:51:01.336 | DEBUG    | __main__:algorithm_chat:20 - [history][]
2024-07-16 10:51:01.462 | ERROR    | __main__:algorithm_chat:24 - Error invoking retrieval chain: "Input to ChatPromptTemplate is missing variables {'\\\\'}.  Expected: ['\\\\', 'context', 'input'] Received: ['input', 'context']"
2024-07-16 10:52:37.569 | DEBUG    | chatbot.describe:__init__:42 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
{__int128读写}
2024-07-16 10:52:37.581 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
{快速排序}
2024-07-16 10:52:37.582 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
{归并排序}
2024-07-16 10:52:37.583 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
{整数二分}
2024-07-16 10:52:37.585 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
{浮点数二分}
2024-07-16 10:52:37.586 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
{整数三分}
2024-07-16 10:52:37.587 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
{浮点数三分}
2024-07-16 10:52:37.588 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
{高精度加法}
2024-07-16 10:52:37.589 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
{高精度减法}
2024-07-16 10:52:37.591 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
{高精度乘低精度}
2024-07-16 10:52:37.592 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
{高精度除以低精度}
2024-07-16 10:52:37.594 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
{子矩阵的和}
2024-07-16 10:52:37.595 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
{差分矩阵}
2024-07-16 10:52:37.596 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
{双指针算法}
2024-07-16 10:52:37.598 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
{数据离散化_保序离散化}
2024-07-16 10:52:37.599 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
{数据离散化_非保序离散化}
2024-07-16 10:52:37.601 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
{RMQ算法}
2024-07-16 10:52:37.603 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
{试除法判定质数}
2024-07-16 10:52:37.604 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
{试除法分解质因数}
2024-07-16 10:52:37.605 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
{朴素素数筛法}
2024-07-16 10:52:37.607 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
{线性素数筛法}
2024-07-16 10:52:37.608 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
{区间素数筛}
2024-07-16 10:52:37.610 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
{Min_25算法}
2024-07-16 10:52:37.612 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
{试除法求约数}
2024-07-16 10:52:37.613 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
{欧几里得算法}
2024-07-16 10:52:37.614 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
{欧拉函数}
2024-07-16 10:52:37.615 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
{筛法求欧拉函数}
2024-07-16 10:52:37.617 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
{卡特兰数求模}
2024-07-16 10:52:37.618 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
{快速求第n位卡特兰数}
2024-07-16 10:52:37.618 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
{Java大数打表卡特兰数}
2024-07-16 10:52:37.619 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
{快速幂}
2024-07-16 10:52:37.620 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
{位运算处理大数相乘}
2024-07-16 10:52:37.622 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
{扩展欧几里得算法}
2024-07-16 10:52:37.623 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
{高斯消元}
2024-07-16 10:52:37.624 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
{递归法求组合数}
2024-07-16 10:52:37.625 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
{预处理逆元的方式求组合数}
2024-07-16 10:52:37.627 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
{Lucas定理}
2024-07-16 10:52:37.628 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
{有向图的拓扑序}
2024-07-16 10:52:37.629 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
{树的直径}
2024-07-16 10:52:37.631 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
{朴素版Dijkstra算法}
2024-07-16 10:52:37.632 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
{堆优化版Dijkstra算法}
2024-07-16 10:52:37.633 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
{朴素版SPFA}
2024-07-16 10:52:37.634 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
{SFA优化版SPFA}
2024-07-16 10:52:37.635 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
{SPFA判负环正环}
2024-07-16 10:52:37.636 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
{Floyd 算法}
2024-07-16 10:52:37.638 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
{Prim算法}
2024-07-16 10:52:37.639 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
{Kruskal算法}
2024-07-16 10:52:37.640 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
{最小生成森林}
2024-07-16 10:52:37.641 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
{最近公共祖先倍增在线算法}
2024-07-16 10:52:37.642 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
{最近公共祖先Tarjan 离线算法}
2024-07-16 10:52:37.643 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
{有向图的强连通分量Tarjan算法}
2024-07-16 10:52:37.645 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
{无向图的点双连通分量Tarjan算法}
2024-07-16 10:52:37.646 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
{二分图检测}
2024-07-16 10:52:37.648 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
{匈牙利算法}
2024-07-16 10:52:37.649 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
{单链表}
2024-07-16 10:52:37.651 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
{双链表}
2024-07-16 10:52:37.652 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
{单调栈}
2024-07-16 10:52:37.654 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
{单调队列}
2024-07-16 10:52:37.656 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
{朴素并查集}
2024-07-16 10:52:37.658 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
{维护Size的并查集}
2024-07-16 10:52:37.659 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
{维护到祖宗节点距离的并查集}
2024-07-16 10:52:37.661 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
{字符串哈希}
2024-07-16 10:52:37.662 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
{KMP匹配算法}
2024-07-16 10:52:37.663 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
{线段树(单点修改)}
2024-07-16 10:52:37.666 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
{线段树区间修改}
2024-07-16 10:52:37.668 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
{树状数组}
2024-07-16 10:52:37.669 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程：
Trie 树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie 树广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。
2024-07-16 10:53:40.067 | DEBUG    | __main__:algorithm_chat:19 - [message]一个处理稀疏图的最小生成树算法
2024-07-16 10:53:40.068 | DEBUG    | __main__:algorithm_chat:20 - [history][]
2024-07-16 10:53:40.184 | ERROR    | __main__:algorithm_chat:24 - Error invoking retrieval chain: "Input to ChatPromptTemplate is missing variables {'\\\\'}.  Expected: ['\\\\', 'context', 'input'] Received: ['input', 'context']"
2024-07-16 11:00:06.212 | DEBUG    | chatbot.describe:__init__:42 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 11:00:06.215 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 11:00:06.218 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 11:00:06.219 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 11:00:06.220 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 11:00:06.222 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 11:00:06.223 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 11:00:06.225 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 11:00:06.225 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 11:00:06.226 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 11:00:06.227 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 11:00:06.229 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 11:00:06.230 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 11:00:06.232 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 11:00:06.233 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 11:00:06.235 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 11:00:06.237 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 11:00:06.238 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 11:00:06.239 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 11:00:06.240 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 11:00:06.242 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 11:00:06.244 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 11:00:06.246 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 11:00:06.248 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 11:00:06.249 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 11:00:06.251 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 11:00:06.253 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 11:00:06.254 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 11:00:06.255 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 11:00:06.256 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 11:00:06.257 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 11:00:06.258 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 11:00:06.259 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 11:00:06.260 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 11:00:06.261 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 11:00:06.261 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 11:00:06.262 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 11:00:06.263 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 11:00:06.265 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 11:00:06.266 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 11:00:06.267 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 11:00:06.268 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 11:00:06.269 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 11:00:06.270 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 11:00:06.271 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 11:00:06.273 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 11:00:06.274 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 11:00:06.275 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 11:00:06.276 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 11:00:06.276 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 11:00:06.278 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 11:00:06.279 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 11:00:06.280 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 11:00:06.281 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 11:00:06.282 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 11:00:06.283 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 11:00:06.284 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 11:00:06.286 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 11:00:06.288 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 11:00:06.290 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 11:00:06.291 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 11:00:06.293 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 11:00:06.295 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 11:00:06.296 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 11:00:06.297 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 11:00:06.300 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 11:00:06.307 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 11:00:44.070 | DEBUG    | __main__:algorithm_chat:19 - [message]一个处理稀疏图的最小生成树算法
2024-07-16 11:00:44.070 | DEBUG    | __main__:algorithm_chat:20 - [history][]
2024-07-16 11:00:46.886 | DEBUG    | __main__:algorithm_chat:27 - [input]一个处理稀疏图的最小生成树算法
2024-07-16 11:00:46.886 | DEBUG    | __main__:algorithm_chat:28 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。\n\n应用场景: \n适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。\n\n时间复杂度: \n算法的时间复杂度为 \nO(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。\n\n[回答]\n(最小生成森林)')]
2024-07-16 11:00:46.887 | DEBUG    | __main__:algorithm_chat:29 - [answer](Kruskal算法)
2024-07-16 11:04:26.473 | DEBUG    | chatbot.describe:__init__:42 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 11:04:26.474 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 11:04:26.476 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 11:04:26.477 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 11:04:26.478 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 11:04:26.479 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 11:04:26.480 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 11:04:26.481 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 11:04:26.482 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 11:04:26.483 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 11:04:26.484 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 11:04:26.485 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 11:04:26.486 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 11:04:26.487 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 11:04:26.488 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 11:04:26.490 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 11:04:26.491 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 11:04:26.492 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 11:04:26.493 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 11:04:26.494 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 11:04:26.496 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 11:04:26.498 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 11:04:26.500 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 11:04:26.502 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 11:04:26.504 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 11:04:26.505 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 11:04:26.507 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 11:04:26.509 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 11:04:26.510 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 11:04:26.511 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 11:04:26.512 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 11:04:26.513 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 11:04:26.516 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 11:04:26.516 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 11:04:26.517 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 11:04:26.518 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 11:04:26.519 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 11:04:26.520 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 11:04:26.521 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 11:04:26.522 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 11:04:26.523 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 11:04:26.523 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 11:04:26.524 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 11:04:26.525 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 11:04:26.526 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 11:04:26.527 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 11:04:26.528 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 11:04:26.530 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 11:04:26.531 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 11:04:26.531 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 11:04:26.533 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 11:04:26.534 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 11:04:26.535 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 11:04:26.536 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 11:04:26.537 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 11:04:26.538 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 11:04:26.539 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 11:04:26.540 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 11:04:26.541 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 11:04:26.543 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 11:04:26.544 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 11:04:26.545 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 11:04:26.546 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 11:04:26.548 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 11:04:26.550 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 11:04:26.552 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 11:04:26.553 | DEBUG    | chatbot.describe:__init__:42 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 11:06:10.581 | DEBUG    | __main__:algorithm_chat:19 - [message]O(1)的时间复杂度，进行字符串之间的比较
2024-07-16 11:06:10.581 | DEBUG    | __main__:algorithm_chat:20 - [history][]
2024-07-16 11:06:16.153 | DEBUG    | __main__:algorithm_chat:27 - [input]O(1)的时间复杂度，进行字符串之间的比较
2024-07-16 11:06:16.155 | DEBUG    | __main__:algorithm_chat:28 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\nKMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。\n构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。\n匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。\n\n应用场景: \nKMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。\n\n时间复杂度:\n预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。\n匹配时间为 O(m)，其中 m 是文本字符串的长度。\n整体复杂度为 O(n+m)，非常高效。\n该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。\n\n[回答]\n(KMP匹配算法)')]
2024-07-16 11:06:16.158 | DEBUG    | __main__:algorithm_chat:29 - [answer](字符串比较操作通常情况下是O(n)的时间复杂度，但如果仅是比较两个字符串是否相等，且假设字符串的长度是固定的，那么这个操作可以认为是O(1)的。因为无论字符串长度如何，比较操作只进行一次，不会随着字符串长度的增加而增加比较次数。)
2024-07-16 11:15:46.717 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 11:15:46.719 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 11:15:46.721 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 11:15:46.722 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 11:15:46.723 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 11:15:46.723 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 11:15:46.724 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 11:15:46.725 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 11:15:46.725 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 11:15:46.726 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 11:15:46.727 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 11:15:46.728 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 11:15:46.729 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 11:15:46.730 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 11:15:46.731 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 11:15:46.732 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 11:15:46.733 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 11:15:46.734 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 11:15:46.735 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 11:15:46.736 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 11:15:46.737 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 11:15:46.739 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 11:15:46.740 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 11:15:46.740 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 11:15:46.742 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 11:15:46.743 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 11:15:46.744 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 11:15:46.744 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 11:15:46.745 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 11:15:46.746 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 11:15:46.746 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 11:15:46.747 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 11:15:46.748 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 11:15:46.749 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 11:15:46.750 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 11:15:46.751 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 11:15:46.751 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 11:15:46.752 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 11:15:46.753 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 11:15:46.754 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 11:15:46.755 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 11:15:46.756 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 11:15:46.757 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 11:15:46.758 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 11:15:46.759 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 11:15:46.759 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 11:15:46.760 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 11:15:46.761 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 11:15:46.762 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 11:15:46.763 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 11:15:46.764 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 11:15:46.765 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 11:15:46.767 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 11:15:46.767 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 11:15:46.768 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 11:15:46.770 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 11:15:46.771 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 11:15:46.773 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 11:15:46.774 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 11:15:46.776 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 11:15:46.777 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 11:15:46.778 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 11:15:46.780 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 11:15:46.781 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 11:15:46.784 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 11:15:46.785 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 11:15:46.786 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 11:16:42.205 | DEBUG    | __main__:algorithm_chat:19 - [message]处理稠密图的最小生成树算法
2024-07-16 11:16:42.206 | DEBUG    | __main__:algorithm_chat:20 - [history][]
2024-07-16 11:16:45.076 | DEBUG    | __main__:algorithm_chat:27 - [input]处理稠密图的最小生成树算法
2024-07-16 11:16:45.077 | DEBUG    | __main__:algorithm_chat:28 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。\n\n应用场景: \n适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。\n\n时间复杂度: \n算法的时间复杂度为 \nO(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。\n\n[回答]\n(最小生成森林)')]
2024-07-16 11:16:45.077 | DEBUG    | __main__:algorithm_chat:29 - [answer]最小生成森林
2024-07-16 11:17:43.533 | DEBUG    | __main__:algorithm_chat:19 - [message]这么找到树的直径
2024-07-16 11:17:43.533 | DEBUG    | __main__:algorithm_chat:20 - [history][['处理稠密图的最小生成树算法', '最小生成森林']]
2024-07-16 11:17:44.552 | DEBUG    | __main__:algorithm_chat:27 - [input]这么找到树的直径
2024-07-16 11:17:44.555 | DEBUG    | __main__:algorithm_chat:28 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。\n\n应用场景: \n树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。\n\n时间复杂度: \n该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。\n\n[回答]\n(树的直径)')]
2024-07-16 11:17:44.559 | DEBUG    | __main__:algorithm_chat:29 - [answer]树的直径
2024-07-16 11:18:27.601 | DEBUG    | __main__:algorithm_chat:19 - [message]O(nlogn)的时间复杂度解决单源最短路问题
2024-07-16 11:18:27.601 | DEBUG    | __main__:algorithm_chat:20 - [history][['处理稠密图的最小生成树算法', '最小生成森林'], ['这么找到树的直径', '树的直径']]
2024-07-16 11:18:42.362 | DEBUG    | __main__:algorithm_chat:27 - [input]O(nlogn)的时间复杂度解决单源最短路问题
2024-07-16 11:18:42.362 | DEBUG    | __main__:algorithm_chat:28 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。\n\n应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。\n\n时间复杂度: Floyd 算法的时间复杂度为 \nO(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。\n\n[回答]\n(Floyd 算法)')]
2024-07-16 11:18:42.363 | DEBUG    | __main__:algorithm_chat:29 - [answer]您提到的 O(nlogn) 的时间复杂度通常是用于解决单源最短路径问题的 Dijkstra 算法（特别是当使用优先队列或二叉堆进行优化时）。以下是关于 Dijkstra 算法的简要说明：

**过程**：
1. 初始化：将所有节点的最短路径估计值设为无穷大，除了源节点，它的最短路径值设为 0。
2. 访问：选择当前未访问节点中估计值最小的节点，将其标记为已访问。
3. 松弛：对于该节点的每一个邻接节点，如果通过当前节点到达邻接节点的路径比已知的最短路径更短，则更新邻接节点的最短路径估计值。
4. 重复步骤 2 和 3，直到所有节点都被访问。

**应用场景**：
- 单源最短路径问题：从一个源节点找到到所有其他节点的最短路径。

**时间复杂度**：
- 如果使用简单的数组或列表来实现，Dijkstra 算法的时间复杂度为 O(n^2)。
- 但是，如果使用优先队列（通常是二叉堆）来优化节点选择过程，时间复杂度可以降低到 O((n + m) log n)，其中 n 是节点数，m 是边数。

这是因为每次从优先队列中取出最小元素需要 O(log n) 的时间复杂度，而每个节点最多被取出一次，每条边最多被松弛一次，所以总的时间复杂度是 O((n + m) log n)。在稀疏图（边数远小于节点数的平方）中，这个时间复杂度接近于 O(n log n)。

所以，如果您需要一个 O(nlogn) 时间复杂度来解决单源最短路径问题，可以使用优化后的 Dijkstra 算法。
2024-07-16 15:27:43.776 | ERROR    | sql.local_to_db:CodeLocalToDB:34 - Error re findall: expected string or bytes-like object, got 'Document'
2024-07-16 15:28:42.554 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text]-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:28:42.556 | ERROR    | sql.local_to_db:CodeLocalToDB:35 - Error re findall: expected string or bytes-like object, got 'Document'
2024-07-16 15:29:17.158 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text]-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:29:17.160 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
快速排序
[算法代码]
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 15:29:17.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
归并排序
[算法代码]
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 15:29:17.162 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
整数二分
[算法代码]
```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
2024-07-16 15:29:17.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:29:17.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
整数三分
[算法代码]
三分整数求极值的时候，往往不在 最后l  或者 r的地方取，而是遍历l~r之后取极值
```
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```
2024-07-16 15:29:17.164 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
浮点数三分
[算法代码]
```
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```
2024-07-16 15:29:17.165 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度加法
[算法代码]
```
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
 
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
 
    if (t) C.push_back(t);
    return C;
}
```
2024-07-16 15:29:17.167 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度减法
[算法代码]
```
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
 
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
2024-07-16 15:29:17.168 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度乘低精度
[算法代码]
```
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
 
    return C;
}
```
2024-07-16 15:29:17.169 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度除以低精度
[算法代码]
```
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
2024-07-16 15:29:17.169 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
位运算模板
[算法代码]
求n的二进制的第k位数字: n >> k & 1
返回n的二进制最后一位1所代表的十进制数：lowbit(n) = n & -n
###
当枚举状态时假设有n个点，每个点有两种状态，那么一共就有2^n个状态，所以可以用位运算来枚举每种方案里面的状态；1~2^n-1里面的所有的数都可以作为一种方案，比如n=5，那么枚举1~31，假设枚举到12，它的二进制为
01100 ，利用位运算判断12的哪一位是1，就证明对第几个点进行了相应的操作；
2024-07-16 15:29:17.170 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
子矩阵的和
[算法代码]
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
2024-07-16 15:29:17.170 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
差分矩阵
[算法代码]
简单的区间差分插入操作：
```
void insert(int l,int r,int x)
{
    b[l]+=x,b[r+1]-=x;
}
```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
\n\n-----\d+-----
[算法名称]
双指针算法
[算法代码]
```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 15:29:17.171 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
数据离散化_保序离散化
[算法代码]
```
vector<int> alls; 
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end()); 
 
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
```
2024-07-16 15:29:17.173 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
数据离散化_非保序离散化
[算法代码]
```
unordered_map<int,int> mp;
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```
2024-07-16 15:29:17.174 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
RMQ
[算法代码] 
const int N=2e5+7,M=20;
```
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:29:17.174 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:29:17.175 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:29:17.176 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:29:17.177 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:29:17.178 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:29:17.179 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:29:17.181 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:29:17.182 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:29:17.182 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
欧拉函数
[算法代码] 
1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
```
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:29:17.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:29:17.184 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:29:17.185 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:29:17.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:29:17.188 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:29:17.189 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:29:17.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:29:17.192 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:29:17.192 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:29:17.194 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Lucas定理
[算法代码] 
 ```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:29:17.196 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:29:17.197 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
树的直径 
[算法代码] 
树的直径求法有很多：
两次BFS或者两次DFS；树形DP 
树形DP的基本思路：
```
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:29:17.198 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素版Dijkstra
[算法代码] 
时间复杂是 O(n^2+m), n 表示点数，m 表示边数
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:29:17.201 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素版spfa
[算法代码] 
``
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:29:17.202 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:29:17.203 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:29:17.205 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
loyd算法 O(n^3)
[算法代码] 
 ```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:29:17.206 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:29:17.207 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:29:17.210 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:29:17.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
倍增在线算法
[算法代码] 
``
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:29:17.212 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:29:17.214 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
有向图的强连通分量
[算法代码] 
 ```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:29:17.217 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:29:17.219 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
二分图
[算法代码] 
 ```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:29:17.221 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
匈牙利算法
[算法代码] 
 ```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:29:17.222 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:29:17.223 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:29:17.225 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
单调栈
[算法代码]
```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
\n\n-----\d+-----
[算法名称]
单调队列
[算法代码]
```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
2024-07-16 15:29:17.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素并查集
[算法代码]
```
    int p[N]; 
 
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;
 
    p[find(a)] = find(b);
```
2024-07-16 15:29:17.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
维护size的并查集
[算法代码]
```
    int p[N], size[N];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
 
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```
2024-07-16 15:29:17.227 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
维护到祖宗节点距离的并查集
[算法代码]
```
    int p[N], d[N];
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
 
    p[find(a)] = find(b);
    d[find(a)] = distance; 
```
2024-07-16 15:29:17.229 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
字符串哈希
[算法代码]
```
typedef unsigned long long ULL;
ULL h[N], p[N]; 
 
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}
 
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 15:29:17.230 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
KMP
[算法代码]
```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
	int n;cin >>n>>p+1; 
	int m;cin >>m>>s+1;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1]) j++;
		ne[i]=j;
	} 
	for(int i=1,j=0;i<=m;i++)
	{
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1]) j++;
		//max_p=max(max_p,j);
		if(j==n)
		{
			cout <<i-n<<" ";
			j=ne[j];
		} 
	}
}
```
2024-07-16 15:29:17.231 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
线段树(单点修改)
[算法代码]
int n,m;
 
struct node
{
	int l,r;  
	int sum;   
	int lmax; 
	int rmax; 
	int tmax;  
}tr[N*4];
 
void pushup(node &u,node &l,node &r)
{
	u.sum=l.sum+r.sum;
	u.lmax=max(l.lmax,l.sum+r.lmax); 
	u.rmax=max(r.rmax,r.sum+l.rmax);
	u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
 
void pushup(int u)
{
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
 
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
	else
	{	tr[u]={l,r};
		int mid=l+r>>1;	
		build(u<<1,l,mid);	
		build(u<<1|1,mid+1,r);
		pushup(u);
	}
}
 
void modify(int u,int x,int v)
{
	if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v}; 
	else 
	{
		int mid=tr[u].l+tr[u].r>>1;	
		if(x<=mid) modify(u<<1,x,v);
		else modify(u<<1|1,x,v);	
		pushup(u);	
	}
}
 
node query(int u,int l,int r) 
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u]; 
	else
	{	
		int mid=tr[u].l+tr[u].r>>1;  
		if(r<=mid) return query(u<<1,l,r);
		else if(l>mid) return query(u<<1|1,l,r); 
		else 
		{
			auto left=query(u<<1,l,r);   
			auto right=query(u<<1|1,l,r);	
			node res;
			pushup(res,left,right);  
			return res;
		}	
	}
}
2024-07-16 15:29:17.233 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
线段树(区间修改)
[算法代码]
```
struct node
{
	ll l,r;  
	ll sum;
	ll add;	
	ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
    root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
    root.mul=root.mul*mul%p;
    root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
	tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
    eval(tr[u<<1],tr[u].add,tr[u].mul);
    eval(tr[u<<1|1],tr[u].add,tr[u].mul);
    tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],0,1};
	else
	{	tr[u]={l,r,0,0,1};	
		int mid=l+r>>1;	
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);	
		pushup(u);	
	}
}
 
void modify(int u,int l,int r,int add,int mul)
{
	if(tr[u].l>=l&&tr[u].r<=r)
	{
		eval(tr[u],add,mul);
	}
	else 
	{
		pushdown(u);
		int mid=tr[u].l+tr[u].r>>1;	
		if(l<=mid) modify(u<<1,l,r,add,mul); 
		if(r>mid) modify(u<<1|1,l,r,add,mul);	
		pushup(u);
	}
}
 
node query(int u,int l,int r)   
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	else
	{	
	    pushdown(u);
		node res;
		res.sum=0;
		int mid=tr[u].l+tr[u].r>>1; 
		if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
		if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
		pushup(u);
		return res;
	}
}
```
2024-07-16 15:29:17.237 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
树状数组
[算法代码]
```
int lowbit(int x)
{
	return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
	return res; 
}
```
2024-07-16 15:29:17.238 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Trie树
[算法代码]
```
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
 
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```
2024-07-16 15:33:48.653 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text]-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:33:48.655 | ERROR    | sql.local_to_db:CodeLocalToDB:35 - Error re findall: expected string or bytes-like object, got 'Document'
2024-07-16 15:34:55.294 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text]-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:35:33.268 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text]-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:35:33.270 | DEBUG    | sql.local_to_db:CodeLocalToDB:32 - [algorithm_name]__int128读写模板子
2024-07-16 15:35:33.270 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [code]```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
2024-07-16 15:35:33.271 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
快速排序
[算法代码]
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 15:35:33.272 | DEBUG    | sql.local_to_db:CodeLocalToDB:32 - [algorithm_name]快速排序
2024-07-16 15:35:33.272 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [code]```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 15:35:33.273 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
归并排序
[算法代码]
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 15:35:33.274 | DEBUG    | sql.local_to_db:CodeLocalToDB:32 - [algorithm_name]归并排序
2024-07-16 15:35:33.275 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [code]```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 15:35:33.276 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
整数二分
[算法代码]
```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
2024-07-16 15:35:33.277 | DEBUG    | sql.local_to_db:CodeLocalToDB:32 - [algorithm_name]整数二分
2024-07-16 15:35:33.278 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [code]```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
2024-07-16 15:35:33.279 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:38:06.182 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text]-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:38:06.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]__int128读写模板子
2024-07-16 15:38:06.184 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
2024-07-16 15:38:06.184 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
快速排序
[算法代码]
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 15:38:06.185 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]快速排序
2024-07-16 15:38:06.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 15:38:06.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
归并排序
[算法代码]
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 15:38:06.187 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]归并排序
2024-07-16 15:38:06.187 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 15:38:06.188 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
整数二分
[算法代码]
```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
2024-07-16 15:38:06.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]整数二分
2024-07-16 15:38:06.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
2024-07-16 15:38:06.191 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:38:06.192 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.193 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
整数三分
[算法代码]
```
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```
2024-07-16 15:38:06.194 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]整数三分
2024-07-16 15:38:06.194 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```
2024-07-16 15:38:06.195 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
浮点数三分
[算法代码]
```
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```
2024-07-16 15:38:06.196 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]浮点数三分
2024-07-16 15:38:06.196 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```
2024-07-16 15:38:06.197 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度加法
[算法代码]
```
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
 
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
 
    if (t) C.push_back(t);
    return C;
}
```
2024-07-16 15:38:06.198 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]高精度加法
2024-07-16 15:38:06.198 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
 
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
 
    if (t) C.push_back(t);
    return C;
}
```
2024-07-16 15:38:06.199 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度减法
[算法代码]
```
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
 
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
2024-07-16 15:38:06.201 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]高精度减法
2024-07-16 15:38:06.201 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
 
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
2024-07-16 15:38:06.202 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度乘低精度
[算法代码]
```
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
 
    return C;
}
```
2024-07-16 15:38:06.202 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]高精度乘低精度
2024-07-16 15:38:06.203 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
 
    return C;
}
```
2024-07-16 15:38:06.203 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高精度除以低精度
[算法代码]
```
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
2024-07-16 15:38:06.205 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]高精度除以低精度
2024-07-16 15:38:06.205 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
2024-07-16 15:38:06.206 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
子矩阵的和
[算法代码]
```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 15:38:06.207 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]子矩阵的和
2024-07-16 15:38:06.207 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 15:38:06.207 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
差分矩阵
[算法代码]
```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
    b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```\n\n-----\d+-----
[算法名称]
双指针算法
[算法代码]
```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 15:38:06.208 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]差分矩阵
2024-07-16 15:38:06.208 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
    b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 15:38:06.209 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
数据离散化_保序离散化
[算法代码]
```
vector<int> alls; 
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end()); 
 
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
```
2024-07-16 15:38:06.210 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]数据离散化_保序离散化
2024-07-16 15:38:06.210 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
vector<int> alls; 
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end()); 
 
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
```
2024-07-16 15:38:06.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
数据离散化_非保序离散化
[算法代码]
```
unordered_map<int,int> mp;
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```
2024-07-16 15:38:06.212 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 15:38:06.212 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```
2024-07-16 15:38:06.213 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
RMQ
[算法代码] 
```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:38:06.214 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.214 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:38:06.214 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.215 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:38:06.215 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.216 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:38:06.216 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.217 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:38:06.217 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.218 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:38:06.219 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.219 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:38:06.221 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.221 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:38:06.222 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.222 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:38:06.223 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.223 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
欧拉函数
[算法代码] 
```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:38:06.224 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.224 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:38:06.226 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:38:06.227 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.227 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:38:06.228 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.229 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:38:06.230 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.230 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:38:06.231 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.231 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:38:06.232 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.233 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:38:06.234 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.235 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:38:06.235 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.236 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:38:06.236 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.237 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Lucas定理
[算法代码] 
```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:38:06.238 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.238 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:38:06.240 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.240 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
树的直径 
[算法代码] 
```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP 
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:38:06.242 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.242 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:38:06.245 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.246 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素版spfa
[算法代码] 
```
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:38:06.248 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.248 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:38:06.250 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.251 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:38:06.253 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.253 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
loyd算法 O(n^3)
[算法代码] 
```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:38:06.255 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.255 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:38:06.257 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.258 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:38:06.262 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.262 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:38:06.264 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.265 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
倍增在线算法
[算法代码] 
```
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:38:06.268 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.268 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:38:06.271 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.271 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:38:06.275 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.275 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:38:06.280 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.280 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:38:06.283 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.283 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:38:06.285 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.286 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:38:06.287 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.287 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:38:06.290 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:06.291 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
单调栈
[算法代码]
```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
\n\n-----\d+-----
[算法名称]
单调队列
[算法代码]
```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```
2024-07-16 15:38:06.293 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]单调栈
2024-07-16 15:38:06.293 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
2024-07-16 15:38:06.294 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
朴素并查集
[算法代码]
```
    int p[N]; 
 
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;
 
    p[find(a)] = find(b);
```
2024-07-16 15:38:06.295 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]朴素并查集
2024-07-16 15:38:06.296 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
    int p[N]; 
 
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;
 
    p[find(a)] = find(b);
```
2024-07-16 15:38:06.297 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
维护size的并查集
[算法代码]
```
    int p[N], size[N];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
 
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```
2024-07-16 15:38:06.299 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]维护size的并查集
2024-07-16 15:38:06.299 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
    int p[N], size[N];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
 
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```
2024-07-16 15:38:06.301 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
维护到祖宗节点距离的并查集
[算法代码]
```
    int p[N], d[N];
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
 
    p[find(a)] = find(b);
    d[find(a)] = distance; 
```
2024-07-16 15:38:06.303 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 15:38:06.303 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
    int p[N], d[N];
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
 
    p[find(a)] = find(b);
    d[find(a)] = distance; 
```
2024-07-16 15:38:06.305 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
字符串哈希
[算法代码]
```
typedef unsigned long long ULL;
ULL h[N], p[N]; 
 
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}
 
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 15:38:06.307 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]字符串哈希
2024-07-16 15:38:06.307 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
typedef unsigned long long ULL;
ULL h[N], p[N]; 
 
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}
 
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 15:38:06.309 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
KMP
[算法代码]
```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
	int n;cin >>n>>p+1; 
	int m;cin >>m>>s+1;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1]) j++;
		ne[i]=j;
	} 
	for(int i=1,j=0;i<=m;i++)
	{
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1]) j++;
		//max_p=max(max_p,j);
		if(j==n)
		{
			cout <<i-n<<" ";
			j=ne[j];
		} 
	}
}
```
2024-07-16 15:38:06.311 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]KMP
2024-07-16 15:38:06.311 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
	int n;cin >>n>>p+1; 
	int m;cin >>m>>s+1;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1]) j++;
		ne[i]=j;
	} 
	for(int i=1,j=0;i<=m;i++)
	{
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1]) j++;
		//max_p=max(max_p,j);
		if(j==n)
		{
			cout <<i-n<<" ";
			j=ne[j];
		} 
	}
}
```
2024-07-16 15:38:06.313 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
线段树(单点修改)
[算法代码]
```
int n,m;
 
struct node
{
	int l,r;  
	int sum;   
	int lmax; 
	int rmax; 
	int tmax;  
}tr[N*4];
 
void pushup(node &u,node &l,node &r)
{
	u.sum=l.sum+r.sum;
	u.lmax=max(l.lmax,l.sum+r.lmax); 
	u.rmax=max(r.rmax,r.sum+l.rmax);
	u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
 
void pushup(int u)
{
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
 
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
	else
	{	tr[u]={l,r};
		int mid=l+r>>1;	
		build(u<<1,l,mid);	
		build(u<<1|1,mid+1,r);
		pushup(u);
	}
}
 
void modify(int u,int x,int v)
{
	if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v}; 
	else 
	{
		int mid=tr[u].l+tr[u].r>>1;	
		if(x<=mid) modify(u<<1,x,v);
		else modify(u<<1|1,x,v);	
		pushup(u);	
	}
}
 
node query(int u,int l,int r) 
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u]; 
	else
	{	
		int mid=tr[u].l+tr[u].r>>1;  
		if(r<=mid) return query(u<<1,l,r);
		else if(l>mid) return query(u<<1|1,l,r); 
		else 
		{
			auto left=query(u<<1,l,r);   
			auto right=query(u<<1|1,l,r);	
			node res;
			pushup(res,left,right);  
			return res;
		}	
	}
}
```
2024-07-16 15:38:06.317 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]线段树(单点修改)
2024-07-16 15:38:06.318 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
int n,m;
 
struct node
{
	int l,r;  
	int sum;   
	int lmax; 
	int rmax; 
	int tmax;  
}tr[N*4];
 
void pushup(node &u,node &l,node &r)
{
	u.sum=l.sum+r.sum;
	u.lmax=max(l.lmax,l.sum+r.lmax); 
	u.rmax=max(r.rmax,r.sum+l.rmax);
	u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
 
void pushup(int u)
{
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
 
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
	else
	{	tr[u]={l,r};
		int mid=l+r>>1;	
		build(u<<1,l,mid);	
		build(u<<1|1,mid+1,r);
		pushup(u);
	}
}
 
void modify(int u,int x,int v)
{
	if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v}; 
	else 
	{
		int mid=tr[u].l+tr[u].r>>1;	
		if(x<=mid) modify(u<<1,x,v);
		else modify(u<<1|1,x,v);	
		pushup(u);	
	}
}
 
node query(int u,int l,int r) 
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u]; 
	else
	{	
		int mid=tr[u].l+tr[u].r>>1;  
		if(r<=mid) return query(u<<1,l,r);
		else if(l>mid) return query(u<<1|1,l,r); 
		else 
		{
			auto left=query(u<<1,l,r);   
			auto right=query(u<<1|1,l,r);	
			node res;
			pushup(res,left,right);  
			return res;
		}	
	}
}
```
2024-07-16 15:38:06.322 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
线段树(区间修改)
[算法代码]
```
struct node
{
	ll l,r;  
	ll sum;
	ll add;	
	ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
    root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
    root.mul=root.mul*mul%p;
    root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
	tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
    eval(tr[u<<1],tr[u].add,tr[u].mul);
    eval(tr[u<<1|1],tr[u].add,tr[u].mul);
    tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],0,1};
	else
	{	tr[u]={l,r,0,0,1};	
		int mid=l+r>>1;	
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);	
		pushup(u);	
	}
}
 
void modify(int u,int l,int r,int add,int mul)
{
	if(tr[u].l>=l&&tr[u].r<=r)
	{
		eval(tr[u],add,mul);
	}
	else 
	{
		pushdown(u);
		int mid=tr[u].l+tr[u].r>>1;	
		if(l<=mid) modify(u<<1,l,r,add,mul); 
		if(r>mid) modify(u<<1|1,l,r,add,mul);	
		pushup(u);
	}
}
 
node query(int u,int l,int r)   
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	else
	{	
	    pushdown(u);
		node res;
		res.sum=0;
		int mid=tr[u].l+tr[u].r>>1; 
		if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
		if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
		pushup(u);
		return res;
	}
}
```
2024-07-16 15:38:06.326 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]线段树(区间修改)
2024-07-16 15:38:06.327 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
struct node
{
	ll l,r;  
	ll sum;
	ll add;	
	ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
    root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
    root.mul=root.mul*mul%p;
    root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
	tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
    eval(tr[u<<1],tr[u].add,tr[u].mul);
    eval(tr[u<<1|1],tr[u].add,tr[u].mul);
    tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],0,1};
	else
	{	tr[u]={l,r,0,0,1};	
		int mid=l+r>>1;	
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);	
		pushup(u);	
	}
}
 
void modify(int u,int l,int r,int add,int mul)
{
	if(tr[u].l>=l&&tr[u].r<=r)
	{
		eval(tr[u],add,mul);
	}
	else 
	{
		pushdown(u);
		int mid=tr[u].l+tr[u].r>>1;	
		if(l<=mid) modify(u<<1,l,r,add,mul); 
		if(r>mid) modify(u<<1|1,l,r,add,mul);	
		pushup(u);
	}
}
 
node query(int u,int l,int r)   
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	else
	{	
	    pushdown(u);
		node res;
		res.sum=0;
		int mid=tr[u].l+tr[u].r>>1; 
		if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
		if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
		pushup(u);
		return res;
	}
}
```
2024-07-16 15:38:06.331 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
树状数组
[算法代码]
```
int lowbit(int x)
{
	return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
	return res; 
}
```
2024-07-16 15:38:06.333 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]树状数组
2024-07-16 15:38:06.333 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
int lowbit(int x)
{
	return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
	return res; 
}
```
2024-07-16 15:38:06.334 | DEBUG    | sql.local_to_db:CodeLocalToDB:28 - [text][算法名称]
Trie树
[算法代码]
```
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
 
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```
2024-07-16 15:38:06.336 | DEBUG    | sql.local_to_db:CodeLocalToDB:33 - [algorithm_name]Trie树
2024-07-16 15:38:06.337 | DEBUG    | sql.local_to_db:CodeLocalToDB:34 - [code]```
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
 
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```
2024-07-16 15:38:36.467 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.468 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.468 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.469 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.469 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.469 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.470 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.470 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.470 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.471 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.471 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.471 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.472 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.472 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.473 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.473 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.473 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.473 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.474 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.474 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.475 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.475 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.475 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.476 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.476 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.476 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.477 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.477 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.477 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.478 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.478 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.478 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.478 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.479 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.479 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.479 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.480 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.480 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:38:36.480 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
2024-07-16 15:39:05.439 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:39:05.440 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
RMQ
[算法代码] 
```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:39:05.441 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:39:05.442 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:39:05.443 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:39:05.444 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:39:05.445 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:39:05.447 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:39:05.449 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:39:05.450 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:39:05.451 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
欧拉函数
[算法代码] 
```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:39:05.451 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:39:05.453 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:39:05.454 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:39:05.455 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:39:05.457 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:39:05.457 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:39:05.459 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:39:05.460 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:39:05.461 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:39:05.463 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
Lucas定理
[算法代码] 
```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:39:05.464 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:39:05.465 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
树的直径 
[算法代码] 
```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP 
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:39:05.466 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
朴素版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:39:05.469 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
朴素版spfa
[算法代码] 
```
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:39:05.470 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:39:05.472 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:39:05.474 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
loyd算法 O(n^3)
[算法代码] 
```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:39:05.475 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:39:05.477 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:39:05.478 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:39:05.479 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
倍增在线算法
[算法代码] 
```
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:39:05.481 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:39:05.483 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:39:05.485 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:39:05.488 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:39:05.490 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:39:05.491 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:39:05.492 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容[text][算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:39:34.089 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:39:34.090 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
RMQ
[算法代码] 
```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:39:34.091 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:39:34.092 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:39:34.093 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:39:34.094 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:39:34.095 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:39:34.096 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:39:34.098 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:39:34.099 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:39:34.100 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
欧拉函数
[算法代码] 
```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:39:34.100 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:39:34.101 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:39:34.102 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:39:34.103 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:39:34.104 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:39:34.105 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:39:34.106 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:39:34.108 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:39:34.108 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:39:34.109 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
Lucas定理
[算法代码] 
```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:39:34.111 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:39:34.112 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
树的直径 
[算法代码] 
```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP 
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:39:34.113 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
朴素版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:39:34.116 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
朴素版spfa
[算法代码] 
```
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:39:34.117 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:39:34.118 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:39:34.120 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
loyd算法 O(n^3)
[算法代码] 
```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:39:34.122 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:39:34.123 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:39:34.124 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:39:34.126 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
倍增在线算法
[算法代码] 
```
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:39:34.128 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:39:34.130 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:39:34.132 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:39:34.135 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:39:34.137 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:39:34.138 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:39:34.139 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 没有找到匹配的内容
[text][算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:41:22.636 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:41:22.637 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
RMQ
[算法代码] 
```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:41:22.638 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:41:22.639 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:41:22.640 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:41:22.641 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:41:22.641 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:41:22.643 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:41:22.645 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:41:22.646 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:41:22.646 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
欧拉函数
[算法代码] 
```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:41:22.647 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:41:22.648 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:41:22.649 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:41:22.651 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:41:22.652 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:41:22.652 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:41:22.654 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:41:22.655 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:41:22.656 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:41:22.657 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
Lucas定理
[算法代码] 
```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:41:22.659 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:41:22.660 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
树的直径 
[算法代码] 
```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP 
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:41:22.661 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
朴素版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:41:22.664 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
朴素版spfa
[算法代码] 
```
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:41:22.666 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:41:22.667 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:41:22.668 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
loyd算法 O(n^3)
[算法代码] 
```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:41:22.670 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:41:22.671 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:41:22.673 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:41:22.674 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
倍增在线算法
[算法代码] 
```
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:41:22.676 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:41:22.677 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:41:22.680 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:41:22.682 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:41:22.683 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:41:22.685 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:41:22.686 | ERROR    | sql.local_to_db:CodeLocalToDB:37 - 没有找到匹配的内容
[text][算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:42:59.877 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:42:59.879 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
RMQ
[算法代码] 
```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:42:59.880 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:42:59.881 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:42:59.881 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:42:59.882 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:42:59.884 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:42:59.885 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:42:59.887 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:42:59.887 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:42:59.888 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
欧拉函数
[算法代码] 
```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:42:59.889 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:42:59.891 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:42:59.892 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:42:59.893 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:42:59.894 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:42:59.895 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:42:59.896 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:42:59.898 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:42:59.899 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:42:59.900 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
Lucas定理
[算法代码] 
```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:42:59.902 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:42:59.903 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
树的直径 
[算法代码] 
```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP 
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:42:59.905 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
朴素版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:42:59.907 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
朴素版spfa
[算法代码] 
```
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:42:59.909 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:42:59.911 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:42:59.913 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
loyd算法 O(n^3)
[算法代码] 
```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:42:59.914 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:42:59.915 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:42:59.918 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:42:59.919 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
倍增在线算法
[算法代码] 
```
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:42:59.921 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:42:59.923 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:42:59.926 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:42:59.929 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:42:59.930 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:42:59.932 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:42:59.933 | ERROR    | sql.local_to_db:CodeLocalToDB:38 - 没有找到匹配的内容
[text][算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:46:27.607 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:46:27.609 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
RMQ
[算法代码] 
```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:46:27.610 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:46:27.610 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:46:27.611 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:46:27.612 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:46:27.613 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:46:27.614 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:46:27.616 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:46:27.617 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:46:27.617 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
欧拉函数
[算法代码] 
```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:46:27.618 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:46:27.620 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:46:27.621 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:46:27.622 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:46:27.623 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:46:27.624 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:46:27.625 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:46:27.627 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:46:27.627 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:46:27.628 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
Lucas定理
[算法代码] 
```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:46:27.629 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:46:27.631 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
树的直径 
[算法代码] 
```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP 
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:46:27.632 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
朴素版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:46:27.635 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
朴素版spfa
[算法代码] 
```
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:46:27.636 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:46:27.637 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:46:27.638 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
loyd算法 O(n^3)
[算法代码] 
```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:46:27.640 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:46:27.641 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:46:27.643 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:46:27.644 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
倍增在线算法
[算法代码] 
```
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:46:27.645 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:46:27.648 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:46:27.650 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:46:27.652 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:46:27.654 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:46:27.655 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:46:27.656 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text][算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:46:58.302 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
浮点数二分
[算法代码] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```
2024-07-16 15:46:58.303 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
RMQ
[算法代码] 
```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 15:46:58.305 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
试除法判定质数
[算法代码] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```
2024-07-16 15:46:58.306 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
试除法分解质因数
[算法代码] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```
2024-07-16 15:46:58.307 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
朴素素数筛法
[算法代码] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
2024-07-16 15:46:58.308 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
线性素数筛法
[算法代码] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
2024-07-16 15:46:58.309 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
区间素数筛法
[算法代码] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```
2024-07-16 15:46:58.311 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
Min_25
[算法代码] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```
2024-07-16 15:46:58.313 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
试除法求约数
[算法代码] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```
2024-07-16 15:46:58.314 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
欧几里得算法
[算法代码] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```
2024-07-16 15:46:58.315 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
欧拉函数
[算法代码] 
```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```
2024-07-16 15:46:58.316 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
筛法求欧拉函数
[算法代码] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```
2024-07-16 15:46:58.318 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
卡特兰数求模
[算法代码] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 15:46:58.319 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
快速求第n位卡特兰数
[算法代码] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```
2024-07-16 15:46:58.321 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
Java大数打表卡特兰数
[算法代码] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```
2024-07-16 15:46:58.323 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
快速幂
[算法代码] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```
2024-07-16 15:46:58.324 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
位运算处理大数相乘
[算法代码] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```
\n\n-----\d+-----
[算法名称]
扩展欧几里得算法
[算法代码] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```
2024-07-16 15:46:58.326 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
高斯消元
[算法代码] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```
2024-07-16 15:46:58.328 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
递归法求组合数
[算法代码] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```
2024-07-16 15:46:58.329 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
预处理逆元的方式求组合数
[算法代码] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 15:46:58.331 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
Lucas定理
[算法代码] 
```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 15:46:58.333 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
有向图的拓扑序
[算法代码] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```
2024-07-16 15:46:58.335 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
树的直径 
[算法代码] 
```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP 
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```
2024-07-16 15:46:58.337 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
朴素版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[算法名称]
堆优化版Dijkstra
[算法代码] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```
2024-07-16 15:46:58.340 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
朴素版spfa
[算法代码] 
```
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```
2024-07-16 15:46:58.342 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
SFA优化版的spfa
[算法代码] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```
2024-07-16 15:46:58.345 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
SPFA判负环正环
[算法代码] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```
2024-07-16 15:46:58.347 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
loyd算法 O(n^3)
[算法代码] 
```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```
2024-07-16 15:46:58.349 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
prim算法
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```
2024-07-16 15:46:58.351 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
kruskal算法
[算法代码] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```
2024-07-16 15:46:58.353 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
最小生成森林
[算法代码] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```
2024-07-16 15:46:58.355 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
倍增在线算法
[算法代码] 
```
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```
2024-07-16 15:46:58.358 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
targin离线算法
[算法代码] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```
2024-07-16 15:46:58.360 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:46:58.364 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:46:58.367 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:46:58.369 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:46:58.371 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:46:58.372 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:48:33.181 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
-----53-----
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:48:33.184 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:48:33.187 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:48:33.190 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:48:33.191 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:48:33.193 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:49:51.251 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:49:51.254 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:49:51.257 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:49:51.258 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:49:51.260 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:49:51.261 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:50:18.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:36 - [algorithm_name]__int128读写模板子
2024-07-16 15:50:18.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:37 - [code]
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}

2024-07-16 15:50:18.973 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:50:18.974 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:50:18.977 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:50:18.978 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:50:18.979 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:50:18.980 | ERROR    | sql.local_to_db:CodeLocalToDB:39 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:53:30.977 | ERROR    | sql.local_to_db:CodeLocalToDB:36 - 找到匹配的内容
[text]
-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:53:30.979 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:53:30.981 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:53:30.984 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:53:30.985 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:53:30.986 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:53:30.988 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:53:55.883 | DEBUG    | sql.local_to_db:CodeLocalToDB:36 - 找到匹配的内容
[text]
-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:53:55.885 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:53:55.887 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:53:55.891 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:53:55.892 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:53:55.893 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:53:55.894 | ERROR    | sql.local_to_db:CodeLocalToDB:40 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:57:00.311 | DEBUG    | sql.local_to_db:CodeLocalToDB:37 - 找到匹配的内容
[text]
-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:57:00.312 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:57:00.315 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:57:00.317 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:57:00.319 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
2024-07-16 15:57:00.320 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:57:00.321 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:57:19.991 | DEBUG    | sql.local_to_db:CodeLocalToDB:37 - 找到匹配的内容
[text]
-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
\n\n-----\d+-----
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:57:19.995 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:57:19.997 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
\n\n-----\d+-----
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
\n\n-----\d+-----
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:57:20.000 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 15:57:59.451 | DEBUG    | sql.local_to_db:CodeLocalToDB:37 - 找到匹配的内容
[text]
-----1-----
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 15:57:59.453 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 15:57:59.455 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 15:57:59.457 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 15:57:59.459 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
\n\n-----\d+-----
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 15:57:59.461 | ERROR    | sql.local_to_db:CodeLocalToDB:41 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 16:00:29.710 | DEBUG    | sql.local_to_db:CodeLocalToDB:38 - 找到匹配的内容
[text]
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 16:00:29.712 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```
2024-07-16 16:00:29.714 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 16:00:29.717 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 16:00:29.719 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
\n\n-----\d+-----
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 16:00:29.721 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 16:01:21.254 | DEBUG    | sql.local_to_db:CodeLocalToDB:38 - 找到匹配的内容
[text]
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 16:01:21.258 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u){
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++){
    if(!dfn[i])
        tarjan(i);
}
for(int i=1;i<=n;i++){
    for(int j=h[i];~j;j=ne[j])
    {
        int k=e[j];
        int a=id[i],b=id[k];
        if(a!=b) dout[a]++;
    }
}
```
2024-07-16 16:01:21.260 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 16:01:21.263 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 16:01:21.264 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
\n\n-----\d+-----
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 16:01:21.267 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[text]
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 16:02:37.045 | DEBUG    | sql.local_to_db:CodeLocalToDB:38 - 找到匹配的内容
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 16:02:37.047 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u){
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++){
    if(!dfn[i])
        tarjan(i);
}
for(int i=1;i<=n;i++){
    for(int j=h[i];~j;j=ne[j])
    {
        int k=e[j];
        int a=id[i],b=id[k];
        if(a!=b) dout[a]++;
    }
}
```
2024-07-16 16:02:37.049 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 16:02:37.051 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 16:02:37.052 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
\n\n-----\d+-----
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 16:02:37.054 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 16:03:11.491 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u){
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++){
    if(!dfn[i])
        tarjan(i);
}
for(int i=1;i<=n;i++){
    for(int j=h[i];~j;j=ne[j])
    {
        int k=e[j];
        int a=id[i],b=id[k];
        if(a!=b) dout[a]++;
    }
}
```
2024-07-16 16:03:11.493 | DEBUG    | sql.local_to_db:CodeLocalToDB:38 - 找到匹配的内容
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 16:03:11.495 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 16:03:11.498 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 16:03:11.500 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
\n\n-----\d+-----
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 16:03:11.502 | ERROR    | sql.local_to_db:CodeLocalToDB:42 - 没有找到匹配的内容
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 16:11:17.227 | ERROR    | sql.local_to_db:CodeLocalToDB:43 - 没有找到匹配的内容
[算法名称]
有向图的强连通分量
[算法代码] 
```
void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u){
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++){
    if(!dfn[i])
        tarjan(i);
}
for(int i=1;i<=n;i++){
    for(int j=h[i];~j;j=ne[j])
    {
        int k=e[j];
        int a=id[i],b=id[k];
        if(a!=b) dout[a]++;
    }
}
```
2024-07-16 16:11:17.229 | DEBUG    | sql.local_to_db:CodeLocalToDB:39 - 找到匹配的内容
[算法名称]
__int128读写模板子
[算法代码]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```
2024-07-16 16:11:17.230 | ERROR    | sql.local_to_db:CodeLocalToDB:43 - 没有找到匹配的内容
[算法名称]
无向图的点双连通分量
[算法代码] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
    }
}
```
2024-07-16 16:11:17.233 | ERROR    | sql.local_to_db:CodeLocalToDB:43 - 没有找到匹配的内容
[算法名称]
二分图
[算法代码] 
```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```
2024-07-16 16:11:17.234 | ERROR    | sql.local_to_db:CodeLocalToDB:43 - 没有找到匹配的内容
[算法名称]
匈牙利算法
[算法代码] 
```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```
\n\n-----\d+-----
[算法名称]
单链表
[算法代码] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```
2024-07-16 16:11:17.236 | ERROR    | sql.local_to_db:CodeLocalToDB:43 - 没有找到匹配的内容
[算法名称]
双链表
[算法代码] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```
2024-07-16 16:27:56.777 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_name]有向图的强连通分量
2024-07-16 16:27:56.778 | DEBUG    | sql.local_to_db:CodeLocalToDB:48 - [algorithm_code]```
void add(int a, int b){
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u){
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++){
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++){
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 16:36:46.807 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 16:36:46.808 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b){
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u){
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++){
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++){
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 16:36:46.810 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b){
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u){
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++){
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++){
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 16:36:46.814 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 16:36:46.815 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 16:36:46.816 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 16:36:46.819 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 16:36:46.820 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 16:36:46.822 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 16:36:46.827 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 16:36:46.828 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 16:36:46.829 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 16:36:46.833 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 16:36:46.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 16:36:46.835 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 16:36:46.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 16:36:46.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 16:36:46.840 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 16:36:46.843 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 16:36:46.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 16:36:46.845 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 16:36:46.849 | DEBUG    | __main__:<module>:48 - Describe of local to DB successful
2024-07-16 16:40:05.309 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 16:40:05.310 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b){
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u){
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++){
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++){
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 16:40:05.311 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b){
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u){
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++){
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++){
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 16:40:05.315 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 16:40:05.316 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 16:40:05.317 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 16:40:05.321 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 16:40:05.322 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 16:40:05.325 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 16:40:05.330 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 16:40:05.331 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 16:40:05.333 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 16:40:05.337 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 16:40:05.337 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 16:40:05.339 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 16:40:05.342 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 16:40:05.343 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 16:40:05.344 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 16:40:05.348 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 16:40:05.348 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 16:40:05.349 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 16:53:10.029 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 16:53:10.030 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 16:53:10.031 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 16:53:10.032 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 16:53:10.033 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 16:53:10.034 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 16:53:10.034 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 16:53:10.035 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 16:53:10.036 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 16:53:10.037 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 16:53:10.038 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 16:53:10.039 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 16:53:10.040 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 16:53:10.041 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 16:53:10.041 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 16:53:10.043 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 16:53:10.043 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 16:53:10.045 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 16:53:10.045 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 16:53:10.046 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 16:53:10.047 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 16:53:10.048 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 16:53:10.049 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 16:53:10.050 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 16:53:10.051 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 16:53:10.052 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 16:53:10.053 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 16:53:10.054 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 16:53:10.055 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 16:53:10.055 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 16:53:10.056 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 16:53:10.057 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 16:53:10.057 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 16:53:10.058 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 16:53:10.059 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 16:53:10.059 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 16:53:10.060 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 16:53:10.061 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 16:53:10.061 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 16:53:10.062 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 16:53:10.062 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 16:53:10.063 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 16:53:10.064 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 16:53:10.065 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 16:53:10.066 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 16:53:10.066 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 16:53:10.067 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 16:53:10.068 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 16:53:10.068 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 16:53:10.069 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 16:53:10.070 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 16:53:10.070 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 16:53:10.072 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 16:53:10.073 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 16:53:10.074 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 16:53:10.075 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 16:53:10.076 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 16:53:10.076 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 16:53:10.077 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 16:53:10.078 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 16:53:10.079 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 16:53:10.080 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 16:53:10.081 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 16:53:10.082 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 16:53:10.083 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 16:53:10.084 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 16:53:10.085 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 16:53:45.837 | DEBUG    | __main__:algorithm_chat:28 - [message]整数二分
2024-07-16 16:53:45.837 | DEBUG    | __main__:algorithm_chat:29 - [history][]
2024-07-16 16:53:47.616 | DEBUG    | __main__:algorithm_chat:36 - [input]整数二分
2024-07-16 16:53:47.616 | DEBUG    | __main__:algorithm_chat:37 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：\nbsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。\nbsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。\n\n应用场景:\n该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。\n\n时间复杂度:\n二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。\n\n[回答]\n(整数二分)')]
2024-07-16 16:53:47.617 | DEBUG    | __main__:algorithm_chat:38 - [answer]对不起，我之前的回答没有遵循您的指示。根据您的要求，以下是正确的回答：

整数二分
2024-07-16 18:22:07.958 | DEBUG    | __main__:algorithm_chat:29 - [message]整数二分
2024-07-16 18:22:07.959 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-16 18:22:10.149 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:22:10.151 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:22:10.151 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:22:10.152 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:22:10.152 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:22:10.153 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:22:10.155 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:22:10.156 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:22:10.157 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:22:10.158 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:22:10.159 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:22:10.160 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:22:10.161 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:22:10.162 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:22:10.163 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:22:10.165 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:22:10.166 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:22:10.166 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:22:10.168 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:22:10.169 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:22:10.171 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:22:10.172 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:22:10.173 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:22:10.174 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:22:10.176 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:22:10.177 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:22:10.178 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:22:10.179 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:22:10.180 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:22:10.180 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:22:10.181 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:22:10.182 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:22:10.183 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:22:10.184 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:22:10.186 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:22:10.186 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:22:10.187 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:22:10.188 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:22:10.189 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:22:10.190 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:22:10.191 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:22:10.192 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:22:10.193 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:22:10.193 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:22:10.194 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:22:10.195 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:22:10.195 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:22:10.197 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:22:10.197 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:22:10.199 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:22:10.200 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:22:10.201 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:22:10.202 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:22:10.203 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:22:10.205 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:22:10.206 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:22:10.207 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:22:10.208 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:22:10.209 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:22:10.209 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:22:10.211 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:22:10.212 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:22:10.213 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:22:10.214 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:22:10.215 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:22:10.217 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:22:10.218 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:22:29.572 | ERROR    | __main__:algorithm_chat:36 - Error invoking retrieval chain: unhashable type: 'list'
2024-07-16 18:30:07.040 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:30:07.041 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:30:07.042 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:30:07.043 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:30:07.044 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:30:07.045 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:30:07.046 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:30:07.047 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:30:07.047 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:30:07.048 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:30:07.049 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:30:07.050 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:30:07.051 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:30:07.053 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:30:07.053 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:30:07.054 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:30:07.055 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:30:07.057 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:30:07.058 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:30:07.059 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:30:07.059 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:30:07.060 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:30:07.061 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:30:07.062 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:30:07.063 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:30:07.064 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:30:07.065 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:30:07.066 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:30:07.067 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:30:07.068 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:30:07.068 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:30:07.069 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:30:07.070 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:30:07.071 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:30:07.072 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:30:07.072 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:30:07.073 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:30:07.073 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:30:07.074 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:30:07.075 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:30:07.075 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:30:07.076 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:30:07.077 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:30:07.078 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:30:07.079 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:30:07.079 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:30:07.080 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:30:07.081 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:30:07.081 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:30:07.082 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:30:07.083 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:30:07.084 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:30:07.085 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:30:07.086 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:30:07.087 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:30:07.087 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:30:07.088 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:30:07.089 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:30:07.090 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:30:07.091 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:30:07.092 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:30:07.093 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:30:07.094 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:30:07.094 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:30:07.096 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:30:07.097 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:30:07.098 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:31:26.895 | DEBUG    | __main__:algorithm_chat:30 - [message]整数二分
2024-07-16 18:31:26.896 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:31:26.897 | ERROR    | __main__:algorithm_chat:36 - Error invoking retrieval chain: Function must have a docstring if description not provided.
2024-07-16 18:33:55.956 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:33:55.957 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:33:55.958 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:33:55.959 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:33:55.960 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:33:55.960 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:33:55.961 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:33:55.962 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:33:55.963 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:33:55.964 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:33:55.965 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:33:55.965 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:33:55.966 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:33:55.968 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:33:55.969 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:33:55.970 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:33:55.971 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:33:55.971 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:33:55.972 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:33:55.974 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:33:55.974 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:33:55.975 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:33:55.976 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:33:55.977 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:33:55.978 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:33:55.979 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:33:55.980 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:33:55.981 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:33:55.982 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:33:55.983 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:33:55.983 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:33:55.984 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:33:55.984 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:33:55.985 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:33:55.985 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:33:55.986 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:33:55.987 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:33:55.988 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:33:55.989 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:33:55.989 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:33:55.990 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:33:55.990 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:33:55.991 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:33:55.992 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:33:55.993 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:33:55.994 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:33:55.995 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:33:55.996 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:33:55.997 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:33:55.997 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:33:55.998 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:33:55.999 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:33:55.999 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:33:56.001 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:33:56.002 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:33:56.002 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:33:56.003 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:33:56.004 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:33:56.005 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:33:56.005 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:33:56.006 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:33:56.007 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:33:56.009 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:33:56.010 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:33:56.011 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:33:56.012 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:33:56.013 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:34:51.373 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树
2024-07-16 18:34:51.373 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:34:51.373 | ERROR    | chatbot.function_agent:GetAlgorithmCode:45 - Error building tools: Function must have a docstring if description not provided.
2024-07-16 18:34:51.373 | ERROR    | __main__:algorithm_chat:36 - Error invoking retrieval chain: cannot access local variable 'tools' where it is not associated with a value
2024-07-16 18:36:05.261 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:36:05.263 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:36:05.264 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:36:05.265 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:36:05.265 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:36:05.266 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:36:05.267 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:36:05.268 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:36:05.269 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:36:05.270 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:36:05.271 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:36:05.272 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:36:05.273 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:36:05.274 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:36:05.275 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:36:05.276 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:36:05.277 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:36:05.278 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:36:05.279 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:36:05.279 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:36:05.280 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:36:05.281 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:36:05.282 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:36:05.283 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:36:05.284 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:36:05.285 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:36:05.286 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:36:05.287 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:36:05.287 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:36:05.288 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:36:05.289 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:36:05.291 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:36:05.291 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:36:05.292 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:36:05.293 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:36:05.293 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:36:05.294 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:36:05.294 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:36:05.295 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:36:05.296 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:36:05.297 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:36:05.298 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:36:05.299 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:36:05.299 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:36:05.300 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:36:05.300 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:36:05.301 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:36:05.302 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:36:05.303 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:36:05.304 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:36:05.305 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:36:05.307 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:36:05.309 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:36:05.311 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:36:05.312 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:36:05.313 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:36:05.314 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:36:05.315 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:36:05.315 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:36:05.316 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:36:05.317 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:36:05.318 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:36:05.320 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:36:05.320 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:36:05.322 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:36:05.323 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:36:05.324 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:36:40.839 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树prim算法
2024-07-16 18:36:40.840 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:36:40.841 | ERROR    | __main__:algorithm_chat:36 - Error invoking retrieval chain: 'prompt'
2024-07-16 18:38:37.730 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:38:37.732 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:38:37.733 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:38:37.734 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:38:37.735 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:38:37.736 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:38:37.737 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:38:37.738 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:38:37.738 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:38:37.739 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:38:37.740 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:38:37.741 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:38:37.742 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:38:37.743 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:38:37.744 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:38:37.745 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:38:37.746 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:38:37.746 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:38:37.747 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:38:37.748 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:38:37.749 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:38:37.750 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:38:37.752 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:38:37.752 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:38:37.753 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:38:37.754 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:38:37.755 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:38:37.756 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:38:37.756 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:38:37.757 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:38:37.758 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:38:37.758 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:38:37.759 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:38:37.760 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:38:37.760 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:38:37.761 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:38:37.762 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:38:37.763 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:38:37.763 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:38:37.764 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:38:37.765 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:38:37.766 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:38:37.766 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:38:37.767 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:38:37.767 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:38:37.768 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:38:37.769 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:38:37.769 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:38:37.770 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:38:37.771 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:38:37.772 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:38:37.772 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:38:37.773 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:38:37.774 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:38:37.775 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:38:37.775 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:38:37.776 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:38:37.777 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:38:37.778 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:38:37.779 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:38:37.780 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:38:37.780 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:38:37.781 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:38:37.782 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:38:37.783 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:38:37.784 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:38:37.785 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:39:08.569 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树prim算法
2024-07-16 18:39:08.570 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:41:54.221 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:41:54.222 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:41:54.224 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:41:54.225 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:41:54.225 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:41:54.226 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:41:54.227 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:41:54.227 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:41:54.228 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:41:54.229 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:41:54.230 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:41:54.231 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:41:54.232 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:41:54.233 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:41:54.233 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:41:54.234 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:41:54.235 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:41:54.236 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:41:54.237 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:41:54.238 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:41:54.239 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:41:54.240 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:41:54.241 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:41:54.242 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:41:54.243 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:41:54.244 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:41:54.245 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:41:54.246 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:41:54.246 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:41:54.247 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:41:54.248 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:41:54.248 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:41:54.249 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:41:54.250 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:41:54.251 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:41:54.252 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:41:54.252 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:41:54.253 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:41:54.254 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:41:54.254 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:41:54.255 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:41:54.255 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:41:54.256 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:41:54.257 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:41:54.258 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:41:54.259 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:41:54.259 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:41:54.260 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:41:54.260 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:41:54.261 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:41:54.262 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:41:54.262 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:41:54.263 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:41:54.265 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:41:54.265 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:41:54.266 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:41:54.267 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:41:54.268 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:41:54.268 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:41:54.269 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:41:54.270 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:41:54.270 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:41:54.271 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:41:54.272 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:41:54.274 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:41:54.275 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:41:54.276 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:42:18.654 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树prim算法
2024-07-16 18:42:18.654 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:48:54.630 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:48:54.631 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:48:54.633 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:48:54.634 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:48:54.634 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:48:54.635 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:48:54.636 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:48:54.637 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:48:54.637 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:48:54.638 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:48:54.639 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:48:54.640 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:48:54.641 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:48:54.642 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:48:54.642 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:48:54.643 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:48:54.644 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:48:54.645 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:48:54.646 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:48:54.647 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:48:54.648 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:48:54.649 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:48:54.650 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:48:54.651 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:48:54.652 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:48:54.653 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:48:54.654 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:48:54.655 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:48:54.656 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:48:54.656 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:48:54.657 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:48:54.657 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:48:54.658 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:48:54.659 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:48:54.660 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:48:54.661 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:48:54.662 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:48:54.663 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:48:54.663 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:48:54.664 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:48:54.665 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:48:54.666 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:48:54.667 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:48:54.668 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:48:54.669 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:48:54.669 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:48:54.670 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:48:54.671 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:48:54.672 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:48:54.672 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:48:54.674 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:48:54.674 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:48:54.676 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:48:54.677 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:48:54.678 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:48:54.678 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:48:54.679 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:48:54.680 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:48:54.681 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:48:54.682 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:48:54.683 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:48:54.683 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:48:54.684 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:48:54.685 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:48:54.686 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:48:54.688 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:48:54.689 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:49:21.502 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树prim算法
2024-07-16 18:49:21.503 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:51:24.124 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:51:24.125 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:51:24.126 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:51:24.127 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:51:24.128 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:51:24.129 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:51:24.130 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:51:24.131 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:51:24.131 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:51:24.132 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:51:24.133 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:51:24.133 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:51:24.134 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:51:24.135 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:51:24.136 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:51:24.137 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:51:24.138 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:51:24.139 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:51:24.140 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:51:24.141 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:51:24.142 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:51:24.143 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:51:24.144 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:51:24.145 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:51:24.145 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:51:24.146 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:51:24.147 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:51:24.148 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:51:24.148 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:51:24.149 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:51:24.150 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:51:24.151 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:51:24.151 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:51:24.152 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:51:24.152 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:51:24.153 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:51:24.154 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:51:24.154 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:51:24.155 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:51:24.156 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:51:24.157 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:51:24.158 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:51:24.158 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:51:24.159 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:51:24.160 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:51:24.160 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:51:24.161 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:51:24.161 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:51:24.162 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:51:24.163 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:51:24.164 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:51:24.165 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:51:24.165 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:51:24.166 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:51:24.167 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:51:24.167 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:51:24.168 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:51:24.169 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:51:24.170 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:51:24.171 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:51:24.172 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:51:24.173 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:51:24.173 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:51:24.174 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:51:24.175 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:51:24.176 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:51:24.178 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:51:58.634 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树prim算法
2024-07-16 18:51:58.635 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:51:58.636 | ERROR    | chatbot.function_agent:GetAlgorithmCode:45 - Error building tools: Function must have a docstring if description not provided.
2024-07-16 18:54:07.190 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:54:07.191 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:54:07.192 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:54:07.193 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:54:07.193 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:54:07.194 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:54:07.195 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:54:07.196 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:54:07.197 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:54:07.197 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:54:07.198 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:54:07.199 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:54:07.200 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:54:07.202 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:54:07.203 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:54:07.203 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:54:07.204 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:54:07.205 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:54:07.206 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:54:07.207 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:54:07.208 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:54:07.209 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:54:07.210 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:54:07.211 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:54:07.212 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:54:07.213 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:54:07.213 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:54:07.214 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:54:07.214 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:54:07.215 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:54:07.216 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:54:07.216 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:54:07.217 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:54:07.217 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:54:07.218 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:54:07.219 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:54:07.220 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:54:07.220 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:54:07.221 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:54:07.222 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:54:07.223 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:54:07.223 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:54:07.224 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:54:07.225 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:54:07.225 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:54:07.226 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:54:07.227 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:54:07.228 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:54:07.228 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:54:07.229 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:54:07.230 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:54:07.231 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:54:07.231 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:54:07.232 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:54:07.233 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:54:07.234 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:54:07.235 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:54:07.236 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:54:07.237 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:54:07.237 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:54:07.238 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:54:07.239 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:54:07.240 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:54:07.241 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:54:07.242 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:54:07.243 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:54:07.244 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 18:54:31.730 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树prim算法
2024-07-16 18:54:31.731 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 18:58:28.529 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 18:58:28.530 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 18:58:28.532 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 18:58:28.533 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 18:58:28.534 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 18:58:28.535 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 18:58:28.535 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 18:58:28.536 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 18:58:28.537 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 18:58:28.538 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 18:58:28.539 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 18:58:28.540 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 18:58:28.541 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 18:58:28.541 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 18:58:28.542 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 18:58:28.543 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 18:58:28.544 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 18:58:28.545 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 18:58:28.546 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 18:58:28.547 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 18:58:28.548 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 18:58:28.549 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 18:58:28.550 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 18:58:28.552 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 18:58:28.553 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 18:58:28.554 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 18:58:28.555 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 18:58:28.556 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 18:58:28.557 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 18:58:28.557 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 18:58:28.558 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 18:58:28.559 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 18:58:28.559 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 18:58:28.560 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 18:58:28.561 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 18:58:28.562 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 18:58:28.562 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 18:58:28.563 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 18:58:28.563 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 18:58:28.564 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 18:58:28.565 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 18:58:28.566 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 18:58:28.567 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 18:58:28.568 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 18:58:28.569 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 18:58:28.569 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 18:58:28.570 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 18:58:28.571 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 18:58:28.571 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 18:58:28.572 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 18:58:28.573 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 18:58:28.574 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 18:58:28.575 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 18:58:28.576 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 18:58:28.577 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 18:58:28.577 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 18:58:28.578 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 18:58:28.579 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 18:58:28.580 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 18:58:28.581 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 18:58:28.582 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 18:58:28.583 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 18:58:28.583 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 18:58:28.584 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 18:58:28.585 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 18:58:28.586 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 18:58:28.587 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 19:02:22.425 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 19:02:22.427 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 19:02:22.428 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 19:02:22.429 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 19:02:22.429 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 19:02:22.430 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 19:02:22.431 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 19:02:22.432 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 19:02:22.433 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 19:02:22.433 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 19:02:22.434 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 19:02:22.435 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 19:02:22.436 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 19:02:22.437 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 19:02:22.438 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 19:02:22.438 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 19:02:22.439 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 19:02:22.440 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 19:02:22.441 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 19:02:22.443 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 19:02:22.444 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 19:02:22.444 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 19:02:22.445 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 19:02:22.446 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 19:02:22.447 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 19:02:22.448 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 19:02:22.449 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 19:02:22.450 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 19:02:22.450 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 19:02:22.451 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 19:02:22.452 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 19:02:22.452 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 19:02:22.453 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 19:02:22.454 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 19:02:22.454 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 19:02:22.455 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 19:02:22.456 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 19:02:22.457 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 19:02:22.458 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 19:02:22.458 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 19:02:22.459 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 19:02:22.459 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 19:02:22.460 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 19:02:22.461 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 19:02:22.461 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 19:02:22.462 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 19:02:22.463 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 19:02:22.464 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 19:02:22.464 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 19:02:22.465 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 19:02:22.466 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 19:02:22.466 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 19:02:22.467 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 19:02:22.469 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 19:02:22.469 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 19:02:22.470 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 19:02:22.471 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 19:02:22.472 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 19:02:22.473 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 19:02:22.473 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 19:02:22.474 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 19:02:22.474 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 19:02:22.476 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 19:02:22.477 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 19:02:22.478 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 19:02:22.479 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 19:02:22.480 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 19:02:58.066 | DEBUG    | __main__:algorithm_chat:30 - [message]最小生成树prim算法
2024-07-16 19:02:58.067 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:03:01.962 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:57 - [algorithm_chao_name]抱歉，我之前的回答有误。根据您给出的问题和上下文，正确的回答应该是：

[回答]
(单链表)
2024-07-16 19:03:10.797 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:59 - [algorithm_code from agnet]如果您想要用关键词在SQLite中查找与某个算法最相关的信息，那么根据您提供的描述，以下是每个关键词的相关性分析：

- 有向图的强连通分量：用于在有向图中寻找强连通分量的算法，如Kosaraju算法。
- __int128读写模板：这与特定编程语言的128位整数读写有关，不是一个算法。
- 子无向图的点双连通分量：用于在无向图中寻找点双连通分量的算法，如Tarjan算法。
- 二分图匈牙利算法：用于解决二分图最大匹配问题的算法，如匈牙利算法。
- 单链表：一种线性数据结构，用于存储元素序列，每个元素指向下一个元素。
- 双链表：另一种线性数据结构，每个元素不仅指向下一个元素，还指向前一个元素。

根据您的描述，如果算法与数据结构有关，并且是关于查找或操作序列中的元素，那么最相关的关键词是：

[单链表]

这是因为单链表是一种简单的数据结构，可以用于实现许多不同的算法，例如在链表中查找元素、插入元素或删除元素等操作。如果您的SQLite数据库中存储了与链表相关的算法或代码模板，您可以使用“单链表”作为关键词进行搜索。
2024-07-16 19:05:41.696 | DEBUG    | __main__:algorithm_chat:30 - [message]整数二分
2024-07-16 19:05:41.697 | DEBUG    | __main__:algorithm_chat:31 - [history][['最小生成树prim算法', '如果您想要用关键词在SQLite中查找与某个算法最相关的信息，那么根据您提供的描述，以下是每个关键词的相关性分析：\n\n- 有向图的强连通分量：用于在有向图中寻找强连通分量的算法，如Kosaraju算法。\n- __int128读写模板：这与特定编程语言的128位整数读写有关，不是一个算法。\n- 子无向图的点双连通分量：用于在无向图中寻找点双连通分量的算法，如Tarjan算法。\n- 二分图匈牙利算法：用于解决二分图最大匹配问题的算法，如匈牙利算法。\n- 单链表：一种线性数据结构，用于存储元素序列，每个元素指向下一个元素。\n- 双链表：另一种线性数据结构，每个元素不仅指向下一个元素，还指向前一个元素。\n\n根据您的描述，如果算法与数据结构有关，并且是关于查找或操作序列中的元素，那么最相关的关键词是：\n\n[单链表]\n\n这是因为单链表是一种简单的数据结构，可以用于实现许多不同的算法，例如在链表中查找元素、插入元素或删除元素等操作。如果您的SQLite数据库中存储了与链表相关的算法或代码模板，您可以使用“单链表”作为关键词进行搜索。']]
2024-07-16 19:05:43.232 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:57 - [algorithm_chao_name]抱歉，我之前的回答没有遵循您的指示。

(整数二分)
2024-07-16 19:05:47.798 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:59 - [algorithm_code from agnet]根据您提供的关键词，如果需要在SQLite中进行搜索以找到与某个算法最相关的信息，我会选择：

**有向图的强连通分量**

这个关键词与图论中的特定算法紧密相关，且是一个独特的概念，容易在数据库中作为搜索条件。如果您想查找与有向图中强连通分量相关的算法或实现，使用这个关键词会是一个很好的起点。在SQLite中，您可以执行类似以下的查询：

```sql
SELECT * FROM algorithms WHERE description LIKE '%有向图的强连通分量%';
```

这将返回所有描述中包含“有向图的强连通分量”这一关键词的记录。
2024-07-16 19:09:35.830 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 19:09:35.831 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 19:09:35.832 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 19:09:35.833 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 19:09:35.834 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 19:09:35.835 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 19:09:35.836 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 19:09:35.837 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 19:09:35.838 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 19:09:35.839 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 19:09:35.840 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 19:09:35.841 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 19:09:35.842 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 19:09:35.842 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 19:09:35.843 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 19:09:35.844 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 19:09:35.846 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 19:09:35.847 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 19:09:35.847 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 19:09:35.848 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 19:09:35.849 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 19:09:35.849 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 19:09:35.851 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 19:09:35.852 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 19:09:35.853 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 19:09:35.854 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 19:09:35.854 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 19:09:35.855 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 19:09:35.856 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 19:09:35.857 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 19:09:35.857 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 19:09:35.858 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 19:09:35.859 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 19:09:35.860 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 19:09:35.860 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 19:09:35.861 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 19:09:35.861 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 19:09:35.862 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 19:09:35.863 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 19:09:35.863 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 19:09:35.864 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 19:09:35.865 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 19:09:35.866 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 19:09:35.867 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 19:09:35.867 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 19:09:35.868 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 19:09:35.868 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 19:09:35.869 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 19:09:35.869 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 19:09:35.870 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 19:09:35.871 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 19:09:35.872 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 19:09:35.873 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 19:09:35.874 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 19:09:35.874 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 19:09:35.875 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 19:09:35.876 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 19:09:35.877 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 19:09:35.878 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 19:09:35.879 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 19:09:35.880 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 19:09:35.880 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 19:09:35.881 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 19:09:35.882 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 19:09:35.883 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 19:09:35.884 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 19:09:35.885 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 19:10:03.865 | DEBUG    | __main__:algorithm_chat:30 - [message]字典树是一种用于存储动态集合或前缀字符串的数据结构
2024-07-16 19:10:03.866 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:10:22.012 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:58 - [algorithm_chao_name]列表。其主要操作包括插入和查询。下面是一个简单的示例，展示了如何在Trie树中插入和查询字符串。

1. 插入操作：

假设我们要构建一个Trie树来存储以下字符串集合：["hello", "world", "heap", "hash", "trie"]。

- 插入 "hello"：
  - 从根节点开始，检查每个字符：
    - 'h'：创建一个子节点，标记为 'h'。
    - 'e'：在 'h' 节点下创建一个子节点，标记为 'e'。
    - 'l'：在 'e' 节点下创建一个子节点，标记为 'l'。
    - 'l'：在 'l' 节点下创建一个子节点，标记为 'l'。
    - 'o'：在 'l' 节点下创建一个子节点，标记为 'o'，并将该节点设置为结束节点（表示一个完整的字符串结束）。

- 插入其他字符串的过程类似。

2. 查询操作：

现在，假设我们要查询字符串 "hello" 是否在Trie树中。

- 查询 "hello"：
  - 从根节点开始，按顺序检查每个字符：
    - 'h'：找到 'h' 节点。
    - 'e'：找到 'e' 节点。
    - 'l'：找到 'l' 节点。
    - 'l'：找到 'l' 节点。
    - 'o'：找到 'o' 节点，并且该节点是结束节点，因此 "hello" 存在于Trie树中。

查询操作的时间复杂度是 O(L)，其中 L 是查询字符串的长度。因为每个字符只需进行常数时间的查找。

以上示例展示了Trie树的基础操作，实际应用中可能还会涉及到更多高级操作，如删除、修改等。Trie树在处理字符串前缀匹配问题时非常高效，广泛应用于搜索引擎、拼写检查、自动补全等功能。
2024-07-16 19:10:28.857 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:60 - [algorithm_code from agnet]对不起，我可能误解了您的问题。如果您需要一个关键词来与SQLite数据库中的信息相关联，并且这个关键词与您给出的算法描述最相关，那么我需要知道这个算法描述是什么。

但是，基于您给出的关键词列表，如果我要选择一个与SQLite数据库最相关的关键词，我会选择：

**二分图匈牙利算法**

这是因为匈牙利算法通常用于解决图匹配问题，例如二分图的最大匹配问题。虽然这个算法与数据库的常规使用不直接相关，但是它在某些优化问题和网络流问题中可能有用，这些问题在数据库中处理复杂关系时可能出现。

如果您的SQLite数据库中存储了与图论或者匹配问题相关的数据，那么使用“二分图匈牙利算法”作为关键词可能会帮助您找到相关的算法实现或者应用示例。不过，这完全取决于您的数据库内容和上下文。如果您提供更多关于算法描述的信息，我可以给出更准确的关键词。
2024-07-16 19:16:34.075 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 19:16:34.076 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 19:16:34.078 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 19:16:34.079 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 19:16:34.080 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 19:16:34.080 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 19:16:34.081 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 19:16:34.082 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 19:16:34.083 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 19:16:34.084 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 19:16:34.085 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 19:16:34.085 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 19:16:34.086 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 19:16:34.087 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 19:16:34.088 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 19:16:34.089 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 19:16:34.090 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 19:16:34.091 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 19:16:34.091 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 19:16:34.092 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 19:16:34.093 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 19:16:34.093 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 19:16:34.095 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 19:16:34.096 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 19:16:34.097 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 19:16:34.097 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 19:16:34.098 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 19:16:34.099 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 19:16:34.100 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 19:16:34.100 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 19:16:34.101 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 19:16:34.102 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 19:16:34.103 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 19:16:34.104 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 19:16:34.104 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 19:16:34.105 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 19:16:34.106 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 19:16:34.106 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 19:16:34.107 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 19:16:34.107 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 19:16:34.108 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 19:16:34.109 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 19:16:34.110 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 19:16:34.111 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 19:16:34.112 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 19:16:34.112 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 19:16:34.113 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 19:16:34.113 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 19:16:34.114 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 19:16:34.115 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 19:16:34.116 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 19:16:34.117 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 19:16:34.118 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 19:16:34.119 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 19:16:34.120 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 19:16:34.121 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 19:16:34.122 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 19:16:34.123 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 19:16:34.124 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 19:16:34.125 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 19:16:34.125 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 19:16:34.126 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 19:16:34.127 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 19:16:34.128 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 19:16:34.129 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 19:16:34.130 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 19:16:34.131 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 19:16:54.794 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 19:16:54.794 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:17:01.513 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:58 - [algorithm_chao_name]抱歉，我之前的回答可能有些混淆。根据您给出的例子中的问题格式，正确的回答应该是：

(链表) 

因为您描述的是链表的初始化、插入和删除操作，这些操作是链表这种数据结构的特点。而树状数组是另一种不同的数据结构，与链表的问题不直接相关。
2024-07-16 19:17:06.383 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:60 - [algorithm_code from agnet]抱歉，我之前的回答可能让您困惑了。现在，根据您提供的关键词，如果我要选择一个与有向图的强连通分量最相关的关键词，以便用于在SQLite中查找相关信息，我会选择：

有向图的强连通分量

这个关键词非常具体，直接指向了有向图中的一种特殊结构，应该能够帮助您在数据库中找到相关算法或数据结构的资料。如果您的数据库中包含了关于图论和算法的数据，这个关键词会是一个很好的查询起点。
2024-07-16 19:18:11.004 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 19:18:11.006 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 19:18:11.007 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 19:18:11.008 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 19:18:11.009 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 19:18:11.010 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 19:18:11.011 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 19:18:11.012 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 19:18:11.013 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 19:18:11.013 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 19:18:11.014 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 19:18:11.015 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 19:18:11.016 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 19:18:11.017 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 19:18:11.018 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 19:18:11.018 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 19:18:11.019 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 19:18:11.020 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 19:18:11.021 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 19:18:11.022 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 19:18:11.023 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 19:18:11.024 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 19:18:11.025 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 19:18:11.026 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 19:18:11.027 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 19:18:11.028 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 19:18:11.028 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 19:18:11.029 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 19:18:11.030 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 19:18:11.031 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 19:18:11.032 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 19:18:11.033 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 19:18:11.033 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 19:18:11.034 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 19:18:11.034 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 19:18:11.035 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 19:18:11.036 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 19:18:11.037 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 19:18:11.038 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 19:18:11.038 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 19:18:11.039 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 19:18:11.040 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 19:18:11.040 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 19:18:11.041 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 19:18:11.042 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 19:18:11.042 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 19:18:11.043 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 19:18:11.044 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 19:18:11.044 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 19:18:11.045 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 19:18:11.046 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 19:18:11.047 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 19:18:11.047 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 19:18:11.048 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 19:18:11.049 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 19:18:11.050 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 19:18:11.051 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 19:18:11.052 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 19:18:11.053 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 19:18:11.053 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 19:18:11.054 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 19:18:11.055 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 19:18:11.055 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 19:18:11.056 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 19:18:11.058 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 19:18:11.059 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 19:18:11.060 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 19:18:46.700 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 19:18:46.701 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:18:49.750 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:58 - [algorithm_chao_name]```plaintext
(树状数组)
```
2024-07-16 19:18:54.474 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:60 - [algorithm_code from agnet]抱歉，我之前的回复似乎有误。根据您提供的算法描述关键词，如果我要选择一个与SQLite数据库查找最相关的关键词，那么我会选择：

```plaintext
有向图的强连通分量
```

在数据库查询中，有时需要处理图论问题，特别是当数据之间存在某种依赖关系时。有向图的强连通分量是一个有用的概念，它可以用来找到图中那些在两个方向上都相互可达的节点集合。虽然SQLite不直接支持复杂的图算法，但这个概念可能与你如何在数据库中表示和查询复杂关系有关。如果您的数据模型中有类似的需求，使用这个关键词可能会帮助您找到相关的资料或实现方法。
2024-07-16 19:22:49.453 | DEBUG    | chatbot.function_agent:__init__:31 - [name_list_prompt]
        你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
        你将获得一段关于某个算法的大致描述。
        请你在以下关键词中选取最相关的一个
        有向图的强连通分量__int128读写模板子无向图的点双连通分量二分图匈牙利算法单链表双链表
2024-07-16 19:22:50.488 | DEBUG    | chatbot.describe:__init__:43 - [doc]-----1-----
[问题] 
过程:
该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：

read 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。
print 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。
应用场景:
__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。

时间复杂度:
read 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。
print 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。
这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。

[回答]
(__int128读写)
2024-07-16 19:22:50.489 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：
选择一个枢轴元素（这里选择的是区间中间的元素）。
通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。
递归地对左右子区间进行快速排序。

应用场景:
快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。

时间复杂度:
快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。

[回答]
(快速排序)
2024-07-16 19:22:50.490 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：
将数组分成两个子数组，分别对这两个子数组进行递归排序。
合并两个已排序的子数组。
重复上述过程，直到整个数组有序。

应用场景:
归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。

时间复杂度:
归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。

[回答]
(归并排序)
2024-07-16 19:22:50.491 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：
bsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。
bsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。

应用场景:
该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。

时间复杂度:
二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。

[回答]
(整数二分)
2024-07-16 19:22:50.492 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数二分模板用于在指定的浮点区间内寻找满足特定条件的数值。与整数二分查找类似，该模板依赖于一个检查函数 check(double x) 来判断某个浮点数是否满足条件。通过不断调整区间 [l, r]，直到区间长度小于给定的精度 eps。该算法的主要步骤如下：
初始化左右边界 l 和 r。
通过计算中点 mid，并调用 check(mid) 判断条件。
根据判断结果调整边界，重复上述步骤，直到精度满足要求。

应用场景:
浮点数二分查找适用于需要高精度数值计算的场景，如物理模拟、优化问题、数值分析等。在实际应用中，常用于确定最优解、寻找特定值等。

时间复杂度:
浮点数二分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求，r 和 l 是查找区间的左右边界。这使得在处理高精度需求的情况下，算法仍能保持较高的效率。

[回答]
(浮点数二分)
2024-07-16 19:22:50.493 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
整数三分模板用于在指定区间内寻找极值，适用于处理凸函数或凹函数等情况。通过不断将区间 [l, r] 分成三部分，使用两个中点 m1 和 m2 来评估函数值。具体步骤如下：
计算两个中点 m1 和 m2。
通过调用 check(x) 函数获取中点对应的函数值。
根据比较结果调整边界，向可能的极值方向收缩搜索范围。
重复上述步骤，直到区间收缩到足够小。

应用场景:
三分查找广泛应用于需要寻找极值的优化问题，如最小化或最大化某些函数值，尤其在函数为单调且连续的情况下。常见于图形优化、机器学习中的超参数调优等。

时间复杂度:
三分查找的时间复杂度为 O(log(r - l))，其中 l 和 r 是搜索区间的边界。这使得在处理大范围搜索时，算法依然高效。

[回答]
(整数三分)
2024-07-16 19:22:50.494 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
浮点数三分模板用于在指定的浮点区间内寻找函数的极值，特别适用于处理凸函数或凹函数。通过将区间 [l, r] 分成三部分，利用两个中点 m1 和 m2 来评估函数值，以决定向哪一侧收缩区间。具体步骤如下：
计算两个中点 m1 和 m2。
使用 check(x) 函数获取中点对应的函数值。
根据函数值的比较结果调整边界，收缩到可能的极值方向。
重复上述步骤，直到区间长度小于给定的精度 eps。

应用场景:
浮点数三分查找常用于数值优化问题，如函数的最小化或最大化，尤其是在需要高精度的情况下。典型应用包括科学计算、经济模型优化等。

时间复杂度:
浮点数三分查找的时间复杂度为 O(log((r - l) / eps))，其中 eps 是精度要求。这使得在处理高精度问题时，算法依然保持较高效率。

[回答]
(浮点数三分)
2024-07-16 19:22:50.495 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度加法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
确保第一个加数 A 的位数大于等于第二个加数 B，如果不满足则交换它们。
初始化结果向量 C 和进位变量 t。
遍历数组 A 的每一位，同时加上 B 的对应位（如果存在）。
将当前位的和取模 10 存入结果向量 C，并计算进位。
如果最后还有进位，则将进位添加到结果向量 C。

应用场景:
高精度加法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度加法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相加并处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度加法)
2024-07-16 19:22:50.496 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度减法用于处理比标准整型范围更大的整数，通过将大整数表示为数组或向量来实现。每个数组元素代表整数的一个数字，通常按逆序存储，以便于从最低位开始计算。具体步骤如下：
初始化结果向量 C，并使用变量 t 存储当前位的计算结果。
遍历数组 A 的每一位，同时减去 B 的对应位（如果存在）。
计算当前位的值，如果结果为负，则进行进位调整，并在结果向量中存储相应的数字。
在计算完所有位后，去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度减法广泛应用于需要处理大整数的场景，如大数计算、密码学、数值分析等。常见于编程竞赛、科学计算和金融应用。

时间复杂度:
高精度减法的时间复杂度为 O(n)，其中 n 是较大整数的位数。这是因为需要逐位进行相减和处理进位，因此在大数计算时，该方法依然高效。

[回答]
(高精度减法)
2024-07-16 19:22:50.497 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度乘低精度用于将一个大整数（以数组或向量表示）与一个小整数（标量）相乘。该算法通过逐位计算和处理进位来实现乘法。具体步骤如下：
初始化结果向量 C 和进位变量 t。
遍历大整数 A 的每一位，并与小整数 b 相乘。
将当前乘积加到进位 t 中，并将当前位的结果（t % 10）存入结果向量 C。
计算新的进位（t /= 10），并继续处理下一位。
如果还有进位，则在循环结束后继续处理。

应用场景:
高精度乘低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到乘法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度乘低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数乘法时保持高效。

[回答]
(高精度乘低精度)
2024-07-16 19:22:50.497 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
高精度除以低精度用于将一个大整数（以数组或向量表示）除以一个小整数（标量），并计算商和余数。该算法通过逐位处理和累积余数来实现除法。具体步骤如下：
初始化结果向量 C 和余数变量 r。
从大整数 A 的最后一位开始向前遍历，将每一位数字与当前余数组合成一个新的数值。
计算新数值除以小整数 b，并将商存入结果向量 C。
更新余数 r 为当前数值对 b 的模。
遍历结束后，反转结果向量 C，以确保商的位数顺序正确。
去除结果向量 C 末尾的零，以确保结果的规范性。

应用场景:
高精度除以低精度广泛应用于需要处理大整数的场景，尤其是在计算中涉及到除法的地方，如大数运算、科学计算、以及在密码学中的应用。

时间复杂度:
高精度除以低精度的时间复杂度为 O(n)，其中 n 是大整数的位数。这使得该方法在处理大数除法时保持高效。

[回答]
(高精度除以低精度)
2024-07-16 19:22:50.498 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
子矩阵的和利用前缀和数组来高效计算任意子矩阵的元素和。前缀和数组 S[i, j] 表示从矩阵左上角到 (i, j) 的所有元素之和。计算步骤如下：
初始化前缀和数组 S，并根据以下公式填充：
S[i,j]=S[i−1,j]+S[i,j−1]−S[i−1,j−1]+matrix[i][j]
其中 matrix[i][j] 是原始矩阵的元素。
通过前缀和数组，可以快速计算任意子矩阵的和。对于左上角为 (x1, y1)，右下角为 (x2, y2) 的子矩阵，其和为：
Sum=S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]

应用场景:
该算法常用于图像处理、区域查询和动态规划问题中，特别是在需要频繁查询子矩阵和的情况下。它显著提高了计算效率。

时间复杂度:
前缀和的构建时间复杂度为 O(n * m)，其中 n 和 m 分别是矩阵的行数和列数。查询任意子矩阵的和则可在 O(1) 的时间内完成。这使得在处理多次查询时，整体效率得到显著提升。

[回答]
(子矩阵的和)
2024-07-16 19:22:50.499 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
差分矩阵用于高效地进行二维范围更新操作。通过差分数组，可以在指定的矩形区域内快速加上某个值，而无需逐个更新每个元素。具体步骤如下：
使用差分矩阵 b，进行插入操作的方式是：
b[l] += x：表示从位置 l 开始加上 x。
b[r + 1] -= x：表示在位置 r + 1 处取消加上 x。
对于给定的子矩阵，左上角为 (x1, y1)，右下角为 (x2, y2)，若要在该区域的所有元素上加上 c，操作如下：
S[x1, y1] += c：在子矩阵的左上角增加 c。
S[x2 + 1, y1] -= c：在右下角下一行取消加上 c。
S[x1, y2 + 1] -= c：在右下角下一列取消加上 c。
S[x2 + 1, y2 + 1] += c：在右下角的下一行下一列补偿取消。

应用场景:
差分矩阵广泛应用于需要频繁进行区域更新的场景，如图像处理、游戏开发中的区域状态更新，以及一些高频的动态查询问题。

时间复杂度:
差分矩阵的插入操作时间复杂度为 O(1)，无论操作多大区域。最终求得实际值需通过前缀和计算，时间复杂度为 O(n * m)，其中 n 和 m 是矩阵的行数和列数。这种高效的更新方式使得整体性能在频繁更新和查询的情况下显著提高。

[回答]
(差分矩阵)
2024-07-16 19:22:50.500 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
双指针算法通过使用两个指针（通常命名为 i 和 j）来有效地遍历数组或序列，并在满足特定条件时移动指针。该算法通常用于解决涉及区间、子数组或特定条件的计算问题。具体步骤如下：
初始化两个指针 i 和 j，其中 i 负责遍历当前元素，而 j 负责寻找满足条件的元素。
在循环中，i 从 0 遍历到 n（数组的长度）。
对于每一个 i，内层 while 循环检查条件 check(i, j)，并在条件满足的情况下移动 j 指针。
根据问题需求，可以在此基础上进行其他计算或记录所需的信息。

应用场景:
双指针算法常用于解决各种问题，例如：
查找数组中满足特定条件的子数组。
计算滑动窗口内的和或其他统计信息。
解决有序数组中寻找特定配对的问题（如三数之和、两数之和等）。

时间复杂度:
双指针算法通常具有线性时间复杂度 O(n)，因为每个指针仅在循环中移动一次。这种高效性使得双指针成为处理序列或数组相关问题时的一种重要技术。

[回答]
(双指针算法)
2024-07-16 19:22:50.501 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
数据离散化/保序离散化是一种常用的技术，用于将连续的或稠密的数据映射到一个离散的、较小的索引空间。这种技术特别适用于处理范围查询和频繁更新的问题。具体步骤如下：
收集数据：将所有需要离散化的数值存入一个数组 alls。
排序和去重：对 alls 进行排序，并利用 unique 去除重复值。
离散化查找：通过二分查找的方式，在 alls 中找到第一个大于等于给定值 x 的位置，返回其索引（加1以便于保序）。

应用场景:
数据离散化广泛应用于以下场景：
处理区间查询或更新时需要降低数据的维度。
在树状数组、线段树等数据结构中进行高效的索引。
解决涉及离散值的动态规划问题。

时间复杂度:
数据离散化的时间复杂度主要由排序和二分查找构成：

排序的时间复杂度为 O(n log n)，其中 n 是数据的数量。
离散化查找的时间复杂度为 O(log n)。因此，总体效率在数据量较大时依然保持良好。

[回答]
(数据离散化_保序离散化)
2024-07-16 19:22:50.502 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
非保序离散化是一种通过映射将数据转换为唯一索引的技术，通常用于快速查找和压缩数据。具体步骤如下：
使用哈希表：通过 unordered_map<int, int> mp 存储原始值到离散索引的映射。
查找和映射：在 find(int x) 函数中，检查值 x 是否已存在于映射中：
如果不存在，创建一个新的映射并分配一个新的索引（++res），将该索引与值 x 关联。
如果存在，则直接返回对应的索引。

应用场景:
非保序离散化适用于需要快速查询和不考虑值的顺序的情况，例如：
图算法中节点的离散化处理。
大数据集中的稀疏矩阵表示。
处理范围查询和动态更新时需要优化空间使用。

时间复杂度:
非保序离散化的时间复杂度为 O(1)，因为哈希表的查找和插入操作在平均情况下都是常数时间复杂度。这使得该方法在处理频繁查找时表现出色。

[回答]
(数据离散化_非保序离散化)
2024-07-16 19:22:50.503 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
RMQ（Range Minimum Query）算法通过构建稀疏表（ST表）来实现对区间最值的高效查询。具体步骤如下：
预处理：使用 dp 数组来存储区间最值的预计算结果。dp[i][j] 表示从位置 i 开始长度为 2^j 的区间的最大值。
对于 j = 0，直接将 dp[i][0] 赋值为 a[i]。
对于 j > 0，使用之前计算的值更新 dp[i][j]，通过比较 dp[i][j-1] 和 dp[i + (1 << (j-1))][j-1]。
查询：在查询区间 [a, b] 的最大值时，计算所需的区间长度 b - a + 1 的对数，得出 res。
使用预处理结果，取 max(dp[a][res], dp[b - (1 << res) + 1][res]) 作为查询结果。

应用场景:
RMQ算法广泛应用于：
需要频繁查询区间最值的场景，如动态规划和算法竞赛。
处理与区间相关的优化问题，如求解区间的最小值或最大值。

时间复杂度:
预处理：时间复杂度为 O(n log n)，其中 n 是数组的大小。
查询：每次查询的时间复杂度为 O(1)，因此适合需要高效查询的应用场景。

[回答]
(RMQ算法)
2024-07-16 19:22:50.503 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法判定质数是一种简单而有效的算法，用于检查一个整数是否为质数。具体步骤如下：
边界条件：首先检查输入 x 是否小于 2，如果是，则返回 false，因为质数定义为大于 1 的自然数。
试除法：通过循环从 2 开始，检查每个整数 i 是否能整除 x：
只需遍历到 sqrt(x)（即 x / i），因为若 x 能被一个大于其平方根的数整除，则必然有一个对应的小于其平方根的因子。
如果发现 x 能被某个 i 整除，返回 false，否则最终返回 true。

应用场景:
试除法判定质数适用于：
基本的质数检查，尤其在输入规模较小时表现良好。
教学或初学者的质数测试。

时间复杂度:
时间复杂度为 O(√x)，其中 x 是待判断的数。由于需要试除到 √x，随着 x 的增大，效率相对较低，但在较小范围内仍然实用。

[回答]
(试除法判定质数)
2024-07-16 19:22:50.504 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
试除法分解质因数是一种直接的算法，用于将一个整数分解为其质因数的乘积。具体步骤如下：
循环检查：从 2 开始，检查每个整数 i 是否为 x 的因子，遍历到 √x（即 x / i）。
因数计数：对于每个 i，如果 x 能被 i 整除，进入内层循环，统计 i 能整除 x 的次数 s，同时逐步将 x 除以 i。
每找到一个质因数 i，输出该因数及其对应的次数 s。
余下质数：循环结束后，如果 x 大于 1，则 x 本身是一个质数，输出 x 和 1。

应用场景:
试除法分解质因数广泛用于：
数论问题，如求最大公约数、最小公倍数等。
密码学中的素因数分解。

时间复杂度:
时间复杂度为 O(√x)，因为在最坏情况下，算法需试除到 √x。虽然效率较低，但对于小整数的分解是有效的。

[回答]
(试除法分解质因数)
2024-07-16 19:22:50.505 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
朴素筛法是一种有效的算法，用于生成不超过 n 的所有素数（质数）。具体步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，并初始化一个数组 primes 来存储素数。
筛选过程：
从 2 开始，检查每个整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，将所有 i 的倍数标记为非素数（即 st[j] = true），从 i+i 开始，以 i 为步长。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的即为所有不超过 n 的素数。

应用场景:
朴素筛法适用于：
需要查找一定范围内素数的应用，如素数测试和数论问题。
在某些算法竞赛中，作为生成素数的基础工具。

时间复杂度:
时间复杂度为 O(n log log n)，这是由于每个素数在筛选过程中只会影响其倍数，整体效率较高，适合生成大量素数。

[回答]
(朴素素数筛法)
2024-07-16 19:22:50.506 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线性筛法是一种高效的算法，用于生成不超过 n 的所有素数（质数）。其主要步骤如下：
初始化：创建一个布尔数组 st，用于标记非素数，以及一个数组 primes 用于存储素数。
筛选过程：
从 2 开始遍历所有整数 i。
如果 i 尚未被标记为非素数，则将其视为素数，存入 primes 数组，并更新计数 cnt。
使用内层循环，对于当前素数列表中的每个素数 primes[j]，将 primes[j] * i 标记为非素数（即 st[primes[j] * i] = true），直到 primes[j] 超过 n / i。
如果 i 能被 primes[j] 整除，停止当前循环，因为此时后续的倍数只会影响更大的素数。
结束条件：循环持续至 i 超过 n，最终 primes 数组中存储的不超过 n 的所有素数。

应用场景:
线性筛法适用于：
需要高效查找一定范围内素数的应用，如数论和算法竞赛中的相关问题。
需要频繁调用素数查询的场合，相较于朴素筛法具有更优的性能。

时间复杂度:
时间复杂度为 O(n)，由于每个素数只影响其倍数的标记，并且不重复处理，这使得线性筛法在性能上优于朴素筛法，尤其在处理大规模数据时更为高效。

[回答]
(线性素数筛法)
2024-07-16 19:22:50.507 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
区间素数筛（Segment Sieve）是一种用于找出某一给定范围 [a, b] 内所有素数的高效算法。其主要步骤如下：
初始化：创建两个布尔数组 is_prime_small 和 is_prime，分别用于标记小范围内的素数（[2, sqrt(b)]）和指定区间 [a, b] 内的素数。
筛选小素数：
先对 [2, sqrt(b)] 范围内的数进行筛选，找出所有素数，标记为 is_prime_small[i] = true。
对于每个找到的素数 i，将其所有倍数标记为非素数。
标记区间素数：
对于每个小素数 i，在区间 [a, b] 内标记其倍数为非素数，确保从 max(2, (a+i-1)/i)*i 开始，以避免标记不在区间内的数。
结束条件：最终，所有在 is_prime 中标记为 true 的位置对应的数即为 [a, b] 内的素数。

应用场景:
区间素数筛适用于：
大范围内的素数查询，尤其是当 a 和 b 的值非常大时，能够有效减少内存使用和计算时间。
需要在特定区间内频繁查找素数的应用场合。

时间复杂度:
时间复杂度为 O((b-a) log log b)，其中 b 是区间的上界。这种复杂度使得该算法在处理大范围素数时仍然保持较高的效率，相较于传统的素数筛法更为适合大规模数据。

[回答]
(区间素数筛)
2024-07-16 19:22:50.508 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
Min_25算法用于计算从1到n的所有质数的和。其主要步骤包括：
初始化：
创建数组 prime 用于存储质数，id1 和 id2 用于快速查找，flag 用于标记非质数，g 存储计算结果，sum 存储前n个质数的和。
设置 T 为 sqrt(n)，以优化质数的生成和查询。
质数筛选：
使用筛法生成质数列表，并计算前n个质数的累积和 sum。
区间计算：
对于每个可能的 l 值（从1到n），计算相应的质数和，使用 g 数组存储结果。
优化：
利用小质数筛选大质数的过程来减小计算量，以 g[j] 减去相应的质数倍数。
结果返回：
在函数 solve 中，根据输入 x 调用初始化函数，并返回1到n的质数和。

应用场景:
此算法适用于需要计算大量质数和的场合，特别是在大范围内快速求解质数和的问题。

时间复杂度:
时间复杂度为 O(n / log n)，利用质数的分布特性和高效的筛选过程，使得在处理大数范围时依然保持高效。

[回答]
(Min_25算法)
2024-07-16 19:22:50.509 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化一个空向量 res 用于存储因子。
遍历从 1 到 x / i 的所有整数 i。
对每个 i，检查 x % i == 0：
如果成立，i 是一个因子，将 i 和 x / i（如果不同）添加到 res。
对结果向量 res 进行排序，以确保因子按升序排列。
返回 res 向量。

应用场景:
数论中的因子分解。
用于求解最小公倍数和最大公约数的计算。
在密码学中，因子分解在 RSA 加密中起到重要作用。
在算法竞赛中，寻找数的因子常用作优化某些问题。

时间复杂度:
算法的时间复杂度为 O(sqrt(x))，因为它只需遍历到 sqrt(x)，并在此基础上提取因子。

[回答]
(试除法求约数)
2024-07-16 19:22:50.510 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
输入两个正整数 a 和 b。
使用递归计算：
如果 b 不为 0，递归调用 gcd(b, a % b)。
如果 b 为 0，则返回 a，此时 a 为最大公约数。

应用场景:
计算两个数的最大公约数（GCD），广泛应用于数论、算法设计和简化分数。
用于求解最小公倍数（LCM），因为 LCM(a, b) = (a * b) / GCD(a, b)。
在密码学中，尤其是在 RSA 算法中，计算公钥和私钥的关系时使用。

时间复杂度:
算法的时间复杂度为 O(log(min(a, b)))，因为每次递归调用都会将问题规模减半。

[回答]
(欧几里得算法)
2024-07-16 19:22:50.511 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
φ(N) 表示 1 到 N 中与 N 互质的数的个数。计算欧拉函数的常用方法是利用其性质，通过质因数分解和公式 
φ(N)=N(1−1/pp_1)(1-1/p_2)...(1-1/p_k)，其中N 的所有质因子。

初始化结果为 x。
遍历从 2 到 x的每个数 i，检查其是否为 x 的因数。
如果 i 是因数，更新结果为 res=res×(1− 1/i)，并不断除去 x 中的因数 i。
如果最终 x 大于 1，则 x 是一个质数，更新结果为 res=res×(1− 1/x)。

应用场景:
在数论中，用于计算与某个数互质的正整数个数，常用于 RSA 算法和其他公钥加密算法。
可用于解决与模运算相关的问题，例如在计算大数的幂时。
在组合数学中，研究整数的性质时也会使用。

时间复杂度:
算法的时间复杂度为 O(√N)，因为只需遍历到 √x 来找到所有质因子。

[回答]
(欧拉函数)
2024-07-16 19:22:50.512 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化欧拉函数数组 euler 和素数标记数组 st。
通过遍历，从 2 到 n 逐个处理：
如果 i 不是素数（即 st[i] 为 false），则记录 i 为素数，并计算其欧拉函数 euler[i] 为 i - 1。
遍历已有的素数数组，更新每个合数的欧拉函数值。
根据 i 和当前素数 prime[j] 的关系，更新合数的欧拉函数值，并在适当条件下停止循环。

应用场景:

计算欧拉函数：欧拉函数在数论中有广泛应用，如计算模数的逆元、加密算法（RSA算法）、计算互质数对等。
数论分析：在数论问题和计算涉及多个大数和素数时，筛法提供了高效的预处理手段。

时间复杂度:
筛法的时间复杂度为 O(nloglogn)，这使得它在处理大范围数时非常高效。

[回答]
(筛法求欧拉函数)
2024-07-16 19:22:50.512 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过逆元预处理来计算卡特兰数的模。在给定的 N 和模数下，首先计算逆元，然后使用递推公式 
C(n)=C(n−1)⋅ (4n−2) /(n+1)
计算卡特兰数，并对结果进行模运算。

应用场景: 
此算法适用于求解在模数下的卡特兰数，常用于组合数学、图论和动态规划问题。特别是在处理大数和需要模运算的情况下非常有效，如计算有效括号组合数和树的结构数等。

时间复杂度: 预处理逆元的时间复杂度为 O(N)，计算卡特兰数的时间复杂度为 O(N)，整体效率较高。

[回答]
(卡特兰数求模)
2024-07-16 19:22:50.513 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用模运算来计算第 n 位卡特兰数。通过预处理逆元以提高计算效率。算法采用递推公式 
C(n)=C(n−1)⋅ (4n−2) / (n+1)，并在每一步中应用模运算。

应用场景: 
该算法适合在需要计算卡特兰数的应用中，如求解组合数学问题、二叉树的数量、有效括号组合等。模运算确保在处理大数时不溢出，适合编程竞赛和大规模计算任务。

时间复杂度: 
预处理逆元的时间复杂度为 O(n)，计算卡特兰数的时间复杂度为 O(n)。总的复杂度为 O(n)，适合大规模数据处理。
时间复杂度为 O(n)，其中 n 是输入的卡特兰数的位数。这种效率适合大范围计算卡特兰数。

[回答]
(快速求第n位卡特兰数)
2024-07-16 19:22:50.514 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该程序使用 Java 的 BigInteger 类型处理卡特兰数，利用递推公式 
C(n)= (4n−2)C(n−1)/n+1
​计算并存储前 104 个卡特兰数。输入 n 后，输出对应的卡特兰数。

应用场景: 
卡特兰数广泛应用于组合数学中，例如计算二叉树的结构、有效括号的组合数、路径计数等。此算法适合处理较大的数值情况，尤其是在求解大规模组合问题时。

时间复杂度:
预处理的时间复杂度为 O(n)，后续查询的时间复杂度为 O(1)。

[回答]
(Java大数打表卡特兰数)
2024-07-16 19:22:50.515 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
快速幂算法用于高效计算 m^kmodp，通过二分法减少乘法次数。每次将指数 k 右移一位，并将底数平方，以便在 k 为奇数时乘以当前底数。

应用场景: 
该算法在大数运算、密码学（如 RSA 算法）、组合数学中的计算中非常有用，尤其是在计算大指数的模幂时，能显著减少时间复杂度。

时间复杂度: 
O(logk)，即每次将 k 除以 2，导致计算次数与指数的位数成正比。

[回答]
(快速幂)
2024-07-16 19:22:50.515 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。

应用场景: 
适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。

时间复杂度: 
时间复杂度为 O(logb)，其中 b 是乘数，效率较高。

[回答]
(位运算处理大数相乘)
2024-07-16 19:22:50.516 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
扩展欧几里得算法用于求解方程 
ax+by=gcd(a,b)。算法不仅返回最大公约数，还返回一组满足该方程的整数解 
x 和 y。

应用场景: 
在数论中，常用于求解线性同余方程、计算模逆元等问题，尤其在加密算法（如RSA）中，扩展欧几里得算法用于计算私钥和公钥之间的关系。

时间复杂度: 
O(log(min(a,b)))，因为算法的每一步都涉及到递归调用，逐步减少问题的规模。

[回答]
(扩展欧几里得算法)
2024-07-16 19:22:50.516 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
高斯消元算法用于求解线性方程组。通过将增广矩阵化为上三角形，进而回代求解变量。算法通过行变换消去变量，确保主元选择最大绝对值，避免数值不稳定。

应用场景: 广泛用于线性代数、数值分析和工程计算中，特别是在求解线性方程组、计算矩阵的秩以及求逆矩阵等问题中。

时间复杂度: 
O(N^3)，其中 N 是方程组的未知数数量。主要时间开销来自于处理增广矩阵的行操作。

[回答]
(高斯消元)
2024-07-16 19:22:50.517 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用动态规划的思想，通过构建一个二维数组 
C 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。

应用场景: 
在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。

时间复杂度: 
O(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。

[回答]
(递归法求组合数)
2024-07-16 19:22:50.518 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法首先通过快速幂算法计算 
a 的 k 次幂模 p 的结果，以获得模逆元。接着，预处理阶乘和其逆元，利用公式 
C(n,k)= fact[n]/(fact[k]⋅fact[n−k])modp，其中 
fact 为阶乘数组，infact 为逆元数组。这样可以在常数时间内计算组合数。

应用场景: 
适用于大规模组合数计算的场景，如动态规划中的状态转移、离线查询和计算组合的概率问题等，特别是在比赛或需要快速计算的场合。

时间复杂度: 
O(Nlogp) 用于计算逆元和阶乘，查询组合数 C(n,k) 的复杂度为 O(1)。整体处理适合规模上万的情况。

[回答]
(预处理逆元的方式求组合数)
2024-07-16 19:22:50.518 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Lucas定理允许我们在大数下计算组合数。
首先，通过快速幂算法计算模逆元。
然后，如果 p，则直接使用组合数计算 C(a,b)。如果任一数超过 p，则将其分解为小数并递归调用，以 C(amodp,bmodp) 计算其组合数，再乘以递归结果。

应用场景: 此算法广泛应用于计算组合数，尤其是在需要处理非常大的数据规模（如上亿）的场合，常用于竞赛中涉及大规模组合计算的题目，如组合数学、概率问题和动态规划。

时间复杂度: 
每次递归处理 O(p)，而组合数的计算复杂度为 O(p)，因此总的时间复杂度大约为 
O(log_p(a))，非常适合于大规模数据。

[回答]
(Lucas定理)
2024-07-16 19:22:50.519 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
利用入度数组（inv）和队列（q），首先将所有入度为零的节点加入队列。然后，依次从队列中取出节点，记录其拓扑序，并将其相邻节点的入度减一。当某个相邻节点的入度减为零时，将其加入队列。重复这一过程，直到队列为空。最后，如果记录的节点数量等于图中节点总数，说明拓扑排序成功。

应用场景: 
拓扑排序常用于有向无环图（DAG）中，广泛应用于任务调度、课程安排、编译顺序等场景。它帮助解决依赖关系的问题，确保按照依赖顺序处理任务。

时间复杂度: 
该算法的时间复杂度为 O(V+E)，其中 
V 为图中顶点数量，E 为边的数量，效率较高，适合处理大规模图结构。

[回答]
(有向图的拓扑序)
2024-07-16 19:22:50.520 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
树的直径可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。基本思路是：通过 DFS 遍历树的所有节点，维护每个节点到其子节点的最大和次大边权。每当更新到当前节点的最大边权时，同时更新直径。最终，得到的直径就是树中两点之间的最长路径。

应用场景: 
树的直径在很多场景中具有重要意义，例如网络拓扑分析、最优路径规划、数据结构中的树形数据操作等。它可以帮助分析网络中最远的两个节点之间的距离，或者在优化资源分配时使用。

时间复杂度: 
该算法的时间复杂度为 O(N)，其中 N 为树中节点的数量。这是因为每个节点和每条边都被访问一次，效率较高，适合处理大规模树结构。

[回答]
(树的直径)
2024-07-16 19:22:50.520 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。

应用场景: 
朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。

时间复杂度: 该算法的时间复杂度为 
O(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。

[回答]
(朴素版Dijkstra算法)
2024-07-16 19:22:50.521 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
堆优化版 Dijkstra 使用优先队列（最小堆）来高效地选择当前距离最小的节点。初始化时将起点的距离设为零，并将其加入优先队列。每次从堆中提取最小距离的节点，更新其邻接节点的距离，如果找到更短的路径，则更新该节点的距离并将其重新加入堆中，直到所有节点处理完成。

应用场景:
适合计算大规模图的单源最短路径问题，如城市交通导航、网络流量分析等，尤其在节点数较多且边数密集的图中，相比朴素版 Dijkstra 更加高效。

时间复杂度: 该算法的时间复杂度为 
O(mlogn)，其中 m 为边数，n 为节点数。通过使用堆来管理节点的选择，使得每次更新操作的效率显著提高。

[回答]
(堆优化版Dijkstra算法)
2024-07-16 19:22:50.522 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SPFA（Shortest Path Faster Algorithm）是 Bellman-Ford 算法的优化版本，使用队列来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列中取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新该邻接节点的距离并将其加入队列，直到队列为空。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题。常见于网络流量分析、地图导航等场景，尤其适合稀疏图。

时间复杂度: 
SPFA 的时间复杂度为 
O(m)，其中 m 为边数。在最坏情况下，复杂度可达 O(nm)，但是在实际应用中通常比 Bellman-Ford 快。

[回答]
(朴素版SPFA)
2024-07-16 19:22:50.523 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
SFA（Shortest Path Faster Algorithm）优化了传统 SPFA，使用双端队列（deque）来管理待处理节点。初始化时，将源点的距离设为零并加入队列。每次从队列的前端取出一个节点，检查其所有邻接边，如果通过该节点能找到更短的路径，则更新邻接节点的距离，并根据更新后的距离决定将其放在队列的前端或后端，从而实现更优的时间复杂度。

应用场景: 
适用于图中存在负权边但无负权回路的单源最短路径问题，尤其在图的边数较少且边权为负时更为有效。常见应用包括交通网络分析、路由选择等。

时间复杂度: 
优化后的 SPFA 的时间复杂度通常为 O(m)，在许多实际场景中，性能比传统的 SPFA 更佳。

[回答]
(SFA优化版SPFA)
2024-07-16 19:22:50.523 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过 SPFA 变体来检测图中的负权环。初始化时，将所有节点的距离设为零并加入队列。算法遍历每个节点及其邻接边，尝试更新邻接节点的距离。如果发现可以通过某一边获得更短的路径，则更新距离并增加该节点的计数器。若某个节点的计数器达到节点总数（n），则说明存在负权环。

应用场景: 
适用于处理包含负权边的图的单源最短路径问题，特别是在需要验证负权环的情况下。常见应用包括金融网络、最优化问题及路径规划等。

时间复杂度: 
SPFA 的时间复杂度通常为 O(m)，但在最坏情况下（例如图中存在许多负权环），可能接近 O(n⋅m)。

[回答]
(SPFA判负环正环)
2024-07-16 19:22:50.524 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。

应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。

时间复杂度: Floyd 算法的时间复杂度为 
O(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。

[回答]
(Floyd 算法)
2024-07-16 19:22:50.525 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Prim 算法通过维护一个最小边集来构建最小生成树。初始化时，将所有节点的距离设置为无穷大，并选择一个起始节点。每次选择当前未加入生成树的节点中，距离已加入生成树的节点最近的节点，将其加入生成树，并更新其他未加入节点的距离。

应用场景: 
适用于求解图的最小生成树，特别是在稠密图中（边数接近节点数平方时），广泛应用于网络设计、资源分配和其他优化问题。

时间复杂度: 
Prim 算法的时间复杂度为 
O(n^2)，其中 n 是图中节点的数量。在使用优先队列的情况下，可以优化到 O(mlogn)，其中 m 是图中的边数。

[回答]
(Prim算法)
2024-07-16 19:22:50.526 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Kruskal 算法通过将所有边按权重排序，然后依次选择权重最小的边，确保不形成环路，从而构建最小生成树。使用并查集（Union-Find）结构来快速判断两个节点是否在同一连通分量中，以避免环的形成。

应用场景: 
Kruskal 算法适合处理稀疏图的最小生成树问题，特别是在边数远少于节点数平方的情况下。广泛用于网络设计、成本最小化等问题。

时间复杂度: 
Kruskal 算法的时间复杂度为 
O(mlogm+mlogn)，其中 m 是边的数量，n 是节点的数量。主要时间开销在于边的排序和并查集的操作。

[回答]
(Kruskal算法)
2024-07-16 19:22:50.526 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
最小生成森林是对图中可能存在多个连通分量的处理方式。该算法（类似于 Prim 算法）适用于处理不连通的图。它通过不断选择最小边，并且更新与未连接节点的距离来构建森林，直到所有的节点都被处理。

应用场景: 
适用于处理稀疏图和非连通图的情况，广泛应用于网络连接、集群分析等领域。通过生成森林，可以有效连接所有节点，同时避免环路。

时间复杂度: 
算法的时间复杂度为 
O(n^2)，适用于节点数量不太大的图。在实际应用中，使用优先队列优化后，复杂度可降低到 O(mlogn)。

[回答]
(最小生成森林)
2024-07-16 19:22:50.527 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法使用 BFS 来预处理树结构，计算每个节点的深度和父节点信息。
通过倍增思想，快速查找节点的最近公共祖先（LCA）。
具体实现通过维护一个倍增数组 fa，其中 fa[u][k] 表示节点 u 的 2^k祖先。

应用场景: 常用于树形结构的查询问题，如计算两个节点的最近公共祖先，广泛应用于计算机网络、数据库管理系统、社交网络等领域的层级关系分析。

时间复杂度:
预处理时间为 O(nlogn)，其中 n 为树的节点数。
查询时间为 O(logn)，适合高频率查询场景。

[回答]
(最近公共祖先倍增在线算法)
2024-07-16 19:22:50.527 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法是一种离线方法，通过 DFS 遍历树结构来处理查询。它使用并查集（Union-Find）来高效找到节点的最近公共祖先。算法分为以下步骤：
DFS 遍历树，记录每个节点的距离。
当遍历到一个节点时，通过并查集将其标记为已访问。
对于每个查询，检查目标节点的状态。如果已访问，则使用并查集找到最近公共祖先，并根据预先计算的距离计算结果。
应用场景: 
适用于大量离线查询的场景，如网络管理、社交网络分析等，尤其在查询数量大于节点数时表现优越。

时间复杂度:
预处理时间为 O(n+qα(n))，其中 n 为节点数，q 为查询数，α 为阿克曼函数的反函数（非常慢增长）。
查询时间为 O(1) 由于使用并查集优化。
该算法在处理大规模树结构查询时非常高效，且易于实现。

[回答]
(最近公共祖先Tarjan 离线算法)
2024-07-16 19:22:50.529 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。
初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。
DFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。
识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。

应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。

时间复杂度:
算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。
该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。

[回答]
(有向图的强连通分量Tarjan算法)
2024-07-16 19:22:50.530 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
Tarjan 算法用于寻找无向图的点双连通分量（Biconnected Components, BCC）。主要思想是利用 DFS 和回溯的方法来识别图中哪些节点在去掉某个节点后，仍然能够保持图的连通性。
初始化: 使用 dfn 和 low 数组，dfn 表示节点的访问顺序，low 表示可回溯的最小 dfn 值。使用栈 stk 存储当前路径上的节点。
DFS 遍历: 从某个根节点开始 DFS：
对于每个未访问的邻接节点进行递归。
更新当前节点的 low 值。
检查回溯条件，如果当前节点是根节点且有多个子节点，或当前节点不是根节点且其 dfn 值小于等于邻接节点的 low 值，则可以识别出一个 BCC。
记录双连通分量: 当满足条件时，将节点从栈中弹出并存储为一个 BCC。

应用场景: 
常用于网络可靠性分析、图的割点与桥的识别、社交网络分析等。

时间复杂度:
算法的时间复杂度为 O(V+E)，适合处理大规模图。
该算法提供了一种高效的方法来分析图的结构特性，特别是在无向图中识别关键的连接点。

[回答]
(无向图的点双连通分量Tarjan算法)
2024-07-16 19:22:50.531 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
使用深度优先搜索（DFS）来检查图是否是二分图。二分图是指可以将图的节点分为两组，使得同一组的节点之间没有边相连。
DFS 颜色标记:
使用一个 color 数组来标记节点的颜色（0 或 1），初始值为 -1（未访问）。
对每个未访问的节点，从该节点开始 DFS，给其标记一种颜色，然后对所有相邻节点进行递归，标记为另一种颜色。
冲突检测:
在 DFS 遍历中，如果发现相邻的节点已被标记为相同颜色，则说明图不是二分图，返回 false。
全图遍历:
对于可能存在多个连通分量的图，遍历所有节点，确保每个节点都被访问。

应用场景:
二分图检测广泛应用于任务分配、网络流、图匹配等问题中。
该算法高效且简单，是检测二分图的标准方法。

时间复杂度:
该算法的时间复杂度为 O(n+m)，其中 n 为节点数，m 为边数。

[回答]
(二分图检测)
2024-07-16 19:22:50.531 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：
对于每个未匹配的节点，尝试找到一个增广路径。
如果找到一条增广路径，则更新匹配关系。
重复此过程，直到无法找到新的增广路径为止。

应用场景: 
常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。

时间复杂度: 
匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。
该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。

[回答]
(匈牙利算法)
2024-07-16 19:22:50.532 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
初始化: init()函数将头指针设置为-1，表示链表为空，并初始化索引。
插入: insert(int a)函数将新元素a插入链表的头部。新节点的ne指向当前头节点，然后更新头指针为新节点的索引。
删除: remove()函数删除链表的头节点，通过更新头指针为下一个节点的索引来实现。

应用场景:
动态数据管理，例如实现栈或队列。
需要频繁插入和删除的场合，如处理中间结果的算法（例如合并排序）。

时间复杂度:
插入和删除操作均为 O(1)，由于操作在链表头部进行。

[回答]
(单链表)
2024-07-16 19:22:50.533 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
双链表由一系列节点组成，每个节点包含指向前一个节点和后一个节点的指针。其基本操作包括初始化、插入和删除节点。
初始化: 设置链表的起始状态，确保第一个节点和最后一个节点的指针正确。
插入: 在指定节点之后插入一个新节点，更新相关指针。
删除: 移除指定节点，并更新其前后节点的指针，以保持链表的完整性。

应用场景: 
双链表适用于频繁插入和删除操作的场景，如编辑器的文本管理、浏览器的历史记录等。

时间复杂度:
插入和删除操作的时间复杂度为 O(1)，只需更新指针。
初始化操作的时间复杂度为 O(1)。
双链表提供了灵活的节点管理，尤其适合动态数据结构的实现。

[回答]
(双链表)
2024-07-16 19:22:50.533 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调栈是一种高效的数据结构，用于维护一个单调递增或递减的序列。该算法通过遍历数组，利用栈来存储索引，并在遍历时根据条件（如比当前数大或小）更新结果。算法流程如下：
初始化一个栈和一个计数器。
遍历数组中的每个元素。
在栈非空时，检查栈顶元素是否满足条件（如是否大于当前元素）。
如果满足条件，弹出栈顶元素，并继续检查下一个。
将当前元素的索引入栈。

应用场景: 
适用于需要快速查询相邻元素关系的场景，如股票价格、气温变化、数据分析等。

时间复杂度:
该算法的时间复杂度为 
O(n)，因为每个元素最多入栈和出栈一次。
通过使用单调栈，能够在一次遍历中高效找到每个元素左边离它最近的比它大或小的元素，极大地提高了查找效率。

[回答]
(单调栈)
2024-07-16 19:22:50.534 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：
使用两个指针 hh 和 tt 表示队列的头和尾。
在每次迭代中，首先移除队列头部超出滑动窗口的元素。
然后，移除队列尾部不符合条件的元素（例如不再是最优解）。
将当前元素加入队列。

应用场景: 
常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。

时间复杂度: 
每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。

[回答]
(单调队列)
2024-07-16 19:22:50.535 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
朴素并查集使用数组表示集合的父节点，支持基本的查找和合并操作。
初始化: 每个元素的父节点指向自己。
查找 (find): 递归查找元素的根父节点，过程中路径压缩以优化后续查询。
合并: 将两个元素的根父节点合并到同一集合。

应用场景: 
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度:
查找操作：O(n) 最坏情况下。
合并操作：O(1) 在查找之后。
该算法简单易于实现，但在大规模数据时效率较低，通常结合路径压缩和按秩合并以优化性能。

[回答]
(朴素并查集)
2024-07-16 19:22:50.536 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程
初始化：为每个节点设置其父节点指向自己，并初始化大小为 1。
查找 (find)：查找并返回节点的根，同时进行路径压缩，以优化后续查询效率。
合并 (union)：将两个集合合并，更新合并后集合的大小，通常将较小集合的根指向较大集合的根，以保持树的平衡。

应用场景
适用于动态连通性问题，如网络连接、社交网络组件管理等。

时间复杂度
find 和 union 操作的时间复杂度为 
O(α(n))，其中α 是阿克曼函数的反函数，增长非常缓慢，几乎可以认为是常数时间。

[回答]
(维护Size的并查集)
2024-07-16 19:22:50.537 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
该算法通过并查集结构维护节点与其祖先节点之间的距离。在查找过程中，不仅返回祖先，还更新当前节点到祖先的距离。
路径压缩: 在 find 函数中，使用路径压缩来优化查找过程，同时累加到祖先的距离。
合并操作: 当合并两个节点的集合时，需要更新到根节点的距离。

应用场景: 
适合需要动态合并和查询的场景，例如动态连通性问题、树形结构中节点间距离计算等。

时间复杂度:
查询与合并操作的平均时间复杂度为 
O(α(n))，其中 α 是阿克曼函数的反函数，表示非常慢增长，通常视为常数。
这个算法非常高效，能够在需要频繁合并和查询的应用中提供良好的性能。

[回答]
(维护到祖宗节点距离的并查集)
2024-07-16 19:22:50.537 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程: 
字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：
初始化哈希值数组 h 和幂数组 p。
在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。
使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。

应用场景: 
字符串哈希常用于字符串比较、查重、子串搜索等问题，尤其在处理长字符串或大量查询时非常高效。

时间复杂度:
预处理时间为 O(n)，其中 n 是字符串长度。
查询时间为 O(1)。
这种方法因其高效性和简单性而广泛应用于字符串相关算法中。

[回答]
(字符串哈希)
2024-07-16 19:22:50.538 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
KMP（Knuth-Morris-Pratt）算法用于在一个文本字符串中高效查找一个模式字符串。该算法利用部分匹配表（也称为“前缀表”）来避免不必要的比较。
构建前缀表: 使用模式字符串生成前缀表，表中每个位置记录了该位置之前的最长相等前后缀的长度。
匹配过程: 遍历文本字符串，并利用前缀表来快速跳过一些匹配失败的字符，从而减少比较次数。

应用场景: 
KMP 算法适用于文本编辑、数据检索、生物信息学等需要高效字符串匹配的场景。

时间复杂度:
预处理时间（构建前缀表）为 O(n)，其中 n 是模式字符串的长度。
匹配时间为 O(m)，其中 m 是文本字符串的长度。
整体复杂度为 O(n+m)，非常高效。
该算法在实际应用中尤其适合处理大规模文本数据的模式匹配问题。

[回答]
(KMP匹配算法)
2024-07-16 19:22:50.539 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程:
线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。
数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。
l, r: 该节点代表的区间的左右端点。
sum: 该区间的总和。
lmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。
tmax: 表示该区间的最大子段和。
构建:
build(int u, int l, int r): 构建线段树。
如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。
单点修改:
modify(int u, int x, int v): 更新节点值，修改指定位置的值。
查询:
query(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。

应用场景:
在实际应用中，可以使用线段树来解决如下问题：
动态数组的区间求和。
动态数组的最大子段和查询。
处理单点更新时保持查询效率。

时间复杂度:
构建时间：O(n)
修改时间：O(logn)
查询时间：O(logn)
这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。

[回答]
(线段树(单点修改))
2024-07-16 19:22:50.540 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
线段树（区间修改）
过程:
节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。
核心功能:
eval 函数: 更新当前节点的值，考虑到乘法和加法的影响。
pushup 函数: 更新父节点的和，基于子节点的和。
pushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。
build 函数: 构建线段树，初始化区间。
modify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。
query 函数: 查询给定区间的和，同时处理懒惰更新。

应用场景: 
线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。
线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。

时间复杂度:
建树: O(n)
修改: O(logn)（使用懒惰标记）
查询: O(logn)
此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。

[回答]
(线段树区间修改)
2024-07-16 19:22:50.541 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。
核心操作:
lowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。
modify(int x, int c): 更新树状数组中位置 x 的值，增加 c。
query(int x): 查询数组前 x 个元素的和。

应用场景:
常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。
该数据结构简单而高效，适合处理频繁的更新和查询操作。

时间复杂度:
更新操作和查询操作均为 O(logn)。

[回答]
(树状数组)
2024-07-16 19:22:50.542 | DEBUG    | chatbot.describe:__init__:43 - [doc][问题]
过程：
Trie 树又称为字典树是一种用于存储动态集合或前缀字符串的数据结构，特别适合处理字符串前缀查询。它以树的形式存储字符串，使得相同前缀的字符串共享存储空间。
主要操作:
插入 (insert): 将字符串插入到 Trie 中，同时更新节点计数。
查询 (query): 查询一个字符串在 Trie 中出现的次数。

应用场景: 
Trie树(字典树)广泛应用于自动补全、拼写检查、IP 路由、前缀匹配等问题。由于它支持快速的前缀查询，因此在大规模字符串数据处理中非常有效。

时间复杂度:
插入和查询操作的时间复杂度为 
O(L)，其中 L 是字符串的长度。对于每个字符都需要进行常数时间的操作。

[回答]
(trie树)
2024-07-16 19:23:49.782 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 19:23:49.783 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:23:52.754 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:59 - [algorithm_chao_name](树状数组)
2024-07-16 19:24:04.628 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:61 - [algorithm_code from agnet]根据提供的信息，最相关的关键词是“树状数组”。树状数组（Binary Indexed Tree, BIT），也被称作Fenwick树，是一种用于高效处理数组前缀和、单点更新以及区间查询问题的数据结构。它能够在O(log n)的时间复杂度内完成这些操作。

从提供的信息中，可以看出树状数组有以下特点：

- 它通过lowbit操作来快速计算前缀和以及更新操作。
- 构建树状数组的步骤包括读入数组元素，并将其加入树状数组中。
- 树状数组的核心思想是存储一个数组的累积和，利用偏移快速计算区间和。
- 在树状数组中，下标通常从1开始。
- 它可以用于解决单点更新和区间查询问题。

因此，基于这些信息，如果需要在给出的关键词中选择一个与描述最相关的，那么“树状数组”是最合适的选择。
2024-07-16 19:25:09.188 | DEBUG    | chatbot.function_agent:__init__:31 - [name_list_prompt]
        你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
        你将获得一段关于某个算法的大致描述。
        请你在以下关键词中选取最相关的一个
        有向图的强连通分量__int128读写模板子无向图的点双连通分量二分图匈牙利算法单链表双链表
2024-07-16 19:25:50.063 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 19:25:50.064 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:25:53.273 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:59 - [algorithm_chao_name](树状数组)
2024-07-16 19:26:00.900 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:61 - [algorithm_code from agnet]根据提供的信息，最相关的关键词是“树状数组”。树状数组（Binary Indexed Tree, BIT），也被称为Fenwick树，是一种用于高效处理数组前缀和、单点更新以及区间查询问题的数据结构。从提供的信息中可以看出，树状数组能够在O(log n)的时间复杂度内完成单点更新和查询操作，这使得它在某些情况下比线段树更为高效和简便。

在树状数组中，通过lowbit函数可以获取一个整数最低有效位上的数字，这是实现树状数组的关键技术之一。构造树状数组时，原数组会被转换成一个树状结构，其中每个节点存储了原数组中一定范围内元素的和。

因此，根据这些信息，如果需要在给出的关键词中选择一个与描述最相关的，那么“树状数组”是最合适的选择。
2024-07-16 19:27:11.175 | DEBUG    | chatbot.function_agent:__init__:31 - [name_list_prompt]
        你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
        你将获得一段关于某个算法的大致描述。
        请你在以下关键词中选取最相关的一个
        有向图的强连通分量
__int128读写模板子
无向图的点双连通分量
二分图
匈牙利算法
单链表
双链表

2024-07-16 19:27:50.782 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 19:27:50.783 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:27:53.931 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:59 - [algorithm_chao_name](树状数组)
2024-07-16 19:28:00.639 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:61 - [algorithm_code from agnet]根据提供的信息，最相关的关键词是：

树状数组

树状数组（Binary Indexed Tree, BIT），也称为Fenwick树，是一种用于高效处理数组前缀和、单点更新以及区间查询问题的数据结构。从提供的信息中可以看出，树状数组可以在O(log n)的时间复杂度内完成单点更新和区间查询操作，这使得它在处理某些特定类型的问题时非常有用。而且，树状数组的实现依赖于lowbit函数，该函数用于确定数组中每个元素的存储位置以及更新和查询时节点间的跳转关系。因此，从问题和参考信息的背景来看，树状数组是最相关的关键词。
2024-07-16 19:29:47.610 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 19:29:47.610 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 19:29:47.612 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 19:29:47.613 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 19:29:47.613 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 19:29:47.614 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 19:29:47.627 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 19:29:47.627 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 19:29:47.628 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 19:29:47.631 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 19:29:47.632 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 19:29:47.633 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 19:29:47.637 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 19:29:47.637 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 19:29:47.638 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 19:29:47.641 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 19:29:47.642 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 19:29:47.643 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 19:29:47.645 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 19:29:47.646 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 19:29:47.648 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 19:29:47.651 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 19:29:47.651 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 19:29:47.652 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 19:29:47.656 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 19:29:47.657 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 19:29:47.657 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 19:29:47.661 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 19:29:47.661 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 19:29:47.662 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 19:29:47.665 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 19:29:47.666 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 19:29:47.667 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 19:29:47.671 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 19:29:47.671 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 19:29:47.672 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 19:29:47.675 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 19:29:47.675 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 19:29:47.676 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 19:29:47.679 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 19:29:47.680 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 19:29:47.680 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 19:29:47.683 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 19:29:47.684 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 19:29:47.685 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 19:29:47.688 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 19:29:47.689 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 19:29:47.690 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 19:29:47.693 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 19:29:47.693 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 19:29:47.694 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 19:29:47.698 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 19:29:47.698 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 19:29:47.699 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 19:29:47.702 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 19:29:47.702 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 19:29:47.704 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 19:29:47.707 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 19:29:47.707 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 19:29:47.708 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 19:29:47.712 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 19:29:47.712 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 19:29:47.713 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 19:29:47.717 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 19:29:47.718 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 19:29:47.720 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 19:29:47.724 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 19:29:47.725 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 19:29:47.727 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 19:29:47.732 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 19:29:47.732 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 19:29:47.733 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 19:29:47.737 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 19:29:47.737 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 19:29:47.738 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 19:29:47.747 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 19:29:47.747 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 19:29:47.748 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 19:29:47.751 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 19:29:47.752 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 19:29:47.754 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 19:29:47.757 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 19:29:47.757 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 19:29:47.759 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 19:29:47.762 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 19:29:47.762 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 19:29:47.764 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 19:29:47.768 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 19:29:47.768 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 19:29:47.770 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 19:29:47.773 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 19:29:47.773 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 19:29:47.774 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 19:29:47.777 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 19:29:47.778 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 19:29:47.778 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 19:29:47.782 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 19:29:47.782 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 19:29:47.783 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 19:29:47.787 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 19:29:47.788 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 19:29:47.789 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 19:29:47.793 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 19:29:47.793 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 19:29:47.795 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 19:29:47.798 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 19:29:47.798 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 19:29:47.799 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 19:29:47.803 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 19:29:47.803 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 19:29:47.805 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 19:29:47.809 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 19:29:47.809 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 19:29:47.810 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 19:29:47.813 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 19:29:47.814 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 19:29:47.816 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 19:29:47.819 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 19:29:47.820 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 19:29:47.822 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 19:29:47.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 19:29:47.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 19:29:47.828 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 19:29:47.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 19:29:47.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 19:29:47.833 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 19:29:47.837 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 19:29:47.838 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 19:29:47.839 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 19:29:47.843 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 19:29:47.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 19:29:47.845 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 19:29:47.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 19:29:47.850 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 19:29:47.851 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 19:29:47.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 19:29:47.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 19:29:47.857 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 19:29:47.860 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 19:29:47.861 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 19:29:47.862 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 19:29:47.865 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 19:29:47.866 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 19:29:47.868 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 19:29:47.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 19:29:47.873 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 19:29:47.875 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 19:29:47.879 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 19:29:47.880 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 19:29:47.882 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 19:29:47.884 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 19:29:47.885 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 19:29:47.887 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 19:29:47.891 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 19:29:47.891 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 19:29:47.892 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 19:29:47.894 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 19:29:47.894 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 19:29:47.895 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 19:29:47.897 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 19:29:47.897 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 19:29:47.898 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 19:29:47.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 19:29:47.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 19:29:47.900 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 19:29:47.901 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 19:29:47.901 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 19:29:47.902 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 19:29:47.905 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 19:29:47.906 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 19:29:47.906 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 19:29:47.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 19:29:47.910 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 19:29:47.911 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 19:29:47.914 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 19:29:47.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 19:29:47.915 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 19:29:47.919 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 19:29:47.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 19:29:47.921 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 19:29:47.925 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 19:29:47.925 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 19:29:47.926 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 19:29:47.929 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 19:29:47.930 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 19:29:47.931 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 19:29:47.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 19:29:47.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 19:29:47.940 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 19:29:47.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 19:29:47.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 19:29:47.948 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 19:29:47.953 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 19:29:47.954 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 19:29:47.955 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 19:29:47.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 19:29:47.959 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 19:29:47.960 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 19:29:47.964 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 19:29:48.984 | DEBUG    | chatbot.function_agent:__init__:31 - [name_list_prompt]
        你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
        你将获得一段关于某个算法的大致描述。
        请你在以下关键词中选取最相关的一个
        有向图的强连通分量
__int128读写模板子
无向图的点双连通分量
二分图
匈牙利算法
单链表
双链表
快速排序
归并排序
整数二分
浮点数二分
整数三分
浮点数三分
高精度加法
高精度减法
高精度乘低精度
高精度除以低精度
子矩阵的和
差分矩阵
双指针算法
数据离散化_保序离散化
数据离散化_非保序离散化
RMQ
试除法判定质数
试除法分解质因数
朴素素数筛法
线性素数筛法
区间素数筛法
Min_25
试除法求约数
欧几里得算法
欧拉函数
筛法求欧拉函数
卡特兰数求模
快速求第n位卡特兰数
Java大数打表卡特兰数
快速幂
位运算处理大数相乘
扩展欧几里得算法
高斯消元
递归法求组合数
预处理逆元的方式求组合数
Lucas定理
有向图的拓扑序
树的直径
堆优化版Dijkstra
朴素版spfa
SFA优化版的spfa
SPFA判负环正环
loyd算法 O(n^3)
prim算法
kruskal算法
最小生成森林
倍增在线算法
targin离线算法
单调栈
单调队列
朴素并查集
维护size的并查集
维护到祖宗节点距离的并查集
字符串哈希
KMP
线段树(单点修改)
线段树(区间修改)
树状数组
Trie树

2024-07-16 19:30:13.193 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 19:30:13.194 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 19:30:16.234 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:59 - [algorithm_chao_name](树状数组)
2024-07-16 19:30:24.487 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:61 - [algorithm_code from agnet]根据提供的信息，树状数组（Binary Indexed Tree, BIT）是一种高效的数据结构，它可以在O(log n)的时间复杂度内完成单点更新和前缀和查询操作。从参考信息的描述来看，树状数组主要用于以下两种操作：

1. 单点更新：在数组的某个位置增加或减少一个值。
2. 前缀和查询：查询数组从第一个元素到指定位置的所有元素之和。

树状数组的核心思想是利用一个数组来存储原数组的累积和，通过lowbit函数来快速定位需要更新或查询的节点。

在给出的关键词中，最相关的一个是：

**树状数组**

因为它直接对应于所描述的数据结构和它的应用场景。其他关键词虽然也涉及算法和数据结构，但与树状数组的功能和用途不是直接相关的。
2024-07-16 20:01:36.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:01:36.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:01:36.938 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:01:36.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:01:36.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:01:36.941 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:01:36.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:01:36.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:01:36.943 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:01:36.944 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:01:36.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:01:36.946 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:01:36.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:01:36.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:01:36.948 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:01:36.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:01:36.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:01:36.950 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:01:36.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:01:36.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:01:36.952 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:01:36.952 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:01:36.952 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:01:36.953 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:01:36.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:01:36.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:01:36.956 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:01:36.956 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:01:36.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:01:36.957 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:01:36.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:01:36.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:01:36.959 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:01:36.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:01:36.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:01:36.961 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:01:36.962 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:01:36.962 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:01:36.962 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:01:36.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:01:36.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:01:36.964 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:01:36.964 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:01:36.964 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:01:36.965 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:01:36.966 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:01:36.966 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:01:36.967 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:01:36.968 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:01:36.968 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:01:36.969 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:01:36.969 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:01:36.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:01:36.970 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:01:36.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:01:36.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:01:36.972 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:01:36.972 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:01:36.973 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:01:36.973 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:01:36.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:01:36.975 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:01:36.976 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:01:36.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:01:36.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:01:36.978 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:01:36.979 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:01:36.979 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:01:36.981 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:01:36.983 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:01:36.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:01:36.984 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:01:36.985 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:01:36.985 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:01:36.986 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:01:36.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:01:36.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:01:36.987 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:01:36.988 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:01:36.989 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:01:36.990 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:01:36.991 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:01:36.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:01:36.992 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:01:36.993 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:01:36.993 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:01:36.995 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:01:36.996 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:01:36.997 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:01:36.997 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:01:36.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:01:36.999 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:01:36.999 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:01:37.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:01:37.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:01:37.001 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:01:37.002 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:01:37.002 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:01:37.003 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:01:37.004 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:01:37.004 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:01:37.006 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:01:37.008 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:01:37.008 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:01:37.009 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:01:37.010 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:01:37.010 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:01:37.011 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:01:37.012 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:01:37.012 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:01:37.013 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:01:37.015 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:01:37.015 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:01:37.016 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:01:37.018 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:01:37.018 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:01:37.019 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:01:37.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:01:37.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:01:37.022 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:01:37.023 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:01:37.024 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:01:37.025 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:01:37.026 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:01:37.026 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:01:37.027 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:01:37.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:01:37.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:01:37.031 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:01:37.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:01:37.033 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:01:37.033 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:01:37.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:01:37.035 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:01:37.036 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:01:37.038 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:01:37.038 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:01:37.040 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:01:37.041 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:01:37.042 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:01:37.043 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:01:37.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:01:37.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:01:37.046 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:01:37.049 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:01:37.049 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:01:37.051 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:01:37.054 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:01:37.055 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:01:37.057 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:01:37.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:01:37.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:01:37.062 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:01:37.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:01:37.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:01:37.067 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:01:37.068 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:01:37.069 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:01:37.070 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:01:37.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:01:37.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:01:37.073 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:01:37.074 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:01:37.074 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:01:37.075 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:01:37.076 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:01:37.077 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:01:37.077 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:01:37.078 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:01:37.078 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:01:37.079 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:01:37.079 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:01:37.080 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:01:37.081 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:01:37.082 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:01:37.082 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:01:37.083 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:01:37.083 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:01:37.084 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:01:37.085 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:01:37.086 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:01:37.086 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:01:37.087 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:01:37.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:01:37.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:01:37.089 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:01:37.090 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:01:37.091 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:01:37.094 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:01:37.096 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:01:37.097 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:01:37.100 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:01:37.103 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:01:37.103 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:01:37.104 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:01:37.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:01:37.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:01:37.106 | DEBUG    | sql.mysql:Insert_Data:34 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:01:37.108 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:01:38.141 | DEBUG    | chatbot.function_agent:__init__:31 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个作为输出
        有向图的强连通分量
__int128读写模板子
无向图的点双连通分量
二分图
匈牙利算法
单链表
双链表
快速排序
归并排序
整数二分
浮点数二分
整数三分
浮点数三分
高精度加法
高精度减法
高精度乘低精度
高精度除以低精度
子矩阵的和
差分矩阵
双指针算法
数据离散化_保序离散化
数据离散化_非保序离散化
RMQ
试除法判定质数
试除法分解质因数
朴素素数筛法
线性素数筛法
区间素数筛法
Min_25
试除法求约数
欧几里得算法
欧拉函数
筛法求欧拉函数
卡特兰数求模
快速求第n位卡特兰数
Java大数打表卡特兰数
快速幂
位运算处理大数相乘
扩展欧几里得算法
高斯消元
递归法求组合数
预处理逆元的方式求组合数
Lucas定理
有向图的拓扑序
树的直径
堆优化版Dijkstra
朴素版spfa
SFA优化版的spfa
SPFA判负环正环
loyd算法 O(n^3)
prim算法
kruskal算法
最小生成森林
倍增在线算法
targin离线算法
单调栈
单调队列
朴素并查集
维护size的并查集
维护到祖宗节点距离的并查集
字符串哈希
KMP
线段树(单点修改)
线段树(区间修改)
树状数组
Trie树

2024-07-16 20:02:07.526 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 20:02:07.527 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 20:02:13.683 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:59 - [algorithm_chao_name](树状数组)
2024-07-16 20:02:19.750 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:61 - [algorithm_code from agnet]树状数组（Binary Indexed Tree, BIT）是这个场景下最相关的一个关键词。根据提供的参考信息，树状数组是一种数据结构，它可以在O(log n)的时间复杂度内完成单点更新和区间查询（前缀和）操作。它通过存储原数组的累积和，并利用lowbit函数快速计算区间和，从而实现高效的算法操作。参考信息中多次提到了树状数组在算法竞赛和高效数据处理中的重要性。
2024-07-16 20:25:59.997 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:25:59.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:25:59.999 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:26:00.001 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:26:00.002 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:26:00.002 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:26:00.003 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:26:00.004 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:26:00.005 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:26:00.006 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:26:00.007 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:26:00.008 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:26:00.010 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:26:00.010 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:26:00.011 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:26:00.013 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:26:00.013 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:00.015 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:00.016 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:26:00.016 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:00.018 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:00.019 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:26:00.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:26:00.021 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:26:00.022 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:26:00.023 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:00.025 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:00.026 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:26:00.027 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:26:00.028 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:26:00.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:26:00.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:00.030 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:00.031 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:26:00.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:26:00.032 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:26:00.033 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:26:00.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:26:00.035 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:26:00.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:26:00.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:26:00.037 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:26:00.038 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:26:00.039 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:26:00.039 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:26:00.040 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:26:00.041 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:26:00.042 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:26:00.042 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:26:00.043 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:26:00.043 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:26:00.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:26:00.045 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:26:00.045 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:26:00.046 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:26:00.046 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:26:00.047 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:26:00.048 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:26:00.049 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:26:00.049 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:26:00.050 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:26:00.050 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:26:00.051 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:26:00.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:26:00.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:26:00.054 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:26:00.055 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:26:00.056 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:26:00.057 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:26:00.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:26:00.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:26:00.059 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:26:00.061 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:26:00.061 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:26:00.062 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:26:00.063 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:26:00.063 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:26:00.064 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:26:00.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:26:00.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:26:00.066 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:26:00.068 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:26:00.069 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:26:00.070 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:26:00.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:26:00.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:26:00.072 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:26:00.073 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:26:00.074 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:26:00.075 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:26:00.076 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:26:00.076 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:26:00.078 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:26:00.079 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:26:00.079 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:26:00.079 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:26:00.080 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:26:00.080 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:26:00.081 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:26:00.082 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:26:00.082 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:26:00.084 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:26:00.086 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:26:00.086 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:26:00.087 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:26:00.087 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:26:00.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:26:00.088 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:26:00.090 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:26:00.091 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:26:00.092 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:26:00.093 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:26:00.094 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:26:00.095 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:26:00.096 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:26:00.096 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:26:00.098 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:26:00.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:26:00.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:26:00.100 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:26:00.102 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:26:00.103 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:26:00.104 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:26:00.106 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:26:00.106 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:26:00.107 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:26:00.109 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:26:00.109 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:26:00.111 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:26:00.113 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:26:00.113 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:26:00.114 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:26:00.115 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:26:00.115 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:26:00.117 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:26:00.118 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:26:00.119 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:26:00.120 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:26:00.121 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:26:00.122 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:26:00.123 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:26:00.124 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:26:00.125 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:26:00.126 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:26:00.129 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:26:00.129 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:26:00.131 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:26:00.134 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:26:00.134 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:26:00.136 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:26:00.138 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:26:00.138 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:26:00.141 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:26:00.144 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:26:00.144 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:26:00.146 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:26:00.148 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:26:00.148 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:26:00.149 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:26:00.151 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:26:00.152 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:26:00.153 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:26:00.154 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:26:00.154 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:26:00.155 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:26:00.156 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:26:00.156 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:26:00.157 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:26:00.157 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:26:00.158 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:26:00.158 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:26:00.159 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:26:00.160 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:26:00.160 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:26:00.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:26:00.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:26:00.162 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:26:00.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:26:00.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:26:00.164 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:26:00.166 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:26:00.166 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:26:00.166 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:26:00.168 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:26:00.169 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:26:00.170 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:26:00.171 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:26:00.171 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:26:00.174 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:26:00.177 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:26:00.177 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:26:00.180 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:26:00.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:26:00.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:26:00.184 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:26:00.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:26:00.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:26:00.187 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:26:00.188 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:26:25.471 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:26:25.471 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:26:25.473 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:26:25.474 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:26:25.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:26:25.475 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:26:25.476 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:26:25.477 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:26:25.478 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:26:25.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:26:25.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:26:25.480 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:26:25.481 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:26:25.482 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:26:25.482 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:26:25.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:26:25.484 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:25.485 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:25.485 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:26:25.486 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:25.486 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:26:25.488 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:26:25.488 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:26:25.489 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:26:25.490 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:26:25.490 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:25.491 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:25.492 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:26:25.493 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:26:25.493 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:26:25.494 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:26:25.494 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:25.495 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:26:25.496 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:26:25.496 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:26:25.497 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:26:25.497 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:26:25.498 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:26:25.498 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:26:25.499 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:26:25.499 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:26:25.500 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:26:25.500 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:26:25.501 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:26:25.501 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:26:25.502 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:26:25.503 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:26:25.503 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:26:25.504 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:26:25.504 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:26:25.504 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:26:25.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:26:25.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:26:25.506 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:26:25.508 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:26:25.508 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:26:25.509 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:26:25.509 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:26:25.510 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:26:25.511 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:26:25.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:26:25.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:26:25.513 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:26:25.514 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:26:25.515 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:26:25.516 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:26:25.517 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:26:25.517 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:26:25.518 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:26:25.520 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:26:25.521 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:26:25.521 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:26:25.522 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:26:25.523 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:26:25.523 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:26:25.523 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:26:25.524 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:26:25.524 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:26:25.526 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:26:25.526 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:26:25.527 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:26:25.528 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:26:25.529 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:26:25.529 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:26:25.530 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:26:25.530 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:26:25.531 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:26:25.533 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:26:25.533 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:26:25.534 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:26:25.535 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:26:25.535 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:26:25.536 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:26:25.537 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:26:25.537 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:26:25.538 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:26:25.539 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:26:25.540 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:26:25.540 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:26:25.541 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:26:25.542 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:26:25.543 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:26:25.545 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:26:25.545 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:26:25.546 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:26:25.547 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:26:25.547 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:26:25.548 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:26:25.549 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:26:25.549 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:26:25.551 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:26:25.552 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:26:25.552 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:26:25.554 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:26:25.555 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:26:25.555 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:26:25.556 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:26:25.557 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:26:25.557 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:26:25.559 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:26:25.560 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:26:25.560 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:26:25.562 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:26:25.563 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:26:25.563 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:26:25.565 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:26:25.566 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:26:25.568 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:26:25.569 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:26:25.571 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:26:25.571 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:26:25.572 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:26:25.574 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:26:25.574 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:26:25.575 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:26:25.577 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:26:25.577 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:26:25.578 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:26:25.580 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:26:25.580 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:26:25.582 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:26:25.583 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:26:25.583 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:26:25.585 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:26:25.586 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:26:25.586 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:26:25.589 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:26:25.591 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:26:25.591 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:26:25.593 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:26:25.596 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:26:25.596 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:26:25.598 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:26:25.600 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:26:25.601 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:26:25.603 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:26:25.604 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:26:25.605 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:26:25.606 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:26:25.606 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:26:25.608 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:26:25.609 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:26:25.610 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:26:25.610 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:26:25.611 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:26:25.612 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:26:25.613 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:26:25.613 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:26:25.614 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:26:25.614 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:26:25.614 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:26:25.615 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:26:25.616 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:26:25.617 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:26:25.618 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:26:25.618 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:26:25.619 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:26:25.620 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:26:25.620 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:26:25.621 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:26:25.622 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:26:25.622 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:26:25.624 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:26:25.625 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:26:25.625 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:26:25.626 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:26:25.627 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:26:25.627 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:26:25.630 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:26:25.633 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:26:25.633 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:26:25.636 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:26:25.639 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:26:25.639 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:26:25.640 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:26:25.641 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:26:25.641 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:26:25.642 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:26:25.644 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:26:26.671 | DEBUG    | chatbot.function_agent:__init__:32 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 20:27:10.995 | DEBUG    | __main__:algorithm_chat:30 - [message]树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。
2024-07-16 20:27:10.996 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 20:27:14.016 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:60 - [algorithm_chao_name](树状数组)
2024-07-16 20:27:17.132 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:62 - [algorithm_code from agnet]65
2024-07-16 20:28:27.409 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:28:27.410 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:28:27.411 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:28:27.412 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:28:27.413 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:28:27.413 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:28:27.414 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:28:27.414 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:28:27.415 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:28:27.416 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:28:27.417 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:28:27.418 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:28:27.419 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:28:27.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:28:27.420 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:28:27.421 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:28:27.421 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:28:27.421 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:28:27.423 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:28:27.424 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:28:27.426 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:28:27.427 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:28:27.427 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:28:27.427 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:28:27.428 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:28:27.428 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:28:27.429 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:28:27.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:28:27.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:28:27.431 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:28:27.432 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:28:27.433 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:28:27.433 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:28:27.434 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:28:27.434 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:28:27.435 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:28:27.435 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:28:27.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:28:27.436 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:28:27.437 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:28:27.437 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:28:27.439 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:28:27.439 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:28:27.439 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:28:27.440 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:28:27.441 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:28:27.441 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:28:27.442 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:28:27.442 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:28:27.443 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:28:27.443 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:28:27.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:28:27.445 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:28:27.445 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:28:27.446 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:28:27.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:28:27.448 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:28:27.449 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:28:27.449 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:28:27.450 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:28:27.451 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:28:27.451 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:28:27.452 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:28:27.453 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:28:27.453 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:28:27.455 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:28:27.456 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:28:27.457 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:28:27.457 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:28:27.460 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:28:27.460 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:28:27.461 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:28:27.462 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:28:27.462 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:28:27.462 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:28:27.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:28:27.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:28:27.464 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:28:27.465 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:28:27.466 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:28:27.467 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:28:27.469 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:28:27.469 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:28:27.470 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:28:27.471 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:28:27.471 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:28:27.473 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:28:27.474 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:28:27.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:28:27.476 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:28:27.476 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:28:27.476 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:28:27.478 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:28:27.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:28:27.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:28:27.480 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:28:27.481 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:28:27.482 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:28:27.482 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:28:27.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:28:27.484 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:28:27.485 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:28:27.487 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:28:27.488 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:28:27.488 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:28:27.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:28:27.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:28:27.491 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:28:27.492 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:28:27.492 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:28:27.494 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:28:27.495 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:28:27.496 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:28:27.497 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:28:27.497 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:28:27.498 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:28:27.499 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:28:27.500 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:28:27.501 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:28:27.502 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:28:27.504 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:28:27.504 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:28:27.505 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:28:27.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:28:27.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:28:27.509 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:28:27.510 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:28:27.511 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:28:27.512 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:28:27.513 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:28:27.513 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:28:27.515 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:28:27.517 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:28:27.517 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:28:27.518 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:28:27.519 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:28:27.520 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:28:27.523 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:28:27.525 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:28:27.525 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:28:27.526 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:28:27.527 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:28:27.527 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:28:27.529 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:28:27.531 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:28:27.531 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:28:27.533 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:28:27.535 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:28:27.536 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:28:27.538 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:28:27.540 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:28:27.541 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:28:27.544 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:28:27.547 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:28:27.547 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:28:27.549 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:28:27.550 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:28:27.551 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:28:27.552 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:28:27.553 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:28:27.553 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:28:27.554 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:28:27.555 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:28:27.556 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:28:27.557 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:28:27.558 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:28:27.559 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:28:27.559 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:28:27.559 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:28:27.560 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:28:27.560 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:28:27.561 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:28:27.561 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:28:27.562 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:28:27.563 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:28:27.563 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:28:27.564 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:28:27.565 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:28:27.566 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:28:27.567 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:28:27.568 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:28:27.568 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:28:27.569 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:28:27.570 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:28:27.570 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:28:27.572 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:28:27.573 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:28:27.573 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:28:27.576 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:28:27.579 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:28:27.579 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:28:27.582 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:28:27.586 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:28:27.587 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:28:27.588 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:28:27.589 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:28:27.589 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:28:27.591 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:28:27.593 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:28:28.725 | DEBUG    | chatbot.function_agent:__init__:32 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 20:28:59.850 | DEBUG    | __main__:algorithm_chat:30 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 20:28:59.851 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 20:29:02.946 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:60 - [algorithm_chao_name](单调队列)
2024-07-16 20:29:06.124 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:62 - [algorithm_code from agnet]57

单调队列是一种特殊的队列数据结构，它在队列的基础上增加了单调性约束，通常用于解决滑动窗口类型的问题，例如在给定数组中找到每个长度为k的连续子数组中的最大值或最小值。通过保持队列的单调递增或递减特性，可以高效地实现这一目的。
2024-07-16 20:30:10.329 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:30:10.329 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:30:10.331 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:30:10.332 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:30:10.333 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:30:10.333 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:30:10.334 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:30:10.334 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:30:10.335 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:30:10.336 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:30:10.336 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:30:10.338 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:30:10.340 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:30:10.340 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:30:10.340 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:30:10.341 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:30:10.341 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:30:10.342 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:30:10.342 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:30:10.343 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:30:10.344 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:30:10.345 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:30:10.345 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:30:10.346 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:30:10.348 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:30:10.348 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:30:10.348 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:30:10.349 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:30:10.350 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:30:10.350 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:30:10.351 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:30:10.352 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:30:10.352 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:30:10.353 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:30:10.354 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:30:10.354 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:30:10.354 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:30:10.355 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:30:10.355 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:30:10.356 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:30:10.356 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:30:10.357 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:30:10.357 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:30:10.357 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:30:10.358 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:30:10.359 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:30:10.360 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:30:10.360 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:30:10.361 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:30:10.361 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:30:10.362 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:30:10.363 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:30:10.363 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:30:10.363 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:30:10.364 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:30:10.364 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:30:10.365 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:30:10.366 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:30:10.367 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:30:10.367 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:30:10.369 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:30:10.369 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:30:10.369 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:30:10.370 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:30:10.370 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:30:10.372 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:30:10.373 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:30:10.374 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:30:10.376 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:30:10.378 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:30:10.379 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:30:10.379 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:30:10.380 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:30:10.381 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:30:10.381 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:30:10.382 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:30:10.382 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:30:10.383 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:30:10.383 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:30:10.384 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:30:10.385 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:30:10.386 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:30:10.386 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:30:10.388 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:30:10.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:30:10.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:30:10.390 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:30:10.391 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:30:10.392 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:30:10.393 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:30:10.394 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:30:10.394 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:30:10.395 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:30:10.396 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:30:10.397 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:30:10.397 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:30:10.398 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:30:10.398 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:30:10.399 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:30:10.400 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:30:10.400 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:30:10.401 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:30:10.403 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:30:10.403 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:30:10.404 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:30:10.404 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:30:10.404 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:30:10.406 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:30:10.407 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:30:10.408 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:30:10.409 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:30:10.411 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:30:10.411 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:30:10.412 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:30:10.413 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:30:10.414 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:30:10.415 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:30:10.416 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:30:10.417 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:30:10.418 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:30:10.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:30:10.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:30:10.421 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:30:10.423 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:30:10.423 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:30:10.424 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:30:10.426 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:30:10.426 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:30:10.428 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:30:10.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:30:10.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:30:10.431 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:30:10.432 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:30:10.432 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:30:10.433 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:30:10.435 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:30:10.435 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:30:10.437 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:30:10.440 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:30:10.440 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:30:10.441 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:30:10.443 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:30:10.443 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:30:10.445 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:30:10.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:30:10.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:30:10.449 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:30:10.451 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:30:10.452 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:30:10.454 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:30:10.456 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:30:10.457 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:30:10.459 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:30:10.462 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:30:10.462 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:30:10.464 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:30:10.466 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:30:10.466 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:30:10.467 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:30:10.468 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:30:10.468 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:30:10.469 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:30:10.471 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:30:10.471 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:30:10.472 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:30:10.473 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:30:10.474 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:30:10.474 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:30:10.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:30:10.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:30:10.476 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:30:10.476 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:30:10.477 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:30:10.478 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:30:10.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:30:10.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:30:10.480 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:30:10.481 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:30:10.481 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:30:10.482 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:30:10.484 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:30:10.484 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:30:10.485 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:30:10.486 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:30:10.486 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:30:10.487 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:30:10.488 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:30:10.488 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:30:10.491 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:30:10.494 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:30:10.494 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:30:10.496 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:30:10.500 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:30:10.500 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:30:10.501 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:30:10.502 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:30:10.502 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:30:10.503 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:30:10.505 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:30:11.571 | DEBUG    | chatbot.function_agent:__init__:32 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 20:30:50.415 | DEBUG    | __main__:algorithm_chat:30 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 20:30:50.415 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 20:30:53.091 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:60 - [algorithm_chao_name](单调队列)
2024-07-16 20:30:56.020 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:62 - [algorithm_code from agnet]57

单调队列是一种特殊的队列数据结构，它用于解决滑动窗口类型的问题，能够维护队列中元素的单调性（递增或递减）。在算法竞赛和某些实际应用问题中，单调队列可以高效地解决一类“在固定大小窗口内找到最值”的问题。
2024-07-16 20:32:15.084 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:32:15.085 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:32:15.086 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:32:15.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:32:15.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:32:15.089 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:32:15.090 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:32:15.090 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:32:15.091 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:32:15.093 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:32:15.093 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:32:15.094 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:32:15.095 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:32:15.095 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:32:15.096 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:32:15.097 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:32:15.097 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:32:15.099 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:32:15.100 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:32:15.100 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:32:15.101 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:32:15.102 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:32:15.103 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:32:15.103 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:32:15.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:32:15.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:32:15.106 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:32:15.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:32:15.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:32:15.108 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:32:15.109 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:32:15.109 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:32:15.109 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:32:15.111 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:32:15.111 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:32:15.111 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:32:15.112 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:32:15.112 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:32:15.113 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:32:15.113 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:32:15.114 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:32:15.114 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:32:15.115 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:32:15.115 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:32:15.116 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:32:15.116 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:32:15.116 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:32:15.118 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:32:15.119 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:32:15.119 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:32:15.120 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:32:15.121 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:32:15.122 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:32:15.122 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:32:15.123 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:32:15.123 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:32:15.124 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:32:15.124 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:32:15.125 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:32:15.125 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:32:15.126 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:32:15.127 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:32:15.127 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:32:15.129 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:32:15.129 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:32:15.130 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:32:15.131 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:32:15.131 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:32:15.133 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:32:15.135 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:32:15.135 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:32:15.136 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:32:15.137 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:32:15.137 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:32:15.137 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:32:15.138 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:32:15.138 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:32:15.139 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:32:15.140 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:32:15.141 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:32:15.142 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:32:15.143 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:32:15.143 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:32:15.144 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:32:15.145 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:32:15.145 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:32:15.146 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:32:15.148 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:32:15.148 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:32:15.148 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:32:15.149 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:32:15.150 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:32:15.150 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:32:15.151 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:32:15.151 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:32:15.152 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:32:15.153 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:32:15.154 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:32:15.155 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:32:15.156 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:32:15.156 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:32:15.158 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:32:15.159 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:32:15.160 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:32:15.160 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:32:15.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:32:15.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:32:15.162 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:32:15.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:32:15.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:32:15.165 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:32:15.166 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:32:15.166 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:32:15.168 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:32:15.169 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:32:15.170 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:32:15.171 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:32:15.172 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:32:15.172 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:32:15.173 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:32:15.176 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:32:15.176 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:32:15.177 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:32:15.179 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:32:15.179 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:32:15.180 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:32:15.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:32:15.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:32:15.185 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:32:15.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:32:15.187 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:32:15.189 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:32:15.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:32:15.191 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:32:15.192 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:32:15.193 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:32:15.193 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:32:15.195 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:32:15.197 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:32:15.198 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:32:15.199 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:32:15.200 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:32:15.200 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:32:15.202 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:32:15.204 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:32:15.204 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:32:15.206 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:32:15.208 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:32:15.209 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:32:15.211 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:32:15.213 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:32:15.213 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:32:15.216 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:32:15.219 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:32:15.219 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:32:15.220 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:32:15.221 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:32:15.222 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:32:15.223 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:32:15.225 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:32:15.225 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:32:15.226 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:32:15.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:32:15.228 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:32:15.228 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:32:15.230 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:32:15.230 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:32:15.231 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:32:15.231 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:32:15.232 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:32:15.232 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:32:15.233 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:32:15.233 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:32:15.234 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:32:15.235 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:32:15.235 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:32:15.236 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:32:15.237 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:32:15.237 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:32:15.238 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:32:15.239 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:32:15.240 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:32:15.241 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:32:15.242 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:32:15.242 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:32:15.243 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:32:15.245 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:32:15.245 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:32:15.247 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:32:15.250 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:32:15.250 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:32:15.253 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:32:15.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:32:15.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:32:15.257 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:32:15.258 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:32:15.259 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:32:15.261 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:32:15.262 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:32:16.304 | DEBUG    | chatbot.function_agent:__init__:32 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 20:32:41.720 | DEBUG    | __main__:algorithm_chat:30 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 20:32:41.720 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 20:32:44.403 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:61 - [algorithm_chao_name](单调队列)
2024-07-16 20:32:48.181 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:63 - [algorithm_code from agnet]57

单调队列是一种特殊的队列，它在队列的两端都可以进行出队操作。它通常用于解决滑动窗口类型的问题，比如在一个固定大小的窗口内找最大值或最小值。通过保持队列的递增或递减特性，单调队列可以在O(1)时间内得到窗口内的最大或最小值。
2024-07-16 20:34:46.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:34:46.845 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:34:46.846 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:34:46.847 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:34:46.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:34:46.848 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:34:46.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:34:46.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:34:46.851 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:34:46.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:34:46.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:34:46.853 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:34:46.854 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:34:46.854 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:34:46.855 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:34:46.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:34:46.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:34:46.857 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:34:46.859 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:34:46.859 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:34:46.860 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:34:46.861 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:34:46.861 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:34:46.862 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:34:46.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:34:46.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:34:46.864 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:34:46.864 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:34:46.865 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:34:46.865 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:34:46.866 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:34:46.867 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:34:46.867 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:34:46.869 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:34:46.869 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:34:46.869 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:34:46.869 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:34:46.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:34:46.870 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:34:46.871 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:34:46.871 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:34:46.872 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:34:46.873 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:34:46.873 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:34:46.874 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:34:46.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:34:46.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:34:46.876 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:34:46.876 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:34:46.877 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:34:46.877 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:34:46.878 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:34:46.879 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:34:46.879 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:34:46.880 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:34:46.880 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:34:46.881 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:34:46.882 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:34:46.882 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:34:46.884 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:34:46.885 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:34:46.885 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:34:46.886 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:34:46.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:34:46.888 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:34:46.889 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:34:46.890 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:34:46.890 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:34:46.892 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:34:46.894 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:34:46.894 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:34:46.895 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:34:46.896 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:34:46.896 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:34:46.896 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:34:46.897 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:34:46.897 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:34:46.898 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:34:46.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:34:46.900 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:34:46.901 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:34:46.902 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:34:46.902 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:34:46.903 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:34:46.904 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:34:46.904 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:34:46.905 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:34:46.907 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:34:46.907 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:34:46.908 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:34:46.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:34:46.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:34:46.910 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:34:46.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:34:46.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:34:46.912 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:34:46.913 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:34:46.913 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:34:46.914 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:34:46.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:34:46.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:34:46.917 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:34:46.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:34:46.919 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:34:46.919 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:34:46.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:34:46.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:34:46.922 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:34:46.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:34:46.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:34:46.924 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:34:46.925 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:34:46.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:34:46.927 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:34:46.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:34:46.929 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:34:46.929 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:34:46.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:34:46.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:34:46.932 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:34:46.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:34:46.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:34:46.935 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:34:46.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:34:46.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:34:46.938 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:34:46.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:34:46.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:34:46.942 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:34:46.944 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:34:46.944 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:34:46.946 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:34:46.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:34:46.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:34:46.949 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:34:46.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:34:46.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:34:46.952 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:34:46.954 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:34:46.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:34:46.956 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:34:46.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:34:46.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:34:46.959 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:34:46.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:34:46.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:34:46.964 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:34:46.967 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:34:46.967 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:34:46.971 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:34:46.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:34:46.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:34:46.979 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:34:46.983 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:34:46.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:34:46.986 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:34:46.989 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:34:46.989 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:34:46.991 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:34:46.993 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:34:46.993 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:34:46.994 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:34:46.996 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:34:46.996 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:34:46.998 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:34:46.999 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:34:46.999 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:34:47.000 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:34:47.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:34:47.001 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:34:47.001 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:34:47.002 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:34:47.003 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:34:47.003 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:34:47.004 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:34:47.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:34:47.006 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:34:47.006 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:34:47.006 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:34:47.008 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:34:47.010 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:34:47.010 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:34:47.011 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:34:47.012 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:34:47.013 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:34:47.014 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:34:47.015 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:34:47.015 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:34:47.018 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:34:47.021 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:34:47.021 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:34:47.024 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:34:47.027 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:34:47.027 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:34:47.028 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:34:47.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:34:47.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:34:47.031 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:34:47.032 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:34:48.074 | DEBUG    | chatbot.function_agent:__init__:33 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的id整数作为tool的输入
最后输出数据库中查找的代码
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 20:35:19.718 | DEBUG    | __main__:algorithm_chat:30 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 20:35:19.719 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 20:35:22.698 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:61 - [algorithm_chao_name](单调队列)
2024-07-16 20:35:27.070 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:63 - [algorithm_code from agnet]根据你提供的关键词，我选择了“单调队列”作为最相关的算法。在数据库中查找单调队列相关代码的SQL语句可以是：

```sql
SELECT code FROM algorithms WHERE id = 57;
```

这里的`code`是假设数据库中存储算法代码的字段名，`algorithms`是假设存储算法的表名，`id`是算法对应的关键词编号，而`57`就是“单调队列”对应的编号。当然，具体的字段名和表名需要根据实际的数据库设计来确定。
2024-07-16 20:37:56.012 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 20:37:56.013 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:37:56.014 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 20:37:56.016 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 20:37:56.016 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:37:56.017 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 20:37:56.018 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 20:37:56.019 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:37:56.020 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 20:37:56.021 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 20:37:56.021 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:37:56.022 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 20:37:56.023 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 20:37:56.024 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:37:56.025 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 20:37:56.026 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 20:37:56.026 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:37:56.027 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:37:56.028 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 20:37:56.028 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:37:56.029 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 20:37:56.030 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 20:37:56.030 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:37:56.031 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 20:37:56.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 20:37:56.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:37:56.033 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:37:56.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 20:37:56.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:37:56.035 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 20:37:56.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 20:37:56.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:37:56.037 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 20:37:56.038 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 20:37:56.038 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:37:56.039 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 20:37:56.039 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 20:37:56.039 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:37:56.040 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 20:37:56.041 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 20:37:56.041 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:37:56.042 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 20:37:56.042 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 20:37:56.042 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:37:56.043 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 20:37:56.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 20:37:56.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:37:56.045 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 20:37:56.046 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 20:37:56.046 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:37:56.047 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 20:37:56.048 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 20:37:56.048 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:37:56.049 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 20:37:56.049 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 20:37:56.050 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:37:56.050 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 20:37:56.051 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 20:37:56.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:37:56.053 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 20:37:56.054 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 20:37:56.054 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:37:56.055 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 20:37:56.056 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 20:37:56.056 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:37:56.058 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 20:37:56.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 20:37:56.060 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:37:56.061 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 20:37:56.063 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 20:37:56.063 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:37:56.064 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 20:37:56.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 20:37:56.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:37:56.065 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 20:37:56.066 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 20:37:56.066 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:37:56.067 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 20:37:56.068 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 20:37:56.069 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:37:56.070 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 20:37:56.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 20:37:56.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:37:56.072 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 20:37:56.073 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 20:37:56.074 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:37:56.075 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 20:37:56.076 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 20:37:56.077 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:37:56.077 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 20:37:56.078 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 20:37:56.079 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:37:56.079 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 20:37:56.080 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 20:37:56.081 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:37:56.082 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 20:37:56.083 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 20:37:56.083 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:37:56.083 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 20:37:56.084 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 20:37:56.084 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:37:56.086 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 20:37:56.087 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 20:37:56.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:37:56.089 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 20:37:56.090 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 20:37:56.090 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:37:56.091 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 20:37:56.092 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 20:37:56.093 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:37:56.095 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 20:37:56.096 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 20:37:56.097 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:37:56.097 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 20:37:56.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 20:37:56.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:37:56.100 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 20:37:56.101 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 20:37:56.102 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:37:56.104 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 20:37:56.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 20:37:56.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:37:56.106 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 20:37:56.108 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 20:37:56.108 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:37:56.110 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 20:37:56.111 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 20:37:56.111 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:37:56.112 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 20:37:56.114 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 20:37:56.115 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:37:56.116 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 20:37:56.116 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 20:37:56.118 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:37:56.119 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 20:37:56.120 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 20:37:56.120 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:37:56.122 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 20:37:56.123 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 20:37:56.124 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:37:56.125 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 20:37:56.126 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 20:37:56.126 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:37:56.129 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 20:37:56.130 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 20:37:56.131 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:37:56.132 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 20:37:56.135 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 20:37:56.135 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:37:56.138 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 20:37:56.140 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 20:37:56.141 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:37:56.143 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 20:37:56.146 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 20:37:56.146 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:37:56.147 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 20:37:56.148 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 20:37:56.148 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:37:56.150 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 20:37:56.152 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 20:37:56.153 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:37:56.154 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 20:37:56.154 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 20:37:56.155 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:37:56.156 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 20:37:56.158 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 20:37:56.158 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:37:56.159 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 20:37:56.159 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 20:37:56.160 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:37:56.160 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 20:37:56.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 20:37:56.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:37:56.162 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 20:37:56.162 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 20:37:56.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:37:56.164 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 20:37:56.165 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 20:37:56.165 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:37:56.166 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 20:37:56.167 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 20:37:56.167 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:37:56.168 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 20:37:56.169 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 20:37:56.170 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:37:56.171 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 20:37:56.172 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 20:37:56.173 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:37:56.175 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 20:37:56.178 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 20:37:56.178 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:37:56.180 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 20:37:56.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 20:37:56.184 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:37:56.185 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 20:37:56.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 20:37:56.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:37:56.187 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 20:37:56.189 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 20:37:57.227 | DEBUG    | chatbot.function_agent:__init__:32 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
算法名以及id号:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 20:38:24.555 | DEBUG    | __main__:algorithm_chat:30 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 20:38:24.556 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-16 20:38:27.218 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:60 - [algorithm_chao_name](单调队列)
2024-07-16 20:38:30.554 | DEBUG    | chatbot.function_agent:GetAlgorithmCode:62 - [algorithm_code from agnet]请您提供关于单调队列算法的描述或问题，我将根据您的需求给出相应的解释或解答。单调队列是一种重要的数据结构，通常用于解决滑动窗口类型的问题，它可以维护队列中元素的单调性（递增或递减），以便快速获取窗口内的最大值或最小值。
2024-07-16 21:52:21.683 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 21:52:21.684 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 21:52:21.685 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 21:52:21.687 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 21:52:21.687 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 21:52:21.688 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 21:52:21.688 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 21:52:21.689 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 21:52:21.690 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 21:52:21.691 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 21:52:21.691 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 21:52:21.692 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 21:52:21.693 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 21:52:21.694 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 21:52:21.695 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 21:52:21.695 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 21:52:21.696 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:52:21.696 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:52:21.698 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 21:52:21.698 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:52:21.699 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:52:21.700 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 21:52:21.700 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 21:52:21.701 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 21:52:21.702 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 21:52:21.702 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:52:21.703 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:52:21.704 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 21:52:21.704 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 21:52:21.705 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 21:52:21.706 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 21:52:21.706 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:52:21.707 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:52:21.707 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 21:52:21.709 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 21:52:21.709 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 21:52:21.710 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 21:52:21.710 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 21:52:21.711 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 21:52:21.712 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 21:52:21.712 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 21:52:21.712 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 21:52:21.713 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 21:52:21.714 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 21:52:21.715 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 21:52:21.716 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 21:52:21.716 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 21:52:21.716 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 21:52:21.717 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 21:52:21.717 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 21:52:21.718 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 21:52:21.719 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 21:52:21.720 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 21:52:21.720 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 21:52:21.721 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 21:52:21.721 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 21:52:21.722 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 21:52:21.723 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 21:52:21.723 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 21:52:21.724 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 21:52:21.725 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 21:52:21.725 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 21:52:21.726 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 21:52:21.727 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 21:52:21.727 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 21:52:21.729 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 21:52:21.731 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 21:52:21.731 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 21:52:21.733 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 21:52:21.735 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 21:52:21.736 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 21:52:21.737 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 21:52:21.738 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 21:52:21.738 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 21:52:21.738 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 21:52:21.739 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 21:52:21.739 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 21:52:21.740 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 21:52:21.742 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 21:52:21.742 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 21:52:21.743 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 21:52:21.745 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 21:52:21.745 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 21:52:21.746 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 21:52:21.747 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 21:52:21.747 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 21:52:21.748 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 21:52:21.750 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 21:52:21.750 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 21:52:21.751 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 21:52:21.752 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 21:52:21.753 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 21:52:21.753 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 21:52:21.754 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 21:52:21.755 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 21:52:21.755 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 21:52:21.756 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 21:52:21.757 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 21:52:21.757 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 21:52:21.758 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 21:52:21.759 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 21:52:21.760 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 21:52:21.762 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 21:52:21.762 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 21:52:21.763 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 21:52:21.764 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 21:52:21.764 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 21:52:21.765 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 21:52:21.766 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 21:52:21.766 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 21:52:21.767 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 21:52:21.771 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 21:52:21.771 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 21:52:21.772 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 21:52:21.773 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 21:52:21.773 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 21:52:21.775 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 21:52:21.776 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 21:52:21.776 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 21:52:21.778 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 21:52:21.779 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 21:52:21.780 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 21:52:21.781 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 21:52:21.783 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 21:52:21.783 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 21:52:21.784 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 21:52:21.786 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 21:52:21.786 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 21:52:21.788 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 21:52:21.790 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 21:52:21.790 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 21:52:21.791 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 21:52:21.792 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 21:52:21.793 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 21:52:21.794 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 21:52:21.795 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 21:52:21.795 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 21:52:21.797 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 21:52:21.799 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 21:52:21.799 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 21:52:21.800 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 21:52:21.801 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 21:52:21.802 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 21:52:21.804 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 21:52:21.806 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 21:52:21.806 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 21:52:21.808 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 21:52:21.811 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 21:52:21.811 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 21:52:21.813 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 21:52:21.816 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 21:52:21.817 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 21:52:21.819 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 21:52:21.822 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 21:52:21.822 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 21:52:21.824 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 21:52:21.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 21:52:21.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 21:52:21.827 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 21:52:21.828 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 21:52:21.829 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 21:52:21.829 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 21:52:21.831 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 21:52:21.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 21:52:21.833 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 21:52:21.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 21:52:21.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 21:52:21.834 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 21:52:21.835 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 21:52:21.836 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 21:52:21.836 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 21:52:21.837 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 21:52:21.838 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 21:52:21.839 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 21:52:21.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 21:52:21.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 21:52:21.841 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 21:52:21.841 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 21:52:21.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 21:52:21.843 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 21:52:21.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 21:52:21.845 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 21:52:21.846 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 21:52:21.846 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 21:52:21.847 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 21:52:21.848 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 21:52:21.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 21:52:21.850 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 21:52:21.853 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 21:52:21.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 21:52:21.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 21:52:21.858 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 21:52:21.862 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 21:52:21.862 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 21:52:21.863 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 21:52:21.864 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 21:52:21.865 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 21:52:21.866 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 21:52:21.867 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 21:52:22.929 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 21:53:06.810 | DEBUG    | __main__:algorithm_chat:27 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 21:53:06.810 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 21:53:11.516 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](单调队列)
2024-07-16 21:53:13.786 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]{'input': '(单调队列)', 'text': '57\n\n单调队列是一种特殊的队列数据结构，它在队列的两端都可以进行出队操作。它通常用于解决滑动窗口类型的问题，可以高效地找到滑动窗口内的最大值或最小值。'}
2024-07-16 21:55:01.284 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 21:55:01.285 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 21:55:01.286 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 21:55:01.287 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 21:55:01.288 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 21:55:01.289 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 21:55:01.290 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 21:55:01.290 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 21:55:01.292 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 21:55:01.293 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 21:55:01.293 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 21:55:01.294 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 21:55:01.295 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 21:55:01.296 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 21:55:01.297 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 21:55:01.298 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 21:55:01.299 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:55:01.300 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:55:01.301 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 21:55:01.301 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:55:01.302 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:55:01.304 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 21:55:01.304 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 21:55:01.306 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 21:55:01.307 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 21:55:01.307 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:55:01.308 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:55:01.309 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 21:55:01.310 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 21:55:01.311 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 21:55:01.312 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 21:55:01.313 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:55:01.314 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:55:01.315 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 21:55:01.315 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 21:55:01.316 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 21:55:01.316 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 21:55:01.317 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 21:55:01.317 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 21:55:01.318 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 21:55:01.319 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 21:55:01.320 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 21:55:01.320 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 21:55:01.320 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 21:55:01.321 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 21:55:01.322 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 21:55:01.322 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 21:55:01.323 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 21:55:01.325 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 21:55:01.325 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 21:55:01.326 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 21:55:01.327 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 21:55:01.327 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 21:55:01.328 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 21:55:01.329 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 21:55:01.329 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 21:55:01.329 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 21:55:01.331 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 21:55:01.331 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 21:55:01.332 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 21:55:01.334 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 21:55:01.334 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 21:55:01.336 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 21:55:01.336 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 21:55:01.336 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 21:55:01.338 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 21:55:01.341 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 21:55:01.341 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 21:55:01.343 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 21:55:01.345 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 21:55:01.346 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 21:55:01.347 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 21:55:01.349 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 21:55:01.350 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 21:55:01.350 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 21:55:01.351 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 21:55:01.351 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 21:55:01.353 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 21:55:01.354 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 21:55:01.355 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 21:55:01.356 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 21:55:01.357 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 21:55:01.358 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 21:55:01.358 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 21:55:01.360 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 21:55:01.360 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 21:55:01.362 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 21:55:01.364 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 21:55:01.364 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 21:55:01.365 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 21:55:01.367 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 21:55:01.367 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 21:55:01.368 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 21:55:01.369 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 21:55:01.370 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 21:55:01.370 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 21:55:01.371 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 21:55:01.372 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 21:55:01.373 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 21:55:01.374 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 21:55:01.375 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 21:55:01.376 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 21:55:01.378 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 21:55:01.378 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 21:55:01.379 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 21:55:01.380 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 21:55:01.381 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 21:55:01.382 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 21:55:01.383 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 21:55:01.383 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 21:55:01.384 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 21:55:01.386 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 21:55:01.386 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 21:55:01.387 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 21:55:01.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 21:55:01.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 21:55:01.390 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 21:55:01.392 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 21:55:01.392 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 21:55:01.394 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 21:55:01.395 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 21:55:01.395 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 21:55:01.397 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 21:55:01.398 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 21:55:01.399 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 21:55:01.400 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 21:55:01.402 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 21:55:01.402 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 21:55:01.403 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 21:55:01.405 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 21:55:01.405 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 21:55:01.406 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 21:55:01.407 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 21:55:01.407 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 21:55:01.409 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 21:55:01.410 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 21:55:01.410 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 21:55:01.412 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 21:55:01.413 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 21:55:01.414 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 21:55:01.415 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 21:55:01.416 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 21:55:01.417 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 21:55:01.418 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 21:55:01.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 21:55:01.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 21:55:01.423 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 21:55:01.425 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 21:55:01.425 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 21:55:01.427 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 21:55:01.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 21:55:01.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 21:55:01.433 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 21:55:01.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 21:55:01.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 21:55:01.437 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 21:55:01.439 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 21:55:01.439 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 21:55:01.440 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 21:55:01.442 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 21:55:01.442 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 21:55:01.443 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 21:55:01.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 21:55:01.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 21:55:01.445 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 21:55:01.446 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 21:55:01.446 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 21:55:01.447 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 21:55:01.448 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 21:55:01.448 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 21:55:01.449 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 21:55:01.450 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 21:55:01.450 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 21:55:01.451 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 21:55:01.452 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 21:55:01.452 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 21:55:01.453 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 21:55:01.454 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 21:55:01.455 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 21:55:01.456 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 21:55:01.457 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 21:55:01.457 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 21:55:01.458 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 21:55:01.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 21:55:01.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 21:55:01.460 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 21:55:01.461 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 21:55:01.462 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 21:55:01.465 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 21:55:01.468 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 21:55:01.469 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 21:55:01.472 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 21:55:01.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 21:55:01.476 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 21:55:01.476 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 21:55:01.478 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 21:55:01.478 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 21:55:01.479 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 21:55:01.480 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 21:55:02.546 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:(仅输出序号)
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 21:55:30.406 | DEBUG    | __main__:algorithm_chat:27 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 21:55:30.406 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 21:55:32.949 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](单调队列)
2024-07-16 21:55:36.321 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]57

单调队列是一种特殊的队列，用于解决滑动窗口类型的问题，能够高效地维护序列中的单调性（递增或递减）。在算法竞赛中，单调队列常用于处理最大/最小值问题，例如在一个固定大小的窗口内找到最大值或最小值。
2024-07-16 21:57:05.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 21:57:05.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 21:57:05.422 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 21:57:05.423 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 21:57:05.424 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 21:57:05.425 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 21:57:05.426 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 21:57:05.426 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 21:57:05.428 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 21:57:05.429 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 21:57:05.429 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 21:57:05.430 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 21:57:05.431 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 21:57:05.431 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 21:57:05.432 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 21:57:05.433 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 21:57:05.433 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:57:05.434 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:57:05.435 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 21:57:05.435 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:57:05.436 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 21:57:05.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 21:57:05.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 21:57:05.438 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 21:57:05.440 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 21:57:05.440 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:57:05.441 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:57:05.442 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 21:57:05.442 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 21:57:05.443 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 21:57:05.443 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 21:57:05.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:57:05.444 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 21:57:05.445 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 21:57:05.445 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 21:57:05.446 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 21:57:05.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 21:57:05.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 21:57:05.448 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 21:57:05.448 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 21:57:05.448 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 21:57:05.449 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 21:57:05.449 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 21:57:05.450 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 21:57:05.450 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 21:57:05.451 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 21:57:05.452 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 21:57:05.452 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 21:57:05.453 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 21:57:05.453 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 21:57:05.455 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 21:57:05.455 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 21:57:05.455 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 21:57:05.456 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 21:57:05.456 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 21:57:05.456 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 21:57:05.458 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 21:57:05.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 21:57:05.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 21:57:05.460 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 21:57:05.461 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 21:57:05.461 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 21:57:05.462 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 21:57:05.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 21:57:05.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 21:57:05.464 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 21:57:05.465 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 21:57:05.465 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 21:57:05.468 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 21:57:05.470 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 21:57:05.470 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 21:57:05.471 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 21:57:05.472 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 21:57:05.472 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 21:57:05.472 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 21:57:05.473 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 21:57:05.473 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 21:57:05.474 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 21:57:05.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 21:57:05.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 21:57:05.476 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 21:57:05.478 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 21:57:05.478 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 21:57:05.479 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 21:57:05.480 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 21:57:05.480 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 21:57:05.482 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 21:57:05.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 21:57:05.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 21:57:05.484 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 21:57:05.485 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 21:57:05.485 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 21:57:05.486 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 21:57:05.487 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 21:57:05.487 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 21:57:05.488 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 21:57:05.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 21:57:05.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 21:57:05.490 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 21:57:05.491 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 21:57:05.491 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 21:57:05.493 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 21:57:05.495 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 21:57:05.495 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 21:57:05.496 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 21:57:05.497 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 21:57:05.497 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 21:57:05.498 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 21:57:05.499 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 21:57:05.499 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 21:57:05.501 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 21:57:05.503 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 21:57:05.503 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 21:57:05.504 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 21:57:05.505 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 21:57:05.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 21:57:05.507 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 21:57:05.509 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 21:57:05.509 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 21:57:05.510 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 21:57:05.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 21:57:05.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 21:57:05.513 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 21:57:05.514 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 21:57:05.514 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 21:57:05.517 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 21:57:05.519 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 21:57:05.519 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 21:57:05.520 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 21:57:05.521 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 21:57:05.521 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 21:57:05.523 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 21:57:05.524 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 21:57:05.524 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 21:57:05.525 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 21:57:05.528 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 21:57:05.528 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 21:57:05.530 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 21:57:05.532 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 21:57:05.532 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 21:57:05.533 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 21:57:05.534 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 21:57:05.534 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 21:57:05.537 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 21:57:05.538 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 21:57:05.539 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 21:57:05.540 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 21:57:05.542 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 21:57:05.543 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 21:57:05.545 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 21:57:05.548 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 21:57:05.548 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 21:57:05.551 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 21:57:05.554 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 21:57:05.554 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 21:57:05.555 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 21:57:05.556 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 21:57:05.557 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 21:57:05.558 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 21:57:05.559 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 21:57:05.559 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 21:57:05.560 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 21:57:05.561 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 21:57:05.562 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 21:57:05.563 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 21:57:05.564 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 21:57:05.564 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 21:57:05.565 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 21:57:05.565 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 21:57:05.566 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 21:57:05.566 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 21:57:05.568 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 21:57:05.568 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 21:57:05.569 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 21:57:05.570 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 21:57:05.570 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 21:57:05.571 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 21:57:05.572 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 21:57:05.573 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 21:57:05.573 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 21:57:05.574 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 21:57:05.575 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 21:57:05.575 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 21:57:05.576 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 21:57:05.576 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 21:57:05.577 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 21:57:05.579 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 21:57:05.579 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 21:57:05.581 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 21:57:05.584 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 21:57:05.584 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 21:57:05.588 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 21:57:05.591 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 21:57:05.591 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 21:57:05.592 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 21:57:05.593 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 21:57:05.593 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 21:57:05.594 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 21:57:05.596 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 21:57:06.685 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 21:57:35.655 | DEBUG    | __main__:algorithm_chat:27 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 21:57:35.655 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 21:57:38.358 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](单调队列)
2024-07-16 21:57:39.584 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]57
2024-07-16 21:58:51.462 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量，其中用到了回溯时间
2024-07-16 21:58:51.463 | DEBUG    | __main__:algorithm_chat:28 - [history][['一种用于优化滑动窗口问题的数据结构', None]]
2024-07-16 21:58:54.232 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](Tarjan算法)
2024-07-16 21:58:55.326 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]3
2024-07-16 22:00:49.086 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量
2024-07-16 22:00:49.086 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:00:51.989 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](Tarjan算法)
2024-07-16 22:00:52.944 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]3
2024-07-16 22:03:21.358 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:03:21.359 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:03:21.360 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:03:21.361 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:03:21.361 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:03:21.362 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:03:21.363 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:03:21.363 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:03:21.365 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:03:21.366 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:03:21.367 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:03:21.368 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:03:21.369 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:03:21.370 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:03:21.371 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:03:21.372 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:03:21.372 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:03:21.373 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:03:21.374 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:03:21.374 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:03:21.375 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:03:21.376 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:03:21.376 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:03:21.377 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:03:21.378 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:03:21.379 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:03:21.380 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:03:21.381 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:03:21.381 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:03:21.382 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:03:21.382 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:03:21.383 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:03:21.383 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:03:21.384 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:03:21.384 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:03:21.385 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:03:21.386 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:03:21.386 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:03:21.387 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:03:21.388 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:03:21.388 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:03:21.389 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:03:21.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:03:21.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:03:21.390 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:03:21.391 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:03:21.391 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:03:21.392 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:03:21.393 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:03:21.393 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:03:21.394 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:03:21.395 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:03:21.395 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:03:21.396 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:03:21.397 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:03:21.397 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:03:21.397 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:03:21.398 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:03:21.399 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:03:21.400 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:03:21.401 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:03:21.401 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:03:21.402 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:03:21.402 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:03:21.402 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:03:21.403 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:03:21.405 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:03:21.405 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:03:21.407 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:03:21.409 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:03:21.410 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:03:21.410 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:03:21.411 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:03:21.412 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:03:21.412 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:03:21.413 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:03:21.413 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:03:21.414 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:03:21.415 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:03:21.416 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:03:21.417 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:03:21.418 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:03:21.418 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:03:21.419 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:03:21.421 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:03:21.421 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:03:21.422 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:03:21.423 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:03:21.424 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:03:21.425 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:03:21.426 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:03:21.426 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:03:21.428 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:03:21.428 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:03:21.429 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:03:21.429 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:03:21.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:03:21.430 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:03:21.431 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:03:21.432 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:03:21.432 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:03:21.435 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:03:21.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:03:21.437 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:03:21.437 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:03:21.438 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:03:21.438 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:03:21.439 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:03:21.440 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:03:21.441 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:03:21.442 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:03:21.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:03:21.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:03:21.446 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:03:21.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:03:21.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:03:21.449 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:03:21.450 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:03:21.450 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:03:21.452 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:03:21.453 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:03:21.453 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:03:21.454 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:03:21.456 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:03:21.457 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:03:21.458 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:03:21.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:03:21.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:03:21.461 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:03:21.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:03:21.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:03:21.464 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:03:21.465 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:03:21.466 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:03:21.467 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:03:21.468 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:03:21.469 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:03:21.471 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:03:21.472 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:03:21.472 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:03:21.474 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:03:21.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:03:21.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:03:21.477 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:03:21.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:03:21.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:03:21.481 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:03:21.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:03:21.485 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:03:21.486 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:03:21.488 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:03:21.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:03:21.492 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:03:21.495 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:03:21.496 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:03:21.497 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:03:21.499 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:03:21.499 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:03:21.500 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:03:21.501 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:03:21.502 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:03:21.502 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:03:21.503 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:03:21.504 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:03:21.505 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:03:21.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:03:21.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:03:21.507 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:03:21.508 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:03:21.508 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:03:21.509 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:03:21.510 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:03:21.510 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:03:21.511 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:03:21.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:03:21.513 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:03:21.513 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:03:21.515 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:03:21.516 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:03:21.517 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:03:21.518 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:03:21.519 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:03:21.520 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:03:21.521 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:03:21.521 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:03:21.522 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:03:21.523 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:03:21.524 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:03:21.527 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:03:21.529 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:03:21.530 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:03:21.532 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:03:21.535 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:03:21.535 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:03:21.536 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:03:21.537 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:03:21.538 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:03:21.540 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:03:21.541 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:03:22.590 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 22:03:46.252 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量
2024-07-16 22:03:46.253 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:05:12.815 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:05:12.816 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:05:12.818 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:05:12.820 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:05:12.820 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:05:12.821 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:05:12.822 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:05:12.822 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:05:12.823 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:05:12.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:05:12.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:05:12.828 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:05:12.830 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:05:12.830 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:05:12.831 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:05:12.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:05:12.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:05:12.833 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:05:12.835 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:05:12.835 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:05:12.836 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:05:12.837 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:05:12.838 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:05:12.838 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:05:12.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:05:12.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:05:12.841 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:05:12.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:05:12.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:05:12.843 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:05:12.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:05:12.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:05:12.845 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:05:12.846 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:05:12.846 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:05:12.847 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:05:12.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:05:12.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:05:12.849 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:05:12.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:05:12.850 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:05:12.850 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:05:12.851 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:05:12.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:05:12.853 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:05:12.853 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:05:12.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:05:12.855 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:05:12.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:05:12.857 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:05:12.858 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:05:12.858 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:05:12.859 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:05:12.859 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:05:12.860 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:05:12.861 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:05:12.862 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:05:12.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:05:12.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:05:12.864 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:05:12.865 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:05:12.866 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:05:12.868 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:05:12.869 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:05:12.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:05:12.873 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:05:12.877 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:05:12.878 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:05:12.881 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:05:12.884 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:05:12.884 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:05:12.885 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:05:12.886 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:05:12.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:05:12.887 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:05:12.888 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:05:12.888 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:05:12.889 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:05:12.890 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:05:12.891 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:05:12.892 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:05:12.893 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:05:12.893 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:05:12.894 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:05:12.895 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:05:12.895 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:05:12.897 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:05:12.898 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:05:12.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:05:12.900 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:05:12.901 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:05:12.901 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:05:12.901 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:05:12.902 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:05:12.903 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:05:12.904 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:05:12.905 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:05:12.905 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:05:12.905 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:05:12.907 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:05:12.907 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:05:12.909 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:05:12.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:05:12.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:05:12.911 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:05:12.912 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:05:12.912 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:05:12.913 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:05:12.914 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:05:12.914 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:05:12.916 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:05:12.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:05:12.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:05:12.919 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:05:12.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:05:12.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:05:12.921 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:05:12.924 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:05:12.924 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:05:12.925 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:05:12.927 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:05:12.927 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:05:12.928 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:05:12.929 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:05:12.930 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:05:12.931 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:05:12.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:05:12.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:05:12.935 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:05:12.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:05:12.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:05:12.938 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:05:12.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:05:12.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:05:12.941 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:05:12.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:05:12.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:05:12.943 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:05:12.946 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:05:12.946 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:05:12.947 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:05:12.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:05:12.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:05:12.951 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:05:12.953 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:05:12.953 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:05:12.954 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:05:12.956 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:05:12.956 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:05:12.959 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:05:12.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:05:12.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:05:12.963 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:05:12.967 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:05:12.967 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:05:12.968 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:05:12.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:05:12.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:05:12.971 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:05:12.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:05:12.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:05:12.975 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:05:12.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:05:12.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:05:12.977 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:05:12.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:05:12.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:05:12.978 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:05:12.979 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:05:12.979 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:05:12.980 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:05:12.981 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:05:12.981 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:05:12.981 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:05:12.983 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:05:12.983 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:05:12.984 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:05:12.985 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:05:12.985 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:05:12.986 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:05:12.988 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:05:12.988 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:05:12.989 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:05:12.990 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:05:12.990 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:05:12.991 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:05:12.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:05:12.994 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:05:12.997 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:05:12.999 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:05:13.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:05:13.002 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:05:13.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:05:13.006 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:05:13.007 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:05:13.008 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:05:13.009 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:05:13.010 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:05:13.011 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:05:14.077 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 22:05:42.091 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量
2024-07-16 22:05:42.092 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:05:44.812 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \nTarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。\n初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。\nDFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。\n识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。\n\n应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。\n\n时间复杂度:\n算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。\n该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。\n\n[回答]\n(有向图的强连通分量Tarjan算法)')]
2024-07-16 22:05:44.813 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](Tarjan算法)
2024-07-16 22:05:45.866 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]3
2024-07-16 22:07:00.741 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:07:00.742 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:07:00.742 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:07:00.745 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:07:00.745 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:07:00.746 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:07:00.747 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:07:00.748 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:07:00.749 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:07:00.750 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:07:00.750 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:07:00.752 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:07:00.753 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:07:00.753 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:07:00.754 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:07:00.755 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:07:00.755 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:07:00.756 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:07:00.757 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:07:00.758 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:07:00.758 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:07:00.760 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:07:00.760 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:07:00.762 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:07:00.763 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:07:00.763 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:07:00.763 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:07:00.764 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:07:00.764 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:07:00.765 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:07:00.766 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:07:00.767 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:07:00.768 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:07:00.769 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:07:00.770 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:07:00.770 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:07:00.770 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:07:00.772 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:07:00.772 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:07:00.773 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:07:00.774 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:07:00.774 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:07:00.775 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:07:00.775 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:07:00.777 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:07:00.778 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:07:00.778 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:07:00.779 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:07:00.779 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:07:00.780 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:07:00.781 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:07:00.782 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:07:00.782 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:07:00.784 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:07:00.785 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:07:00.785 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:07:00.786 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:07:00.787 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:07:00.788 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:07:00.789 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:07:00.790 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:07:00.790 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:07:00.791 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:07:00.793 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:07:00.793 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:07:00.794 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:07:00.796 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:07:00.797 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:07:00.799 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:07:00.801 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:07:00.801 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:07:00.803 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:07:00.804 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:07:00.804 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:07:00.805 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:07:00.806 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:07:00.806 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:07:00.807 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:07:00.808 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:07:00.809 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:07:00.810 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:07:00.812 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:07:00.812 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:07:00.814 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:07:00.815 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:07:00.815 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:07:00.817 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:07:00.819 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:07:00.819 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:07:00.820 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:07:00.822 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:07:00.822 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:07:00.823 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:07:00.824 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:07:00.825 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:07:00.826 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:07:00.827 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:07:00.827 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:07:00.828 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:07:00.830 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:07:00.830 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:07:00.833 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:07:00.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:07:00.835 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:07:00.835 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:07:00.836 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:07:00.837 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:07:00.838 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:07:00.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:07:00.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:07:00.842 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:07:00.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:07:00.845 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:07:00.847 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:07:00.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:07:00.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:07:00.850 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:07:00.851 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:07:00.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:07:00.854 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:07:00.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:07:00.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:07:00.857 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:07:00.859 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:07:00.860 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:07:00.862 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:07:00.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:07:00.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:07:00.865 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:07:00.867 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:07:00.868 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:07:00.869 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:07:00.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:07:00.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:07:00.873 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:07:00.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:07:00.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:07:00.877 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:07:00.879 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:07:00.880 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:07:00.881 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:07:00.882 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:07:00.883 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:07:00.884 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:07:00.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:07:00.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:07:00.889 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:07:00.892 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:07:00.892 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:07:00.894 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:07:00.896 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:07:00.897 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:07:00.900 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:07:00.903 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:07:00.904 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:07:00.905 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:07:00.907 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:07:00.907 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:07:00.908 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:07:00.910 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:07:00.910 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:07:00.910 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:07:00.913 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:07:00.913 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:07:00.914 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:07:00.916 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:07:00.916 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:07:00.916 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:07:00.917 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:07:00.917 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:07:00.918 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:07:00.919 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:07:00.919 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:07:00.920 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:07:00.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:07:00.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:07:00.922 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:07:00.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:07:00.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:07:00.925 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:07:00.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:07:00.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:07:00.927 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:07:00.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:07:00.929 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:07:00.930 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:07:00.930 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:07:00.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:07:00.934 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:07:00.938 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:07:00.938 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:07:00.940 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:07:00.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:07:00.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:07:00.944 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:07:00.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:07:00.946 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:07:00.947 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:07:00.949 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:07:02.031 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 22:07:31.337 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量
2024-07-16 22:07:31.338 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:07:34.534 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \nTarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。\n初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。\nDFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。\n识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。\n\n应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。\n\n时间复杂度:\n算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。\n该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。\n\n[回答]\n(有向图的强连通分量)')]
2024-07-16 22:07:34.535 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name]")中的内容作为输出，根据您提供的检索内容，我的输出是：

有向图的强连通分量
2024-07-16 22:07:35.794 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]1
2024-07-16 22:08:38.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:08:38.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:08:38.922 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:08:38.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:08:38.924 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:08:38.925 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:08:38.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:08:38.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:08:38.927 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:08:38.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:08:38.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:08:38.929 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:08:38.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:08:38.932 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:08:38.932 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:08:38.933 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:08:38.933 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:08:38.934 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:08:38.935 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:08:38.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:08:38.937 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:08:38.938 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:08:38.938 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:08:38.939 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:08:38.941 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:08:38.941 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:08:38.942 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:08:38.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:08:38.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:08:38.943 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:08:38.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:08:38.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:08:38.946 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:08:38.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:08:38.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:08:38.948 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:08:38.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:08:38.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:08:38.949 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:08:38.950 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:08:38.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:08:38.951 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:08:38.952 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:08:38.952 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:08:38.953 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:08:38.954 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:08:38.954 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:08:38.955 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:08:38.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:08:38.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:08:38.956 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:08:38.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:08:38.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:08:38.958 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:08:38.959 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:08:38.959 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:08:38.959 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:08:38.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:08:38.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:08:38.962 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:08:38.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:08:38.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:08:38.964 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:08:38.964 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:08:38.965 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:08:38.966 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:08:38.968 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:08:38.968 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:08:38.970 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:08:38.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:08:38.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:08:38.973 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:08:38.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:08:38.975 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:08:38.975 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:08:38.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:08:38.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:08:38.977 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:08:38.978 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:08:38.978 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:08:38.979 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:08:38.981 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:08:38.982 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:08:38.982 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:08:38.983 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:08:38.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:08:38.985 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:08:38.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:08:38.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:08:38.988 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:08:38.989 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:08:38.989 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:08:38.990 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:08:38.990 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:08:38.991 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:08:38.991 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:08:38.991 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:08:38.993 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:08:38.993 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:08:38.994 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:08:38.995 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:08:38.997 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:08:38.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:08:38.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:08:38.999 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:08:39.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:08:39.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:08:39.001 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:08:39.002 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:08:39.004 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:08:39.004 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:08:39.006 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:08:39.006 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:08:39.007 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:08:39.009 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:08:39.009 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:08:39.011 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:08:39.012 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:08:39.013 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:08:39.014 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:08:39.016 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:08:39.016 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:08:39.018 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:08:39.019 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:08:39.019 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:08:39.021 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:08:39.023 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:08:39.024 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:08:39.026 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:08:39.028 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:08:39.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:08:39.031 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:08:39.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:08:39.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:08:39.034 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:08:39.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:08:39.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:08:39.038 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:08:39.040 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:08:39.040 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:08:39.042 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:08:39.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:08:39.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:08:39.046 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:08:39.048 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:08:39.048 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:08:39.051 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:08:39.053 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:08:39.053 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:08:39.055 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:08:39.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:08:39.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:08:39.062 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:08:39.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:08:39.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:08:39.066 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:08:39.068 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:08:39.068 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:08:39.070 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:08:39.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:08:39.072 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:08:39.073 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:08:39.074 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:08:39.074 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:08:39.075 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:08:39.076 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:08:39.077 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:08:39.077 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:08:39.078 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:08:39.078 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:08:39.079 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:08:39.080 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:08:39.080 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:08:39.081 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:08:39.081 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:08:39.081 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:08:39.082 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:08:39.083 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:08:39.084 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:08:39.085 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:08:39.086 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:08:39.087 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:08:39.087 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:08:39.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:08:39.088 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:08:39.089 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:08:39.092 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:08:39.092 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:08:39.095 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:08:39.098 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:08:39.098 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:08:39.101 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:08:39.103 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:08:39.104 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:08:39.105 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:08:39.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:08:39.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:08:39.108 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:08:39.109 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:08:40.195 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 22:09:10.291 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量
2024-07-16 22:09:10.292 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:09:15.091 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \nTarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。\n初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。\nDFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。\n识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。\n\n应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。\n\n时间复杂度:\n算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。\n该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。\n\n[回答]\n(有向图的强连通分量)')]
2024-07-16 22:09:15.092 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name]</br>

根据您提供的指示，我的输出为：(有向图的强连通分量)。

这个输出直接来源于您给出的[回答]部分，是对问题中提及的Tarjan算法用于解决的问题的简洁总结。如果您有任何关于有向图的强连通分量或Tarjan算法的具体问题，欢迎继续提问。
2024-07-16 22:09:16.276 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]1
2024-07-16 22:14:07.357 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:14:07.357 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:14:07.359 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:14:07.360 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:14:07.360 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:14:07.361 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:14:07.362 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:14:07.363 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:14:07.363 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:14:07.365 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:14:07.365 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:14:07.366 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:14:07.367 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:14:07.367 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:14:07.368 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:14:07.370 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:14:07.370 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:14:07.371 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:14:07.371 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:14:07.372 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:14:07.373 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:14:07.374 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:14:07.375 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:14:07.375 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:14:07.376 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:14:07.376 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:14:07.377 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:14:07.377 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:14:07.377 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:14:07.378 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:14:07.379 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:14:07.379 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:14:07.380 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:14:07.381 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:14:07.381 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:14:07.381 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:14:07.382 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:14:07.382 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:14:07.383 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:14:07.384 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:14:07.384 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:14:07.384 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:14:07.385 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:14:07.385 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:14:07.386 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:14:07.388 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:14:07.388 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:14:07.388 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:14:07.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:14:07.389 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:14:07.390 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:14:07.391 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:14:07.391 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:14:07.391 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:14:07.392 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:14:07.393 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:14:07.394 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:14:07.395 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:14:07.395 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:14:07.396 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:14:07.396 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:14:07.397 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:14:07.397 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:14:07.399 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:14:07.399 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:14:07.401 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:14:07.402 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:14:07.403 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:14:07.405 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:14:07.407 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:14:07.407 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:14:07.408 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:14:07.408 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:14:07.409 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:14:07.409 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:14:07.410 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:14:07.410 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:14:07.411 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:14:07.411 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:14:07.412 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:14:07.413 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:14:07.415 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:14:07.415 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:14:07.416 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:14:07.417 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:14:07.417 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:14:07.418 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:14:07.420 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:14:07.421 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:14:07.422 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:14:07.423 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:14:07.424 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:14:07.424 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:14:07.425 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:14:07.425 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:14:07.426 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:14:07.427 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:14:07.427 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:14:07.427 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:14:07.428 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:14:07.429 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:14:07.430 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:14:07.431 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:14:07.432 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:14:07.432 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:14:07.433 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:14:07.434 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:14:07.435 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:14:07.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:14:07.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:14:07.438 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:14:07.439 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:14:07.439 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:14:07.440 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:14:07.442 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:14:07.442 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:14:07.443 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:14:07.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:14:07.445 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:14:07.446 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:14:07.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:14:07.448 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:14:07.449 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:14:07.451 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:14:07.451 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:14:07.453 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:14:07.454 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:14:07.455 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:14:07.456 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:14:07.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:14:07.459 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:14:07.460 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:14:07.461 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:14:07.461 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:14:07.462 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:14:07.464 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:14:07.464 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:14:07.466 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:14:07.467 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:14:07.467 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:14:07.468 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:14:07.470 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:14:07.470 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:14:07.472 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:14:07.474 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:14:07.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:14:07.477 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:14:07.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:14:07.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:14:07.481 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:14:07.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:14:07.484 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:14:07.486 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:14:07.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:14:07.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:14:07.491 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:14:07.492 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:14:07.492 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:14:07.493 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:14:07.495 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:14:07.495 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:14:07.496 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:14:07.498 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:14:07.498 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:14:07.499 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:14:07.500 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:14:07.500 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:14:07.501 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:14:07.501 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:14:07.502 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:14:07.502 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:14:07.503 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:14:07.503 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:14:07.504 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:14:07.505 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:14:07.506 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:14:07.506 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:14:07.507 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:14:07.507 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:14:07.508 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:14:07.509 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:14:07.510 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:14:07.511 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:14:07.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:14:07.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:14:07.513 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:14:07.514 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:14:07.515 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:14:07.517 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:14:07.520 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:14:07.521 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:14:07.523 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:14:07.526 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:14:07.526 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:14:07.528 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:14:07.530 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:14:07.530 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:14:07.531 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:14:07.533 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:14:08.590 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 22:14:33.487 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量
2024-07-16 22:14:33.488 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:14:37.964 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \nTarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。\n初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。\nDFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。\n识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。\n\n应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。\n\n时间复杂度:\n算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。\n该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。\n\n[回答]\n(有向图的强连通分量)')]
2024-07-16 22:14:37.965 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name]](有向图的强连通分量)[]

根据您的要求，这是从提供的内容中摘取的输出部分。但似乎在您的指示中缺少了具体的输出要求，如果需要更详细的解释或应用场景的描述，请告知我具体的需求。
2024-07-16 22:14:39.394 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]1
```python
1
```
2024-07-16 22:14:39.395 | ERROR    | chatbot.algorithm_code:GetAlgorithmCode:69 - 知识库中无该算法模板
2024-07-16 22:15:17.566 | DEBUG    | __main__:algorithm_chat:27 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 22:15:17.566 | DEBUG    | __main__:algorithm_chat:28 - [history][['有向图的强连通分量', '知识库中无该算法模板']]
2024-07-16 22:15:20.160 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：\n使用两个指针 hh 和 tt 表示队列的头和尾。\n在每次迭代中，首先移除队列头部超出滑动窗口的元素。\n然后，移除队列尾部不符合条件的元素（例如不再是最优解）。\n将当前元素加入队列。\n\n应用场景: \n常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。\n\n时间复杂度: \n每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。\n\n[回答]\n(单调队列)')]
2024-07-16 22:15:20.161 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](单调队列)
2024-07-16 22:15:21.308 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]57
2024-07-16 22:15:21.308 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:66 - [algorithm code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:16:12.511 | DEBUG    | __main__:algorithm_chat:27 - [message]有向图的强连通分量
2024-07-16 22:16:12.511 | DEBUG    | __main__:algorithm_chat:28 - [history][['有向图的强连通分量', '知识库中无该算法模板'], ['一种用于优化滑动窗口问题的数据结构', '```\nint hh = 0, tt = -1;\nfor (int i = 0; i < n; i ++ )\n{\nwhile (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\nwhile (hh <= tt && check(q[tt], i)) tt -- ;\nq[ ++ tt] = i;\n}\n```']]
2024-07-16 22:16:18.129 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \nTarjan 算法用于查找有向图的强连通分量（SCC）。算法的核心是通过深度优先搜索（DFS）跟踪节点的访问顺序和最小可回溯到的访问顺序，以识别强连通分量。\n初始化: 使用 dfn 和 low 数组来记录每个节点的访问时间和最低可回溯的时间。\nDFS 遍历: 在遍历中，当发现未访问的节点时，递归访问该节点，并更新 low 值。如果发现已经在栈中的节点，则更新当前节点的 low 值。\n识别强连通分量: 当 dfn[u] == low[u] 时，表示找到了一个强连通分量，弹出栈中的节点直到当前节点。\n\n应用场景: 常用于网络分析、社交网络、编译器中的依赖分析、图形处理等领域。\n\n时间复杂度:\n算法的整体时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数，适合处理大规模图。\n该算法有效地解决了强连通分量的问题，适合各种图形和网络分析任务。\n\n[回答]\n(有向图的强连通分量)')]
2024-07-16 22:16:18.130 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name])。Tarjan算法通过深度优先搜索（DFS）来判断图中的强连通分量，它使用两个重要的数组dfn和low来记录节点的访问顺序和能够回溯到的最早的节点。当dfn[u] == low[u]时，意味着找到了一个强连通分量，并将栈中属于该分量的节点全部弹出。这个算法在处理网络分析、社交网络、编译器中的依赖分析以及图形处理等领域有广泛的应用，并且其时间复杂度为O(V+E)，适合于大规模图的处理。
2024-07-16 22:16:19.218 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]1
2024-07-16 22:16:19.219 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:66 - [algorithm code]```
void add(int a, int b){
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u){
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++){
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++){
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:17:11.910 | DEBUG    | __main__:algorithm_chat:27 - [message]一种用于处理区间查询和更新的高效数据结构
2024-07-16 22:17:11.911 | DEBUG    | __main__:algorithm_chat:28 - [history][['有向图的强连通分量', '知识库中无该算法模板'], ['一种用于优化滑动窗口问题的数据结构', '```\nint hh = 0, tt = -1;\nfor (int i = 0; i < n; i ++ )\n{\nwhile (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\nwhile (hh <= tt && check(q[tt], i)) tt -- ;\nq[ ++ tt] = i;\n}\n```'], ['有向图的强连通分量', '```\nvoid add(int a, int b){\ne[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\nvoid tarjan(int u){\ndfn[u] = low[u] = ++ timestamp;\nstk[ ++ top] = u, in_stk[u] = true;\n\nfor (int i = h[u]; ~i; i = ne[i])\n{\nint j = e[i];\nif (!dfn[j])\n{\ntarjan(j);\nlow[u] = min(low[u], low[j]);\n}\nelse if (in_stk[j])\nlow[u] = min(low[u], dfn[j]);\n}\n\nif (dfn[u] == low[u])\n{\n++ scc_cnt;\nint y;\ndo {\ny = stk[top -- ];\nin_stk[y] = false;\nid[y] = scc_cnt;\n//size_scc[scc_cnt]++;\n} while (y != u);\n}\n}\nfor(int i=1;i<=n;i++){\nif(!dfn[i])\ntarjan(i);\n}\nfor(int i=1;i<=n;i++){\nfor(int j=h[i];~j;j=ne[j])\n{\nint k=e[j];\nint a=id[i],b=id[k];\nif(a!=b) dout[a]++;\n}\n}\n```']]
2024-07-16 22:17:14.785 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n线段树是一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。以下是单点修改的线段树实现。\n数据结构: node 结构体存储每个节点的区间信息和相应的统计数据。\nl, r: 该节点代表的区间的左右端点。\nsum: 该区间的总和。\nlmax, rmax: 分别表示该区间内以左端点开始的最大前缀和和以右端点结束的最大后缀和。\ntmax: 表示该区间的最大子段和。\n构建:\nbuild(int u, int l, int r): 构建线段树。\n如果 l == r，说明叶子节点，直接赋值；否则，递归构建左右子树。\n单点修改:\nmodify(int u, int x, int v): 更新节点值，修改指定位置的值。\n查询:\nquery(int u, int l, int r): 查询指定区间的值，并合并左右子区间的结果。\n\n应用场景:\n在实际应用中，可以使用线段树来解决如下问题：\n动态数组的区间求和。\n动态数组的最大子段和查询。\n处理单点更新时保持查询效率。\n\n时间复杂度:\n构建时间：O(n)\n修改时间：O(logn)\n查询时间：O(logn)\n这种高效性使得线段树在需要频繁更新和查询的场景中非常有用。\n\n[回答]\n(线段树(单点修改))')]
2024-07-16 22:17:14.785 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](线段树(单点修改))
2024-07-16 22:17:15.951 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]63
2024-07-16 22:17:15.951 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:66 - [algorithm code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:24:32.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:24:32.100 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:24:32.101 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:24:32.103 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:24:32.104 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:24:32.104 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:24:32.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:24:32.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:24:32.106 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:24:32.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:24:32.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:24:32.108 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:24:32.109 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:24:32.110 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:24:32.111 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:24:32.111 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:24:32.111 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:24:32.112 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:24:32.113 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:24:32.113 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:24:32.115 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:24:32.116 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:24:32.117 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:24:32.118 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:24:32.118 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:24:32.119 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:24:32.120 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:24:32.121 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:24:32.121 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:24:32.122 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:24:32.122 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:24:32.123 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:24:32.124 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:24:32.125 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:24:32.125 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:24:32.126 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:24:32.126 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:24:32.126 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:24:32.127 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:24:32.128 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:24:32.128 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:24:32.128 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:24:32.129 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:24:32.129 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:24:32.131 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:24:32.132 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:24:32.132 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:24:32.132 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:24:32.133 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:24:32.133 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:24:32.134 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:24:32.134 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:24:32.135 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:24:32.135 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:24:32.136 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:24:32.137 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:24:32.138 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:24:32.139 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:24:32.139 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:24:32.140 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:24:32.141 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:24:32.141 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:24:32.142 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:24:32.143 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:24:32.143 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:24:32.145 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:24:32.146 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:24:32.147 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:24:32.148 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:24:32.150 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:24:32.151 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:24:32.152 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:24:32.153 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:24:32.153 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:24:32.153 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:24:32.154 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:24:32.154 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:24:32.154 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:24:32.155 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:24:32.156 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:24:32.156 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:24:32.158 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:24:32.159 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:24:32.160 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:24:32.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:24:32.161 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:24:32.162 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:24:32.162 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:24:32.164 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:24:32.165 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:24:32.166 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:24:32.167 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:24:32.167 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:24:32.168 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:24:32.168 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:24:32.169 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:24:32.170 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:24:32.171 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:24:32.171 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:24:32.172 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:24:32.173 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:24:32.174 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:24:32.176 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:24:32.176 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:24:32.177 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:24:32.177 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:24:32.178 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:24:32.179 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:24:32.180 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:24:32.181 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:24:32.182 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:24:32.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:24:32.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:24:32.184 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:24:32.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:24:32.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:24:32.187 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:24:32.188 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:24:32.188 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:24:32.189 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:24:32.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:24:32.192 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:24:32.193 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:24:32.194 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:24:32.195 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:24:32.196 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:24:32.197 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:24:32.198 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:24:32.199 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:24:32.201 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:24:32.201 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:24:32.202 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:24:32.204 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:24:32.204 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:24:32.205 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:24:32.207 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:24:32.208 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:24:32.209 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:24:32.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:24:32.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:24:32.212 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:24:32.213 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:24:32.214 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:24:32.216 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:24:32.218 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:24:32.218 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:24:32.220 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:24:32.222 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:24:32.222 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:24:32.224 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:24:32.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:24:32.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:24:32.229 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:24:32.232 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:24:32.232 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:24:32.234 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:24:32.236 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:24:32.236 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:24:32.237 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:24:32.239 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:24:32.239 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:24:32.240 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:24:32.241 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:24:32.241 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:24:32.242 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:24:32.244 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:24:32.244 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:24:32.245 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:24:32.246 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:24:32.246 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:24:32.246 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:24:32.247 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:24:32.247 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:24:32.248 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:24:32.249 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:24:32.250 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:24:32.250 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:24:32.251 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:24:32.251 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:24:32.252 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:24:32.253 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:24:32.254 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:24:32.254 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:24:32.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:24:32.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:24:32.257 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:24:32.258 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:24:32.258 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:24:32.261 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:24:32.264 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:24:32.264 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:24:32.267 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:24:32.270 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:24:32.270 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:24:32.271 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:24:32.272 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:24:32.272 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:24:32.274 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:24:32.275 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:25:44.804 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:25:44.805 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:25:44.806 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:25:44.807 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:25:44.808 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:25:44.808 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:25:44.810 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:25:44.810 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:25:44.811 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:25:44.812 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:25:44.812 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:25:44.813 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:25:44.813 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:25:44.814 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:25:44.815 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:25:44.816 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:25:44.817 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:25:44.818 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:25:44.819 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:25:44.819 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:25:44.820 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:25:44.821 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:25:44.821 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:25:44.821 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:25:44.824 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:25:44.824 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:25:44.825 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:25:44.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:25:44.826 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:25:44.827 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:25:44.828 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:25:44.828 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:25:44.829 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:25:44.830 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:25:44.830 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:25:44.831 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:25:44.831 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:25:44.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:25:44.832 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:25:44.833 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:25:44.833 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:25:44.834 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:25:44.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:25:44.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:25:44.835 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:25:44.837 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:25:44.837 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:25:44.838 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:25:44.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:25:44.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:25:44.840 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:25:44.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:25:44.841 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:25:44.841 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:25:44.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:25:44.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:25:44.843 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:25:44.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:25:44.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:25:44.845 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:25:44.846 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:25:44.847 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:25:44.847 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:25:44.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:25:44.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:25:44.849 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:25:44.851 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:25:44.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:25:44.853 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:25:44.854 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:25:44.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:25:44.855 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:25:44.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:25:44.857 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:25:44.857 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:25:44.858 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:25:44.858 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:25:44.859 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:25:44.860 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:25:44.860 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:25:44.861 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:25:44.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:25:44.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:25:44.864 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:25:44.865 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:25:44.866 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:25:44.867 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:25:44.868 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:25:44.868 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:25:44.869 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:25:44.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:25:44.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:25:44.871 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:25:44.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:25:44.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:25:44.873 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:25:44.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:25:44.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:25:44.875 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:25:44.876 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:25:44.876 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:25:44.878 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:25:44.880 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:25:44.880 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:25:44.881 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:25:44.881 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:25:44.882 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:25:44.882 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:25:44.883 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:25:44.883 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:25:44.885 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:25:44.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:25:44.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:25:44.888 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:25:44.890 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:25:44.890 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:25:44.891 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:25:44.892 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:25:44.893 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:25:44.894 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:25:44.896 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:25:44.896 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:25:44.897 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:25:44.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:25:44.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:25:44.901 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:25:44.902 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:25:44.902 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:25:44.903 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:25:44.905 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:25:44.906 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:25:44.907 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:25:44.908 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:25:44.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:25:44.910 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:25:44.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:25:44.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:25:44.914 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:25:44.916 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:25:44.916 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:25:44.917 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:25:44.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:25:44.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:25:44.920 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:25:44.922 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:25:44.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:25:44.924 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:25:44.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:25:44.927 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:25:44.929 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:25:44.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:25:44.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:25:44.934 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:25:44.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:25:44.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:25:44.938 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:25:44.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:25:44.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:25:44.942 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:25:44.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:25:44.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:25:44.944 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:25:44.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:25:44.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:25:44.946 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:25:44.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:25:44.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:25:44.948 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:25:44.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:25:44.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:25:44.951 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:25:44.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:25:44.952 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:25:44.952 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:25:44.953 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:25:44.953 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:25:44.954 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:25:44.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:25:44.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:25:44.956 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:25:44.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:25:44.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:25:44.958 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:25:44.959 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:25:44.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:25:44.961 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:25:44.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:25:44.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:25:44.965 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:25:44.968 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:25:44.969 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:25:44.972 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:25:44.975 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:25:44.975 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:25:44.976 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:25:44.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:25:44.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:25:44.978 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:25:44.979 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:26:25.827 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:26:25.828 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:26:25.829 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:26:25.830 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:26:25.831 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:26:25.831 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:26:25.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:26:25.832 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:26:25.833 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:26:25.835 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:26:25.836 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:26:25.837 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:26:25.838 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:26:25.838 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:26:25.839 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:26:25.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:26:25.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:26:25.841 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:26:25.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:26:25.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:26:25.844 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:26:25.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:26:25.845 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:26:25.846 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:26:25.846 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:26:25.847 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:26:25.847 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:26:25.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:26:25.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:26:25.850 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:26:25.851 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:26:25.851 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:26:25.852 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:26:25.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:26:25.853 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:26:25.853 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:26:25.854 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:26:25.854 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:26:25.854 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:26:25.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:26:25.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:26:25.856 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:26:25.857 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:26:25.857 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:26:25.858 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:26:25.859 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:26:25.859 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:26:25.860 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:26:25.860 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:26:25.861 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:26:25.861 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:26:25.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:26:25.863 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:26:25.865 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:26:25.866 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:26:25.866 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:26:25.867 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:26:25.868 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:26:25.868 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:26:25.869 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:26:25.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:26:25.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:26:25.871 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:26:25.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:26:25.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:26:25.873 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:26:25.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:26:25.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:26:25.876 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:26:25.879 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:26:25.879 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:26:25.880 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:26:25.881 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:26:25.881 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:26:25.882 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:26:25.882 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:26:25.884 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:26:25.885 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:26:25.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:26:25.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:26:25.888 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:26:25.889 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:26:25.889 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:26:25.890 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:26:25.892 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:26:25.892 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:26:25.893 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:26:25.895 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:26:25.895 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:26:25.896 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:26:25.896 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:26:25.897 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:26:25.898 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:26:25.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:26:25.899 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:26:25.900 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:26:25.901 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:26:25.901 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:26:25.903 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:26:25.904 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:26:25.904 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:26:25.906 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:26:25.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:26:25.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:26:25.910 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:26:25.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:26:25.911 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:26:25.913 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:26:25.914 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:26:25.914 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:26:25.916 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:26:25.917 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:26:25.917 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:26:25.918 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:26:25.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:26:25.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:26:25.921 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:26:25.922 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:26:25.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:26:25.924 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:26:25.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:26:25.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:26:25.928 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:26:25.929 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:26:25.929 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:26:25.930 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:26:25.932 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:26:25.932 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:26:25.934 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:26:25.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:26:25.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:26:25.937 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:26:25.938 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:26:25.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:26:25.940 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:26:25.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:26:25.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:26:25.943 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:26:25.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:26:25.946 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:26:25.947 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:26:25.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:26:25.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:26:25.950 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:26:25.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:26:25.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:26:25.955 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:26:25.956 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:26:25.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:26:25.958 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:26:25.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:26:25.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:26:25.964 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:26:25.967 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:26:25.967 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:26:25.969 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:26:25.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:26:25.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:26:25.972 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:26:25.973 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:26:25.973 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:26:25.974 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:26:25.975 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:26:25.975 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:26:25.976 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:26:25.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:26:25.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:26:25.977 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:26:25.978 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:26:25.978 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:26:25.979 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:26:25.980 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:26:25.980 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:26:25.981 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:26:25.982 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:26:25.982 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:26:25.982 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:26:25.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:26:25.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:26:25.985 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:26:25.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:26:25.987 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:26:25.988 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:26:25.989 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:26:25.990 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:26:25.991 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:26:25.991 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:26:25.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:26:25.995 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:26:25.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:26:25.999 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:26:26.001 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:26:26.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:26:26.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:26:26.006 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:26:26.007 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:26:26.007 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:26:26.009 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:26:26.011 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:30:33.176 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:30:33.177 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:30:33.178 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:30:33.179 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:30:33.181 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:30:33.182 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:30:33.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:30:33.183 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:30:33.184 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:30:33.185 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:30:33.186 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:30:33.187 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:30:33.188 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:30:33.188 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:30:33.189 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:30:33.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:30:33.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:30:33.191 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:30:33.192 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:30:33.192 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:30:33.193 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:30:33.194 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:30:33.194 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:30:33.195 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:30:33.197 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:30:33.197 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:30:33.198 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:30:33.198 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:30:33.199 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:30:33.199 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:30:33.200 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:30:33.200 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:30:33.201 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:30:33.201 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:30:33.202 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:30:33.203 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:30:33.203 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:30:33.204 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:30:33.204 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:30:33.205 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:30:33.205 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:30:33.205 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:30:33.206 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:30:33.206 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:30:33.207 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:30:33.208 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:30:33.209 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:30:33.209 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:30:33.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:30:33.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:30:33.211 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:30:33.212 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:30:33.212 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:30:33.213 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:30:33.213 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:30:33.214 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:30:33.214 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:30:33.215 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:30:33.215 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:30:33.216 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:30:33.217 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:30:33.218 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:30:33.218 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:30:33.219 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:30:33.219 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:30:33.221 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:30:33.222 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:30:33.223 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:30:33.225 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:30:33.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:30:33.227 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:30:33.227 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:30:33.228 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:30:33.228 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:30:33.229 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:30:33.229 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:30:33.229 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:30:33.230 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:30:33.232 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:30:33.232 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:30:33.233 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:30:33.234 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:30:33.234 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:30:33.235 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:30:33.236 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:30:33.236 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:30:33.238 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:30:33.240 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:30:33.240 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:30:33.241 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:30:33.243 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:30:33.243 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:30:33.244 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:30:33.245 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:30:33.245 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:30:33.246 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:30:33.247 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:30:33.247 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:30:33.248 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:30:33.248 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:30:33.249 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:30:33.250 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:30:33.252 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:30:33.252 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:30:33.253 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:30:33.254 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:30:33.254 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:30:33.255 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:30:33.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:30:33.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:30:33.257 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:30:33.259 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:30:33.259 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:30:33.262 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:30:33.263 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:30:33.263 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:30:33.264 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:30:33.266 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:30:33.266 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:30:33.268 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:30:33.269 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:30:33.270 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:30:33.271 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:30:33.272 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:30:33.273 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:30:33.274 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:30:33.276 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:30:33.276 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:30:33.278 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:30:33.280 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:30:33.280 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:30:33.281 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:30:33.282 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:30:33.282 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:30:33.283 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:30:33.284 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:30:33.284 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:30:33.286 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:30:33.289 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:30:33.289 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:30:33.289 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:30:33.291 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:30:33.292 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:30:33.294 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:30:33.295 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:30:33.296 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:30:33.297 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:30:33.299 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:30:33.299 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:30:33.302 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:30:33.304 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:30:33.304 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:30:33.308 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:30:33.311 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:30:33.311 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:30:33.312 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:30:33.314 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:30:33.314 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:30:33.315 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:30:33.317 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:30:33.317 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:30:33.318 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:30:33.319 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:30:33.319 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:30:33.320 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:30:33.321 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:30:33.322 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:30:33.322 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:30:33.323 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:30:33.323 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:30:33.324 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:30:33.324 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:30:33.325 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:30:33.325 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:30:33.326 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:30:33.327 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:30:33.328 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:30:33.329 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:30:33.329 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:30:33.329 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:30:33.331 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:30:33.331 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:30:33.332 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:30:33.333 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:30:33.333 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:30:33.334 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:30:33.336 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:30:33.336 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:30:33.340 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:30:33.343 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:30:33.344 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:30:33.346 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:30:33.350 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:30:33.350 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:30:33.351 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:30:33.352 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:30:33.352 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:30:33.353 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:30:33.354 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:30:35.430 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 22:32:25.894 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-16 22:32:25.895 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:32:25.897 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:32:25.898 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-16 22:32:25.900 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:32:25.901 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-16 22:32:25.903 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-16 22:32:25.903 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:32:25.905 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-16 22:32:25.906 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-16 22:32:25.906 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:32:25.908 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-16 22:32:25.910 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-16 22:32:25.910 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:32:25.910 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-16 22:32:25.912 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-16 22:32:25.912 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:32:25.913 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:32:25.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-16 22:32:25.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:32:25.917 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-16 22:32:25.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-16 22:32:25.919 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:32:25.921 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-16 22:32:25.922 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-16 22:32:25.922 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:32:25.923 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:32:25.925 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-16 22:32:25.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:32:25.927 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-16 22:32:25.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-16 22:32:25.929 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:32:25.930 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-16 22:32:25.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-16 22:32:25.932 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:32:25.933 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-16 22:32:25.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-16 22:32:25.935 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:32:25.936 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-16 22:32:25.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-16 22:32:25.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:32:25.938 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-16 22:32:25.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-16 22:32:25.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:32:25.940 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-16 22:32:25.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-16 22:32:25.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:32:25.943 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-16 22:32:25.944 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-16 22:32:25.944 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:32:25.945 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-16 22:32:25.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-16 22:32:25.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:32:25.948 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-16 22:32:25.950 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-16 22:32:25.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:32:25.952 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-16 22:32:25.953 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-16 22:32:25.953 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:32:25.955 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-16 22:32:25.956 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-16 22:32:25.957 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:32:25.958 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-16 22:32:25.959 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-16 22:32:25.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:32:25.962 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-16 22:32:25.964 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-16 22:32:25.964 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:32:25.967 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-16 22:32:25.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-16 22:32:25.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:32:25.972 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-16 22:32:25.973 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-16 22:32:25.973 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:32:25.974 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-16 22:32:25.975 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-16 22:32:25.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:32:25.977 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-16 22:32:25.978 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-16 22:32:25.979 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:32:25.980 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-16 22:32:25.982 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-16 22:32:25.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:32:25.985 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-16 22:32:25.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-16 22:32:25.987 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:32:25.988 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-16 22:32:25.991 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-16 22:32:25.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:32:25.993 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-16 22:32:25.995 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-16 22:32:25.995 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:32:25.996 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-16 22:32:25.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-16 22:32:25.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:32:26.000 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-16 22:32:26.001 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-16 22:32:26.001 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:32:26.002 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-16 22:32:26.003 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-16 22:32:26.004 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:32:26.006 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-16 22:32:26.009 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-16 22:32:26.009 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:32:26.010 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-16 22:32:26.011 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-16 22:32:26.011 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:32:26.014 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-16 22:32:26.015 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-16 22:32:26.016 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:32:26.018 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-16 22:32:26.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-16 22:32:26.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:32:26.022 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-16 22:32:26.023 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-16 22:32:26.024 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:32:26.025 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-16 22:32:26.028 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-16 22:32:26.028 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:32:26.031 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-16 22:32:26.033 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-16 22:32:26.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:32:26.036 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-16 22:32:26.038 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-16 22:32:26.038 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:32:26.040 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-16 22:32:26.043 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-16 22:32:26.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:32:26.045 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-16 22:32:26.048 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-16 22:32:26.048 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:32:26.049 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-16 22:32:26.050 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-16 22:32:26.051 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:32:26.052 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-16 22:32:26.054 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-16 22:32:26.055 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:32:26.056 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-16 22:32:26.060 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-16 22:32:26.060 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:32:26.062 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-16 22:32:26.063 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-16 22:32:26.064 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:32:26.067 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-16 22:32:26.070 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-16 22:32:26.070 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:32:26.073 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-16 22:32:26.075 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-16 22:32:26.076 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:32:26.078 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-16 22:32:26.082 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-16 22:32:26.082 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:32:26.086 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-16 22:32:26.091 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-16 22:32:26.091 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:32:26.093 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-16 22:32:26.095 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-16 22:32:26.095 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:32:26.097 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-16 22:32:26.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-16 22:32:26.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:32:26.100 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-16 22:32:26.101 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-16 22:32:26.101 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:32:26.103 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-16 22:32:26.104 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-16 22:32:26.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:32:26.106 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-16 22:32:26.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-16 22:32:26.107 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:32:26.108 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:32:26.109 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-16 22:32:26.110 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:32:26.111 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-16 22:32:26.112 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-16 22:32:26.112 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:32:26.113 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-16 22:32:26.114 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-16 22:32:26.114 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:32:26.115 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-16 22:32:26.117 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-16 22:32:26.118 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:32:26.119 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-16 22:32:26.120 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-16 22:32:26.120 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:32:26.122 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-16 22:32:26.124 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-16 22:32:26.124 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:32:26.126 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-16 22:32:26.130 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-16 22:32:26.130 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:32:26.133 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:32:26.137 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-16 22:32:26.138 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:32:26.139 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:32:26.140 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-16 22:32:26.140 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:32:26.142 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-16 22:32:26.143 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-16 22:32:28.761 | DEBUG    | chatbot.algorithm_code:__init__:39 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-16 22:33:02.403 | DEBUG    | __main__:algorithm_chat:27 - [message]一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。
2024-07-16 22:33:02.404 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:33:05.122 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程：\n概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。\n核心操作:\nlowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。\nmodify(int x, int c): 更新树状数组中位置 x 的值，增加 c。\nquery(int x): 查询数组前 x 个元素的和。\n\n应用场景:\n常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。\n该数据结构简单而高效，适合处理频繁的更新和查询操作。\n\n时间复杂度:\n更新操作和查询操作均为 O(logn)。\n\n[回答]\n(树状数组)')]
2024-07-16 22:33:05.122 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](树状数组)
2024-07-16 22:33:06.400 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]65
2024-07-16 22:33:06.400 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:66 - [algorithm code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-16 22:33:19.343 | DEBUG    | chatbot.chatbot:GetResult:44 - [result]下面是重新排版并添加逐行注释的代码。这段代码实现了一个基础的树状数组（Binary Indexed Tree, BIT或Fenwick Tree），用于高效处理数组的前缀和与区间和查询。

```cpp
// lowbit函数用于获取最低位的1及其后面的所有0组成的数值
int lowbit(int x) {
    return x & -x; // 使用位操作获得最低位的1，这是树状数组的核心操作之一
}

// modify函数用于更新树状数组中的元素，即给位置x加上值c
void modify(int x, int c) { // 修改树状数组中位置x的值
    while (x <= n) { // 当x在数组范围内时进行更新
        tr[x] += c; // 更新位置x的值
        x += lowbit(x); // 移动到下一个需要更新的位置
    }
}

// query函数用于计算从1到x的区间和
int query(int x) { // 查询从1到x的区间和
    int res = 0; // 初始化结果
    while (x > 0) { // 当x大于0时进行查询
        res += tr[x]; // 将位置x的值累加到结果中
        x -= lowbit(x); // 移动到前一个需要查询的位置
    }
    return res; // 返回区间和
}
```

注意：上述代码假设`n`是树状数组的大小上限，`tr`是一个全局数组，用于存储树状数组的数据。在真实使用中，应该将`n`和`tr`的定义包含在代码中，并且`tr`的大小应该至少为`n+1`，因为树状数组通常是基于1索引的。

此外，代码中没有提供`n`和`tr`的定义，也没有主函数或其他相关函数的定义，这些在实际应用中是必须的。这里只对提供的函数进行了注释和排版。
2024-07-16 22:33:46.167 | DEBUG    | __main__:algorithm_chat:27 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-16 22:33:46.168 | DEBUG    | __main__:algorithm_chat:28 - [history][['一种用于处理区间查询和更新的高效数据结构，特别适合于动态数组的范围查询和单点更新。', '下面是重新排版并添加逐行注释的代码。这段代码实现了一个基础的树状数组（Binary Indexed Tree, BIT或Fenwick Tree），用于高效处理数组的前缀和与区间和查询。\n\n```cpp\n// lowbit函数用于获取最低位的1及其后面的所有0组成的数值\nint lowbit(int x) {\n    return x & -x; // 使用位操作获得最低位的1，这是树状数组的核心操作之一\n}\n\n// modify函数用于更新树状数组中的元素，即给位置x加上值c\nvoid modify(int x, int c) { // 修改树状数组中位置x的值\n    while (x <= n) { // 当x在数组范围内时进行更新\n        tr[x] += c; // 更新位置x的值\n        x += lowbit(x); // 移动到下一个需要更新的位置\n    }\n}\n\n// query函数用于计算从1到x的区间和\nint query(int x) { // 查询从1到x的区间和\n    int res = 0; // 初始化结果\n    while (x > 0) { // 当x大于0时进行查询\n        res += tr[x]; // 将位置x的值累加到结果中\n        x -= lowbit(x); // 移动到前一个需要查询的位置\n    }\n    return res; // 返回区间和\n}\n```\n\n注意：上述代码假设`n`是树状数组的大小上限，`tr`是一个全局数组，用于存储树状数组的数据。在真实使用中，应该将`n`和`tr`的定义包含在代码中，并且`tr`的大小应该至少为`n+1`，因为树状数组通常是基于1索引的。\n\n此外，代码中没有提供`n`和`tr`的定义，也没有主函数或其他相关函数的定义，这些在实际应用中是必须的。这里只对提供的函数进行了注释和排版。']]
2024-07-16 22:33:49.205 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：\n使用两个指针 hh 和 tt 表示队列的头和尾。\n在每次迭代中，首先移除队列头部超出滑动窗口的元素。\n然后，移除队列尾部不符合条件的元素（例如不再是最优解）。\n将当前元素加入队列。\n\n应用场景: \n常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。\n\n时间复杂度: \n每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。\n\n[回答]\n(单调队列)')]
2024-07-16 22:33:49.205 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](单调队列)
2024-07-16 22:33:50.280 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]57
2024-07-16 22:33:50.280 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:66 - [algorithm code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-16 22:34:00.106 | DEBUG    | chatbot.chatbot:GetResult:44 - [result]下面是重新排版并添加了逐行注释的代码：

```cpp
// 初始化队头和队尾指针
int hh = 0, tt = -1;

// 遍历输入序列
for (int i = 0; i < n; i++) {
    // 如果队头元素已经不在当前窗口内，移除队头元素
    while (hh <= tt && check_out(q[hh])) hh++;

    // 如果队列不为空且队尾元素不满足条件，移除队尾元素
    while (hh <= tt && check(q[tt], i)) tt--;

    // 将当前元素添加到队列中
    q[++tt] = i;
}
```

注释说明：
- `hh` 和 `tt` 分别是队列的头部和尾部指针。
- `n` 是输入序列的长度。
- `q` 是一个数组，用于存储队列中的元素。
- `check_out` 是一个函数，用于检查队头元素是否已经不在当前处理的窗口内。
- `check` 是一个函数，用于检查队尾元素是否满足特定条件，例如是否与当前元素 `i` 冲突。
- `++tt` 用于将新的元素添加到队列的末尾。

如果 `check_out` 和 `check` 函数的具体实现未知，上述注释是基于这些函数名称的假设行为进行的。如果这些函数的实现与注释不符，那么注释可能需要相应调整。
2024-07-16 22:43:57.692 | DEBUG    | __main__:algorithm_chat:27 - [message]线段树区间修改
2024-07-16 22:43:57.693 | DEBUG    | __main__:algorithm_chat:28 - [history][]
2024-07-16 22:44:09.423 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n线段树（区间修改）\n过程:\n节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。\n核心功能:\neval 函数: 更新当前节点的值，考虑到乘法和加法的影响。\npushup 函数: 更新父节点的和，基于子节点的和。\npushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。\nbuild 函数: 构建线段树，初始化区间。\nmodify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。\nquery 函数: 查询给定区间的和，同时处理懒惰更新。\n\n应用场景: \n线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。\n线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。\n\n时间复杂度:\n建树: O(n)\n修改: O(logn)（使用懒惰标记）\n查询: O(logn)\n此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。\n\n[回答]\n(线段树区间修改)')]
2024-07-16 22:44:09.424 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name](线段树区间修改)

线段树是一种强大的数据结构，特别适用于处理区间查询和区间更新的问题。在您提供的信息中，该线段树的实现支持区间加法和乘法修改，通过懒惰传播（lazy propagation）技术，可以实现高效的区间更新操作。

具体来说，通过以下核心功能实现区间修改：

- **eval 函数**：负责计算当前节点由于乘法和加法懒惰标记所带来的影响，更新当前节点的 `sum` 值。
- **pushup 函数**：在查询或更新操作中，用于根据子节点的 `sum` 值更新父节点的 `sum` 值。
- **pushdown 函数**：在需要访问子节点之前，将当前节点的懒惰标记 `add` 和 `mul` 传播到它的子节点，确保子节点在需要时可以得到正确的更新。
- **modify 函数**：对给定区间进行加法或乘法修改。通过使用懒惰标记，我们可以在不立即更新每个节点的情况下，将更新操作延迟到必要时再执行，这大大提高了性能。
- **query 函数**：执行区间和的查询操作，同时处理可能存在的懒惰更新。

这种实现方式允许对区间进行快速的修改操作，并且这些操作的时间复杂度通常为：

- **建树（build）**：O(n)
- **修改（modify）**：O(log n)，由于使用了懒惰标记来延迟更新。
- **查询（query）**：O(log n)

综上所述，线段树区间修改的实现通过高效地处理乘法和加法更新，为解决区间更新和查询问题提供了一个灵活而高效的工具。
2024-07-16 22:44:10.951 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]64
2024-07-16 22:44:10.952 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:66 - [algorithm code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-16 22:44:43.410 | DEBUG    | chatbot.chatbot:GetResult:44 - [result]这段代码是一个基于线段树的数据结构实现，用于处理区间查询和更新的问题，具有区间加法和乘法操作。以下是代码的重新排版和逐行注释：

```cpp
#include <bits/stdc++.h> // C++标准库头文件，通常包含了常用的STL容器和函数
using namespace std;

const int N = 1e5 + 10; // 常量N定义，通常表示数组大小或节点数量，这里假设为10^5 + 10
const int p = 1e9 + 7; // 常量p，一个大的质数，用于取模，通常用于防止整数溢出

// 定义节点结构体，用于线段树
struct node {
    int l, r; // 当前节点的区间左端点和右端点
    long long sum; // 区间和
    long long add; // 区间加法懒惰标记
    long long mul; // 区间乘法懒惰标记
} tr[N * 4]; // 线段树数组

// 计算当前节点的区间和，加法和乘法懒惰标记
void eval(node &root, int add, int mul) {
    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p; // 更新区间和
    root.mul = root.mul * mul % p; // 更新区间乘法标记
    root.add = (root.add * mul + add) % p; // 更新区间加法标记
}

// 向上传递累加信息
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 更新当前节点的区间和
}

// 向下传递懒惰标记
void pushdown(int u) {
    // 递归更新子节点的区间和和懒惰标记
    eval(tr[u << 1], tr[u].add, tr[u].mul);
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul);
    // 清除当前节点的懒惰标记
    tr[u].add = 0, tr[u].mul = 1;
}

// 构建线段树
void build(int u, int l, int r) {
    if (l == r) {
        // 叶子节点，直接赋值
        tr[u] = {l, r, w[r], 0, 1}; // 假设存在一个数组w，存储原始数据
    } else {
        // 内部节点，递归构建左右子树
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1; // 计算中点
        build(u << 1, l, mid); // 构建左子树
        build(u << 1 | 1, mid + 1, r); // 构建右子树
        pushup(u); // 向上传递信息
    }
}

// 更新线段树区间
void modify(int u, int l, int r, int add, int mul) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全在查询区间内，直接更新
        eval(tr[u], add, mul);
    } else {
        // 否则，下推懒惰标记，并递归更新子节点
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul); // 更新左子树
        if (r > mid) modify(u << 1 | 1, l, r, add, mul); // 更新右子树
        pushup(u); // 向上传递信息
    }
}

// 查询线段树区间和
node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全在查询区间内，直接返回结果
        return tr[u];
    } else {
        // 否则，下推懒惰标记，并递归查询子节点
        pushdown(u);
        node res = {0, 0, 0, 0, 1}; // 初始化返回结果
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) res.sum += query(u << 1, l, r).sum % p; // 查询左子树
        if (r > mid) res.sum += query(u << 1 | 1, l
2024-07-16 22:45:29.672 | DEBUG    | __main__:algorithm_chat:27 - [message]继续输出
2024-07-16 22:45:29.672 | DEBUG    | __main__:algorithm_chat:28 - [history][['线段树区间修改', '这段代码是一个基于线段树的数据结构实现，用于处理区间查询和更新的问题，具有区间加法和乘法操作。以下是代码的重新排版和逐行注释：\n\n```cpp\n#include <bits/stdc++.h> // C++标准库头文件，通常包含了常用的STL容器和函数\nusing namespace std;\n\nconst int N = 1e5 + 10; // 常量N定义，通常表示数组大小或节点数量，这里假设为10^5 + 10\nconst int p = 1e9 + 7; // 常量p，一个大的质数，用于取模，通常用于防止整数溢出\n\n// 定义节点结构体，用于线段树\nstruct node {\n    int l, r; // 当前节点的区间左端点和右端点\n    long long sum; // 区间和\n    long long add; // 区间加法懒惰标记\n    long long mul; // 区间乘法懒惰标记\n} tr[N * 4]; // 线段树数组\n\n// 计算当前节点的区间和，加法和乘法懒惰标记\nvoid eval(node &root, int add, int mul) {\n    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p; // 更新区间和\n    root.mul = root.mul * mul % p; // 更新区间乘法标记\n    root.add = (root.add * mul + add) % p; // 更新区间加法标记\n}\n\n// 向上传递累加信息\nvoid pushup(int u) {\n    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 更新当前节点的区间和\n}\n\n// 向下传递懒惰标记\nvoid pushdown(int u) {\n    // 递归更新子节点的区间和和懒惰标记\n    eval(tr[u << 1], tr[u].add, tr[u].mul);\n    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul);\n    // 清除当前节点的懒惰标记\n    tr[u].add = 0, tr[u].mul = 1;\n}\n\n// 构建线段树\nvoid build(int u, int l, int r) {\n    if (l == r) {\n        // 叶子节点，直接赋值\n        tr[u] = {l, r, w[r], 0, 1}; // 假设存在一个数组w，存储原始数据\n    } else {\n        // 内部节点，递归构建左右子树\n        tr[u] = {l, r, 0, 0, 1};\n        int mid = l + r >> 1; // 计算中点\n        build(u << 1, l, mid); // 构建左子树\n        build(u << 1 | 1, mid + 1, r); // 构建右子树\n        pushup(u); // 向上传递信息\n    }\n}\n\n// 更新线段树区间\nvoid modify(int u, int l, int r, int add, int mul) {\n    if (tr[u].l >= l && tr[u].r <= r) {\n        // 当前区间完全在查询区间内，直接更新\n        eval(tr[u], add, mul);\n    } else {\n        // 否则，下推懒惰标记，并递归更新子节点\n        pushdown(u);\n        int mid = tr[u].l + tr[u].r >> 1;\n        if (l <= mid) modify(u << 1, l, r, add, mul); // 更新左子树\n        if (r > mid) modify(u << 1 | 1, l, r, add, mul); // 更新右子树\n        pushup(u); // 向上传递信息\n    }\n}\n\n// 查询线段树区间和\nnode query(int u, int l, int r) {\n    if (tr[u].l >= l && tr[u].r <= r) {\n        // 当前区间完全在查询区间内，直接返回结果\n        return tr[u];\n    } else {\n        // 否则，下推懒惰标记，并递归查询子节点\n        pushdown(u);\n        node res = {0, 0, 0, 0, 1}; // 初始化返回结果\n        int mid = tr[u].l + tr[u].r >> 1;\n        if (l <= mid) res.sum += query(u << 1, l, r).sum % p; // 查询左子树\n        if (r > mid) res.sum += query(u << 1 | 1, l']]
2024-07-16 22:45:31.437 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:78 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='-----1-----\n[问题] \n过程:\n该模板实现了对 __int128 类型的读写操作，适用于需要处理超过标准整型范围的大整数场景。具体步骤如下：\n\nread 函数用于从标准输入中读取 __int128 类型的大整数。通过逐字符读取并转换为整数，处理负号。\nprint 函数用于将 __int128 类型的大整数输出到标准输出。采用递归方法输出每一位数字，处理负号。\n应用场景:\n__int128 类型读写模板在处理需要高精度大整数的算法中非常有用，如大数乘法、RSA加密解密、科学计算和一些竞赛题目。由于标准 int 和 long long 类型无法满足更大范围的数据需求，该模板提供了必要的基础操作。\n\n时间复杂度:\nread 函数的时间复杂度为 O(n)，其中 n 为输入数字的长度，因为需要逐字符读取并转换为整数。\nprint 函数的时间复杂度为 O(log x)，其中 x 为输入数字的大小，因为递归调用的次数与数字的位数成比例。\n这两个函数在处理 __int128 类型时保证了高效的读写操作，适用于处理大整数的场景。\n\n[回答]\n(__int128读写)')]
2024-07-16 22:45:31.441 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:48 - [algorithm_chao_name]对不起，根据你提供的规则，我应该在'[回答]'的下一行中输出括号内的内容。那么我的输出应该是：

(__int128读写)
2024-07-16 22:45:32.509 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:61 - [algorithm_name]2
2024-07-16 22:45:32.510 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:66 - [algorithm code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-16 22:45:48.260 | DEBUG    | chatbot.chatbot:GetResult:44 - [result]这段代码用于处理大整数的输入和输出，下面是重新排版并添加注释的代码：

```cpp
// 读取一个128位整数，处理可能的负号
inline __int128 read() {
    __int128 x = 0, f = 1; // 定义结果和符号标志，默认为正数
    char ch = getchar(); // 读取第一个字符

    // 如果字符不是数字，则可能是负号或非数字字符
    while (ch < '0' || ch > '9') {
        if (ch == '-') // 如果是负号，设置符号标志为-1
            f = -1;
        ch = getchar(); // 继续读取下一个字符
    }

    // 当字符是数字时，进行数字的读取和转换
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0'; // 将当前字符转换为数字，并累加到结果中
        ch = getchar(); // 读取下一个字符
    }

    return x * f; // 返回带符号的结果
}

// 输出一个128位整数
inline void print(__int128 x) {
    if (x < 0) { // 如果是负数
        putchar('-'); // 输出负号
        x = -x; // 转换为正数以方便输出
    }

    // 递归处理大于9的数字，确保先输出高位
    if (x > 9)
        print(x / 10);

    // 输出当前最低位的数字
    putchar(x % 10 + '0'); // 将数字转换为字符输出
}
```

这段代码使用了`__int128`类型来处理大于64位整数的输入和输出。这种类型在某些编译器如GCC和Clang中可用，但不是所有编译器都支持。`getchar()`和`putchar()`函数用于读取和输出单个字符。

注意：这种递归输出方法对于非常大的数可能会导致栈溢出。通常在处理大整数时，应该使用循环而不是递归。
