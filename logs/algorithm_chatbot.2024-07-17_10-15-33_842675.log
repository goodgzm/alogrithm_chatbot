2024-07-17 10:15:33.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 10:15:33.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 10:15:33.846 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 10:15:33.850 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-17 10:15:33.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 10:15:33.854 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 10:15:33.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-17 10:15:33.857 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 10:15:33.860 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 10:15:33.864 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-17 10:15:33.864 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 10:15:33.868 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 10:15:33.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 10:15:33.881 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 10:15:33.884 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 10:15:33.886 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-17 10:15:33.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 10:15:33.889 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 10:15:33.892 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 10:15:33.893 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 10:15:33.897 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 10:15:33.900 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 10:15:33.901 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 10:15:33.902 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 10:15:33.905 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 10:15:33.905 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 10:15:33.908 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 10:15:33.910 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 10:15:33.910 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 10:15:33.913 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 10:15:33.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 10:15:33.916 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 10:15:33.918 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 10:15:33.920 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 10:15:33.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 10:15:33.921 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 10:15:33.922 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 10:15:33.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 10:15:33.924 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 10:15:33.925 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 10:15:33.925 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 10:15:33.926 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 10:15:33.927 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 10:15:33.927 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 10:15:33.929 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 10:15:33.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 10:15:33.932 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 10:15:33.933 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 10:15:33.935 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-17 10:15:33.935 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 10:15:33.937 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 10:15:33.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 10:15:33.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 10:15:33.941 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 10:15:33.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 10:15:33.944 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 10:15:33.946 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 10:15:33.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 10:15:33.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 10:15:33.952 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 10:15:33.954 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 10:15:33.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 10:15:33.957 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 10:15:33.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 10:15:33.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 10:15:33.965 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 10:15:33.969 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-17 10:15:33.971 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 10:15:33.976 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 10:15:33.981 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 10:15:33.982 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 10:15:33.983 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 10:15:33.985 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 10:15:33.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 10:15:33.987 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 10:15:33.988 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 10:15:33.988 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 10:15:33.990 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 10:15:33.991 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 10:15:33.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 10:15:33.994 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 10:15:33.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 10:15:33.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 10:15:34.000 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 10:15:34.002 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 10:15:34.003 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 10:15:34.005 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 10:15:34.008 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 10:15:34.008 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 10:15:34.010 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 10:15:34.013 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-17 10:15:34.014 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 10:15:34.015 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 10:15:34.017 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 10:15:34.017 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 10:15:34.019 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 10:15:34.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 10:15:34.021 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 10:15:34.022 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 10:15:34.024 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 10:15:34.024 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 10:15:34.027 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 10:15:34.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 10:15:34.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 10:15:34.034 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 10:15:34.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 10:15:34.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 10:15:34.038 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 10:15:34.040 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 10:15:34.041 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 10:15:34.043 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 10:15:34.047 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 10:15:34.047 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 10:15:34.050 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 10:15:34.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-17 10:15:34.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 10:15:34.053 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 10:15:34.055 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 10:15:34.056 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 10:15:34.058 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 10:15:34.060 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 10:15:34.060 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 10:15:34.063 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 10:15:34.065 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 10:15:34.066 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 10:15:34.068 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 10:15:34.070 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 10:15:34.084 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 10:15:34.100 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 10:15:34.102 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 10:15:34.103 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 10:15:34.104 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 10:15:34.106 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-17 10:15:34.106 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 10:15:34.110 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 10:15:34.113 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 10:15:34.114 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 10:15:34.117 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 10:15:34.119 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 10:15:34.120 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 10:15:34.121 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 10:15:34.122 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 10:15:34.123 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 10:15:34.125 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 10:15:34.127 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 10:15:34.128 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 10:15:34.131 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 10:15:34.133 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 10:15:34.134 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 10:15:34.138 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 10:15:34.141 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 10:15:34.147 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 10:15:34.152 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 10:15:34.159 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-17 10:15:34.160 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 10:15:34.162 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 10:15:34.165 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 10:15:34.165 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 10:15:34.167 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 10:15:34.169 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-17 10:15:34.169 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 10:15:34.171 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 10:15:34.172 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-17 10:15:34.172 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 10:15:34.174 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 10:15:34.175 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-17 10:15:34.175 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 10:15:34.176 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 10:15:34.178 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-17 10:15:34.182 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 10:15:34.183 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 10:15:34.185 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 10:15:34.185 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 10:15:34.186 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 10:15:34.187 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 10:15:34.188 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 10:15:34.188 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 10:15:34.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 10:15:34.190 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 10:15:34.192 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 10:15:34.196 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 10:15:34.196 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 10:15:34.198 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 10:15:34.199 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-17 10:15:34.200 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 10:15:34.202 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 10:15:34.205 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 10:15:34.206 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 10:15:34.214 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 10:15:34.221 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 10:15:34.222 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 10:15:34.232 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 10:15:34.238 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-17 10:15:34.239 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 10:15:34.240 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 10:15:34.242 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-17 10:15:34.242 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 10:15:34.245 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 10:15:34.247 | DEBUG    | __main__:init:19 - Code of local to DB successful
2024-07-17 10:15:37.154 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 10:17:19.103 | DEBUG    | __main__:algorithm_chat:28 - [message]单源最短路问题
2024-07-17 10:17:19.104 | DEBUG    | __main__:algorithm_chat:29 - [history][]
2024-07-17 10:17:22.138 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。\n\n应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。\n\n时间复杂度: Floyd 算法的时间复杂度为 \nO(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。\n\n[回答]\n(Floyd 算法)')]
2024-07-17 10:17:22.139 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](Floyd 算法)
2024-07-17 10:17:23.454 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]23
2024-07-17 10:17:23.456 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 10:17:41.495 | DEBUG    | chatbot.chatbot:GetResult:52 - [result]下面是重新排版并添加了逐行注释的代码。请注意，为了理解代码的功能，我假设了一些上下文，特别是关于`dp`数组的用途和变量`n`、`a`、`b`的来源。

```cpp
const int N = 2e5 + 7; // 定义一个常量N，通常用于数组大小，这里假设足够大以存储数据
const int M = 20;      // 常量M，可能代表某种维度限制或数组大小

int dp[N][M]; // 动态规划数组，存储子段的最大值
int a[N];      // 数组a，存储原始数据

// 外循环遍历所有可能的"区间大小"（从0到M-1）
for (int j = 0; j < M; j++) {
    // 内循环遍历数组a，计算以i开始，长度为2^j的子段的最大值
    for (int i = 1; i + (1 << j) - 1 <= n; i++) { // 确保i加上2^j-1不会越界
        if (!j) { // 如果j为0，即区间长度为1，dp[i][j]就是a[i]本身
            dp[i][j] = a[i];
        } else { // 否则，计算左半部分和右半部分的最大值
            // dp[i][j-1]代表当前区间的左半部分的最大值
            // dp[i+(1<<(j-1))][j-1]代表当前区间的右半部分的最大值
            dp[i][j] = max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);
        }
    }
}

// 计算结果，这里假设b > a且都在数组范围内
int res = log(b - a + 1) / log(2); // 计算最大区间长度对应的j值
// 输出在区间[a, b]中的最大值
cout << max(dp[a][res], dp[b - (1 << res) + 1][res]) << endl;
```

这段代码似乎是用于处理一个RMQ（Range Maximum/Minimum Query，区间最大/最小查询）问题。它使用了一种称为“稀疏表”或“Sparse Table”的预处理技术来高效地解决查询问题。

注意：代码中有几个变量（`n`和`b`）没有在代码中定义，假设它们是在代码其他部分定义的。此外，这段代码没有包括必要的头文件（如`<iostream>`和`<cmath>`），并且没有初始化变量`n`和数组`a`，这在实际代码中是必要的。
2024-07-17 10:18:14.456 | DEBUG    | __main__:algorithm_chat:28 - [message]时间复杂度O(nlogn)解决最短路问题
2024-07-17 10:18:14.456 | DEBUG    | __main__:algorithm_chat:29 - [history][['单源最短路问题', '下面是重新排版并添加了逐行注释的代码。请注意，为了理解代码的功能，我假设了一些上下文，特别是关于`dp`数组的用途和变量`n`、`a`、`b`的来源。\n\n```cpp\nconst int N = 2e5 + 7; // 定义一个常量N，通常用于数组大小，这里假设足够大以存储数据\nconst int M = 20;      // 常量M，可能代表某种维度限制或数组大小\n\nint dp[N][M]; // 动态规划数组，存储子段的最大值\nint a[N];      // 数组a，存储原始数据\n\n// 外循环遍历所有可能的"区间大小"（从0到M-1）\nfor (int j = 0; j < M; j++) {\n    // 内循环遍历数组a，计算以i开始，长度为2^j的子段的最大值\n    for (int i = 1; i + (1 << j) - 1 <= n; i++) { // 确保i加上2^j-1不会越界\n        if (!j) { // 如果j为0，即区间长度为1，dp[i][j]就是a[i]本身\n            dp[i][j] = a[i];\n        } else { // 否则，计算左半部分和右半部分的最大值\n            // dp[i][j-1]代表当前区间的左半部分的最大值\n            // dp[i+(1<<(j-1))][j-1]代表当前区间的右半部分的最大值\n            dp[i][j] = max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);\n        }\n    }\n}\n\n// 计算结果，这里假设b > a且都在数组范围内\nint res = log(b - a + 1) / log(2); // 计算最大区间长度对应的j值\n// 输出在区间[a, b]中的最大值\ncout << max(dp[a][res], dp[b - (1 << res) + 1][res]) << endl;\n```\n\n这段代码似乎是用于处理一个RMQ（Range Maximum/Minimum Query，区间最大/最小查询）问题。它使用了一种称为“稀疏表”或“Sparse Table”的预处理技术来高效地解决查询问题。\n\n注意：代码中有几个变量（`n`和`b`）没有在代码中定义，假设它们是在代码其他部分定义的。此外，这段代码没有包括必要的头文件（如`<iostream>`和`<cmath>`），并且没有初始化变量`n`和数组`a`，这在实际代码中是必要的。']]
2024-07-17 10:18:18.874 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: Floyd 算法通过三重循环实现对所有节点对之间最短路径的更新。初始化时，构建一个距离矩阵 d，将所有节点到自身的距离设为零，其余设为无穷大。然后，通过输入的边更新初始距离。接着，算法遍历每一个可能的中间节点 k，并尝试更新任意两个节点 i 和 j 之间的最短路径。\n\n应用场景: 适合处理稠密图（即边数接近节点数平方）的多源最短路径问题，广泛应用于网络路由、地理信息系统及图论中的各种最短路径计算。\n\n时间复杂度: Floyd 算法的时间复杂度为 \nO(n^3)，其中 n 是图中节点的数量。这使得该算法在节点数较大时效率较低，但对于节点数较小的图（如 n<500）仍然是有效的。\n\n[回答]\n(Floyd 算法)')]
2024-07-17 10:18:18.877 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](Floyd 算法的时间复杂度为 O(n^3)，并不适用于时间复杂度要求为 O(nlogn) 的最短路径问题。对于要求时间复杂度为 O(nlogn) 的最短路问题，通常会使用基于优先队列的 Dijkstra 算法，该算法适用于带有非负权重的图。)
2024-07-17 10:18:20.259 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]46
2024-07-17 10:18:20.261 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 10:18:41.236 | DEBUG    | chatbot.chatbot:GetResult:52 - [result]这段代码是一个使用Dijkstra算法计算单源最短路径的函数。下面我将重新排版这段代码，并逐行添加注释，以使其更加清晰。

```cpp
// 定义Dijkstra算法函数，计算从源点1到其他所有点的最短路径
int dijkstra() {
    // 初始化距离数组，将所有距离设为极大值，这里用0x3f3f3f3f表示
    memset(dist, 0x3f, sizeof dist);
    // 设置源点1到自身的距离为0
    dist[1] = 0;
    // 定义一个优先队列，按照距离从小到大排序，first为距离，second为节点编号
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    // 将源点1加入优先队列，距离为0
    heap.push({0, 1});

    // 当优先队列非空时进行循环
    while (heap.size()) {
        // 获取队列中距离最小的节点
        auto t = heap.top();
        heap.pop();

        // 解析节点编号和距离
        int ver = t.second, distance = t.first;

        // 如果该节点已经访问过，则跳过
        if (st[ver]) continue;
        st[ver] = true; // 标记当前节点为已访问

        // 遍历当前节点的所有邻接边
        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i]; // 邻接点编号
            // 如果经过当前节点到达邻接点的距离更短，则更新距离
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i]; // 更新距离
                heap.push({dist[j], j}); // 将新的节点和距离加入优先队列
            }
        }
    }

    // 如果目标节点n的距离仍然是极大值，说明无法到达，返回-1
    if (dist[n] == 0x3f3f3f3f) return -1;
    // 返回到达目标节点n的最短距离
    return dist[n];
}
```

注释说明：
- `dist[]`：存储从源点到其他各点的最短距离。
- `st[]`：标记数组，用于标记某个节点是否已访问。
- `h[]`、`e[]`、`ne[]`、`w[]`：分别代表邻接表的头指针数组、边的终点数组、下一条边的数组、边的权重数组。
- `PII`：一个自定义的Pair类型，通常表示一对整数，在这里用于存储节点和距离。
- `n`：目标节点编号。
- `0x3f3f3f3f`：一个常用的极大值，表示无穷大。

代码中未给出这些变量的定义，但根据上下文可以推断其用途。如果这些变量未在代码的其它部分定义，代码将无法直接编译运行。
2024-07-17 10:20:23.975 | DEBUG    | __main__:algorithm_chat:28 - [message]今天天气怎么样
2024-07-17 10:20:23.975 | DEBUG    | __main__:algorithm_chat:29 - [history][['单源最短路问题', '下面是重新排版并添加了逐行注释的代码。请注意，为了理解代码的功能，我假设了一些上下文，特别是关于`dp`数组的用途和变量`n`、`a`、`b`的来源。\n\n```cpp\nconst int N = 2e5 + 7; // 定义一个常量N，通常用于数组大小，这里假设足够大以存储数据\nconst int M = 20;      // 常量M，可能代表某种维度限制或数组大小\n\nint dp[N][M]; // 动态规划数组，存储子段的最大值\nint a[N];      // 数组a，存储原始数据\n\n// 外循环遍历所有可能的"区间大小"（从0到M-1）\nfor (int j = 0; j < M; j++) {\n    // 内循环遍历数组a，计算以i开始，长度为2^j的子段的最大值\n    for (int i = 1; i + (1 << j) - 1 <= n; i++) { // 确保i加上2^j-1不会越界\n        if (!j) { // 如果j为0，即区间长度为1，dp[i][j]就是a[i]本身\n            dp[i][j] = a[i];\n        } else { // 否则，计算左半部分和右半部分的最大值\n            // dp[i][j-1]代表当前区间的左半部分的最大值\n            // dp[i+(1<<(j-1))][j-1]代表当前区间的右半部分的最大值\n            dp[i][j] = max(dp[i][j-1], dp[i+(1<<(j-1))][j-1]);\n        }\n    }\n}\n\n// 计算结果，这里假设b > a且都在数组范围内\nint res = log(b - a + 1) / log(2); // 计算最大区间长度对应的j值\n// 输出在区间[a, b]中的最大值\ncout << max(dp[a][res], dp[b - (1 << res) + 1][res]) << endl;\n```\n\n这段代码似乎是用于处理一个RMQ（Range Maximum/Minimum Query，区间最大/最小查询）问题。它使用了一种称为“稀疏表”或“Sparse Table”的预处理技术来高效地解决查询问题。\n\n注意：代码中有几个变量（`n`和`b`）没有在代码中定义，假设它们是在代码其他部分定义的。此外，这段代码没有包括必要的头文件（如`<iostream>`和`<cmath>`），并且没有初始化变量`n`和数组`a`，这在实际代码中是必要的。'], ['时间复杂度O(nlogn)解决最短路问题', '这段代码是一个使用Dijkstra算法计算单源最短路径的函数。下面我将重新排版这段代码，并逐行添加注释，以使其更加清晰。\n\n```cpp\n// 定义Dijkstra算法函数，计算从源点1到其他所有点的最短路径\nint dijkstra() {\n    // 初始化距离数组，将所有距离设为极大值，这里用0x3f3f3f3f表示\n    memset(dist, 0x3f, sizeof dist);\n    // 设置源点1到自身的距离为0\n    dist[1] = 0;\n    // 定义一个优先队列，按照距离从小到大排序，first为距离，second为节点编号\n    priority_queue<PII, vector<PII>, greater<PII>> heap;\n    // 将源点1加入优先队列，距离为0\n    heap.push({0, 1});\n\n    // 当优先队列非空时进行循环\n    while (heap.size()) {\n        // 获取队列中距离最小的节点\n        auto t = heap.top();\n        heap.pop();\n\n        // 解析节点编号和距离\n        int ver = t.second, distance = t.first;\n\n        // 如果该节点已经访问过，则跳过\n        if (st[ver]) continue;\n        st[ver] = true; // 标记当前节点为已访问\n\n        // 遍历当前节点的所有邻接边\n        for (int i = h[ver]; i != -1; i = ne[i]) {\n            int j = e[i]; // 邻接点编号\n            // 如果经过当前节点到达邻接点的距离更短，则更新距离\n            if (dist[j] > distance + w[i]) {\n                dist[j] = distance + w[i]; // 更新距离\n                heap.push({dist[j], j}); // 将新的节点和距离加入优先队列\n            }\n        }\n    }\n\n    // 如果目标节点n的距离仍然是极大值，说明无法到达，返回-1\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    // 返回到达目标节点n的最短距离\n    return dist[n];\n}\n```\n\n注释说明：\n- `dist[]`：存储从源点到其他各点的最短距离。\n- `st[]`：标记数组，用于标记某个节点是否已访问。\n- `h[]`、`e[]`、`ne[]`、`w[]`：分别代表邻接表的头指针数组、边的终点数组、下一条边的数组、边的权重数组。\n- `PII`：一个自定义的Pair类型，通常表示一对整数，在这里用于存储节点和距离。\n- `n`：目标节点编号。\n- `0x3f3f3f3f`：一个常用的极大值，表示无穷大。\n\n代码中未给出这些变量的定义，但根据上下文可以推断其用途。如果这些变量未在代码的其它部分定义，代码将无法直接编译运行。']]
2024-07-17 10:20:29.189 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][]
2024-07-17 10:20:29.189 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name][回答]: 山南当前(2024年07月17日)天气: 阴 14.6摄氏度, 西风4级, 湿度: 81%, 空气质量: 23. 白天:阵雨, 最高气温24摄氏度 ,无持续风向<3级. 夜间:小雨, 最低气温12摄氏度 ,无持续风向<3级。
2024-07-17 10:20:31.853 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]对不起，您提供的信息与问题要求的算法描述不相关。我需要一段关于某个算法的描述，才能从您给出的关键词列表中选择对应的序号整数。如果您能提供相应的算法描述，我会很乐意帮助您。
2024-07-17 10:20:31.856 | ERROR    | chatbot.algorithm_code:GetAlgorithmCode:76 - 知识库中无该算法模板
2024-07-17 11:02:30.099 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 11:02:30.100 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:02:30.102 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:02:30.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-17 11:02:30.105 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:02:30.107 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:02:30.108 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-17 11:02:30.109 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:02:30.111 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:02:30.114 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-17 11:02:30.114 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:02:30.117 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:02:30.119 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 11:02:30.120 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:02:30.121 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:02:30.124 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-17 11:02:30.125 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:02:30.127 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:02:30.129 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 11:02:30.130 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:02:30.132 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:02:30.134 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 11:02:30.135 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:02:30.136 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:02:30.138 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 11:02:30.139 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:02:30.140 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:02:30.142 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 11:02:30.143 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:02:30.144 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:02:30.146 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 11:02:30.147 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:02:30.148 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:02:30.150 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 11:02:30.151 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:02:30.151 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:02:30.153 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 11:02:30.153 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:02:30.155 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:02:30.156 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 11:02:30.156 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:02:30.157 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:02:30.158 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 11:02:30.158 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:02:30.161 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:02:30.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 11:02:30.163 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:02:30.164 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:02:30.166 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-17 11:02:30.166 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:02:30.168 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:02:30.171 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 11:02:30.171 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:02:30.173 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:02:30.174 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 11:02:30.175 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:02:30.176 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:02:30.178 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 11:02:30.178 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:02:30.180 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:02:30.181 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 11:02:30.181 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:02:30.183 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:02:30.185 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 11:02:30.185 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:02:30.188 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:02:30.191 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-17 11:02:30.191 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:02:30.196 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:02:30.199 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 11:02:30.200 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:02:30.201 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:02:30.202 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 11:02:30.203 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:02:30.203 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:02:30.204 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 11:02:30.204 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:02:30.205 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:02:30.206 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 11:02:30.207 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:02:30.209 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:02:30.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 11:02:30.211 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:02:30.212 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:02:30.214 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 11:02:30.215 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:02:30.216 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:02:30.218 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 11:02:30.219 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:02:30.220 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:02:30.223 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-17 11:02:30.223 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:02:30.224 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:02:30.225 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 11:02:30.226 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:02:30.227 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:02:30.228 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 11:02:30.229 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:02:30.230 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:02:30.231 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 11:02:30.232 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:02:30.234 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:02:30.237 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 11:02:30.238 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:02:30.238 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:02:30.240 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 11:02:30.240 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:02:30.242 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:02:30.243 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 11:02:30.243 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:02:30.245 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:02:30.247 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 11:02:30.247 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:02:30.248 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:02:30.250 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-17 11:02:30.250 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:02:30.251 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:02:30.252 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 11:02:30.253 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:02:30.254 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:02:30.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 11:02:30.256 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:02:30.258 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:02:30.259 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 11:02:30.259 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:02:30.260 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:02:30.261 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 11:02:30.262 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:02:30.264 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:02:30.265 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 11:02:30.265 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:02:30.266 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:02:30.268 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-17 11:02:30.268 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:02:30.269 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:02:30.271 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 11:02:30.271 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:02:30.273 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:02:30.275 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 11:02:30.275 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:02:30.276 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:02:30.278 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 11:02:30.278 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:02:30.280 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:02:30.282 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 11:02:30.282 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:02:30.284 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:02:30.286 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 11:02:30.286 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:02:30.288 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:02:30.290 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 11:02:30.291 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:02:30.294 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:02:30.299 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-17 11:02:30.299 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:02:30.301 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:02:30.302 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 11:02:30.302 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:02:30.303 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:02:30.306 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-17 11:02:30.306 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:02:30.307 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:02:30.308 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-17 11:02:30.308 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:02:30.309 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:02:30.310 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-17 11:02:30.310 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:02:30.310 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:02:30.311 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-17 11:02:30.312 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:02:30.312 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:02:30.313 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 11:02:30.313 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:02:30.315 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:02:30.315 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 11:02:30.316 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:02:30.316 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:02:30.317 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 11:02:30.317 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:02:30.318 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:02:30.320 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 11:02:30.320 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:02:30.321 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:02:30.322 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-17 11:02:30.322 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:02:30.324 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:02:30.327 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 11:02:30.327 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:02:30.333 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:02:30.340 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 11:02:30.341 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:02:30.345 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:02:30.350 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-17 11:02:30.350 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:02:30.351 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:02:30.352 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-17 11:02:30.352 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:02:30.354 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:02:30.356 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 11:02:32.471 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 11:04:13.731 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 11:04:13.732 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:04:13.733 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:04:13.735 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-17 11:04:13.735 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:04:13.736 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:04:13.737 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-17 11:04:13.737 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:04:13.738 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:04:13.740 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-17 11:04:13.740 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:04:13.741 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:04:13.742 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 11:04:13.742 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:04:13.743 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:04:13.744 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-17 11:04:13.744 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:04:13.745 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:04:13.746 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 11:04:13.747 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:04:13.747 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:04:13.748 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 11:04:13.748 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:04:13.749 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:04:13.750 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 11:04:13.750 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:04:13.751 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:04:13.751 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 11:04:13.751 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:04:13.752 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:04:13.753 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 11:04:13.753 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:04:13.754 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:04:13.754 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 11:04:13.755 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:04:13.755 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:04:13.756 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 11:04:13.756 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:04:13.757 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:04:13.757 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 11:04:13.758 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:04:13.758 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:04:13.759 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 11:04:13.759 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:04:13.760 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:04:13.762 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 11:04:13.762 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:04:13.763 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:04:13.763 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-17 11:04:13.764 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:04:13.764 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:04:13.765 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 11:04:13.765 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:04:13.766 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:04:13.766 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 11:04:13.767 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:04:13.768 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:04:13.769 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 11:04:13.769 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:04:13.770 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:04:13.771 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 11:04:13.771 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:04:13.772 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:04:13.773 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 11:04:13.774 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:04:13.775 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:04:13.776 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-17 11:04:13.777 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:04:13.778 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:04:13.780 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 11:04:13.780 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:04:13.781 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:04:13.782 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 11:04:13.783 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:04:13.783 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:04:13.784 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 11:04:13.784 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:04:13.785 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:04:13.785 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 11:04:13.786 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:04:13.786 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:04:13.788 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 11:04:13.788 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:04:13.789 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:04:13.790 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 11:04:13.790 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:04:13.791 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:04:13.792 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 11:04:13.793 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:04:13.794 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:04:13.795 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-17 11:04:13.796 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:04:13.796 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:04:13.797 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 11:04:13.797 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:04:13.798 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:04:13.799 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 11:04:13.799 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:04:13.800 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:04:13.800 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 11:04:13.801 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:04:13.803 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:04:13.805 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 11:04:13.805 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:04:13.806 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:04:13.806 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 11:04:13.807 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:04:13.808 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:04:13.809 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 11:04:13.809 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:04:13.811 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:04:13.813 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 11:04:13.813 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:04:13.814 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:04:13.816 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-17 11:04:13.816 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:04:13.818 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:04:13.819 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 11:04:13.820 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:04:13.821 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:04:13.823 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 11:04:13.824 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:04:13.825 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:04:13.827 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 11:04:13.827 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:04:13.829 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:04:13.831 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 11:04:13.831 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:04:13.833 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:04:13.835 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 11:04:13.836 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:04:13.837 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:04:13.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-17 11:04:13.839 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:04:13.841 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:04:13.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 11:04:13.842 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:04:13.844 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:04:13.846 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 11:04:13.846 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:04:13.847 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:04:13.848 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 11:04:13.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:04:13.850 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:04:13.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 11:04:13.853 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:04:13.854 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:04:13.854 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 11:04:13.855 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:04:13.857 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:04:13.859 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 11:04:13.860 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:04:13.862 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:04:13.865 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-17 11:04:13.865 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:04:13.866 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:04:13.867 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 11:04:13.868 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:04:13.869 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:04:13.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-17 11:04:13.870 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:04:13.871 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:04:13.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-17 11:04:13.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:04:13.873 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:04:13.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-17 11:04:13.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:04:13.875 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:04:13.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-17 11:04:13.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:04:13.876 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:04:13.876 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 11:04:13.877 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:04:13.878 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:04:13.879 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 11:04:13.879 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:04:13.880 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:04:13.880 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 11:04:13.881 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:04:13.881 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:04:13.882 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 11:04:13.883 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:04:13.884 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:04:13.885 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-17 11:04:13.885 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:04:13.886 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:04:13.887 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 11:04:13.888 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:04:13.890 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:04:13.893 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 11:04:13.893 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:04:13.895 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:04:13.897 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-17 11:04:13.898 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:04:13.899 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:04:13.900 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-17 11:04:13.900 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:04:13.901 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:04:13.902 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 11:04:16.050 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 11:09:54.181 | DEBUG    | __main__:algorithm_chat:30 - [message]请提供可以解决区间查询与区间修改的算法
2024-07-17 11:09:54.182 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-17 11:09:54.182 | ERROR    | __main__:algorithm_chat:38 - Error invoking retrieval chain: name 'noiseremoval' is not defined
2024-07-17 11:10:28.553 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 11:10:28.553 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:10:28.555 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:10:28.557 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-17 11:10:28.557 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:10:28.558 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:10:28.559 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-17 11:10:28.559 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:10:28.561 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:10:28.563 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-17 11:10:28.563 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:10:28.564 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:10:28.565 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 11:10:28.566 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:10:28.567 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:10:28.568 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-17 11:10:28.568 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:10:28.569 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:10:28.570 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 11:10:28.571 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:10:28.571 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:10:28.572 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 11:10:28.572 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:10:28.573 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:10:28.573 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 11:10:28.574 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:10:28.575 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:10:28.576 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 11:10:28.576 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:10:28.577 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:10:28.578 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 11:10:28.578 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:10:28.579 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:10:28.580 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 11:10:28.580 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:10:28.580 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:10:28.581 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 11:10:28.581 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:10:28.582 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:10:28.583 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 11:10:28.583 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:10:28.583 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:10:28.584 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 11:10:28.584 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:10:28.585 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:10:28.586 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 11:10:28.586 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:10:28.586 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:10:28.587 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-17 11:10:28.587 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:10:28.588 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:10:28.589 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 11:10:28.590 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:10:28.590 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:10:28.591 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 11:10:28.591 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:10:28.592 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:10:28.592 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 11:10:28.593 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:10:28.593 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:10:28.594 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 11:10:28.594 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:10:28.594 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:10:28.595 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 11:10:28.595 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:10:28.596 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:10:28.597 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-17 11:10:28.597 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:10:28.598 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:10:28.600 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 11:10:28.600 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:10:28.601 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:10:28.602 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 11:10:28.602 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:10:28.603 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:10:28.604 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 11:10:28.604 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:10:28.605 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:10:28.606 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 11:10:28.607 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:10:28.607 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:10:28.608 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 11:10:28.609 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:10:28.610 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:10:28.611 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 11:10:28.611 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:10:28.612 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:10:28.613 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 11:10:28.613 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:10:28.614 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:10:28.615 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-17 11:10:28.615 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:10:28.616 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:10:28.616 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 11:10:28.617 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:10:28.618 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:10:28.619 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 11:10:28.619 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:10:28.620 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:10:28.621 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 11:10:28.621 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:10:28.622 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:10:28.624 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 11:10:28.625 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:10:28.625 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:10:28.626 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 11:10:28.627 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:10:28.627 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:10:28.628 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 11:10:28.628 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:10:28.630 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:10:28.631 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 11:10:28.632 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:10:28.633 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:10:28.634 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-17 11:10:28.634 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:10:28.635 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:10:28.636 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 11:10:28.636 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:10:28.637 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:10:28.639 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 11:10:28.640 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:10:28.641 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:10:28.642 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 11:10:28.643 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:10:28.644 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:10:28.646 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 11:10:28.647 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:10:28.648 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:10:28.650 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 11:10:28.651 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:10:28.652 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:10:28.654 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-17 11:10:28.654 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:10:28.656 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:10:28.657 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 11:10:28.657 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:10:28.660 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:10:28.662 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 11:10:28.662 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:10:28.664 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:10:28.665 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 11:10:28.666 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:10:28.667 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:10:28.669 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 11:10:28.669 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:10:28.671 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:10:28.673 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 11:10:28.674 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:10:28.676 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:10:28.678 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 11:10:28.678 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:10:28.682 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:10:28.684 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-17 11:10:28.684 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:10:28.686 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:10:28.687 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 11:10:28.688 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:10:28.688 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:10:28.690 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-17 11:10:28.690 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:10:28.691 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:10:28.691 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-17 11:10:28.692 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:10:28.692 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:10:28.694 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-17 11:10:28.694 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:10:28.695 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:10:28.696 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-17 11:10:28.696 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:10:28.696 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:10:28.697 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 11:10:28.697 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:10:28.698 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:10:28.699 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 11:10:28.699 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:10:28.700 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:10:28.701 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 11:10:28.702 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:10:28.703 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:10:28.704 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 11:10:28.704 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:10:28.705 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:10:28.706 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-17 11:10:28.706 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:10:28.707 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:10:28.709 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 11:10:28.709 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:10:28.711 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:10:28.713 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 11:10:28.714 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:10:28.716 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:10:28.719 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-17 11:10:28.719 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:10:28.720 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:10:28.721 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-17 11:10:28.721 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:10:28.722 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:10:28.724 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 11:10:30.824 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 11:11:11.502 | DEBUG    | __main__:algorithm_chat:30 - [message]可以处理区间查询和区间修改的算法
2024-07-17 11:11:11.502 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-17 11:11:12.215 | DEBUG    | __main__:algorithm_chat:34 - [message after noise removal]['可以', '处理', '区间', '查询', '区间', '修改', '算法']
2024-07-17 11:11:12.261 | ERROR    | chatbot.algorithm_describe:GetAlgorithmChaoName:83 - Retrieval failed: 'list' object has no attribute 'replace'
2024-07-17 11:11:12.261 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]An error occurred during retrieval
2024-07-17 11:13:32.435 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 11:13:32.436 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:13:32.439 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:13:32.441 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-17 11:13:32.441 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:13:32.442 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:13:32.443 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-17 11:13:32.444 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:13:32.445 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:13:32.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-17 11:13:32.447 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:13:32.448 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:13:32.449 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 11:13:32.450 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:13:32.451 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:13:32.452 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-17 11:13:32.453 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:13:32.454 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:13:32.455 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 11:13:32.455 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:13:32.456 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:13:32.457 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 11:13:32.458 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:13:32.459 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:13:32.461 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 11:13:32.461 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:13:32.462 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:13:32.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 11:13:32.463 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:13:32.464 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:13:32.465 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 11:13:32.466 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:13:32.467 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:13:32.467 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 11:13:32.468 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:13:32.468 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:13:32.469 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 11:13:32.469 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:13:32.469 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:13:32.470 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 11:13:32.470 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:13:32.471 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:13:32.471 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 11:13:32.472 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:13:32.473 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:13:32.474 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 11:13:32.474 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:13:32.475 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:13:32.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-17 11:13:32.475 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:13:32.476 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:13:32.477 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 11:13:32.477 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:13:32.477 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:13:32.479 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 11:13:32.480 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:13:32.480 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:13:32.481 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 11:13:32.482 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:13:32.482 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:13:32.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 11:13:32.483 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:13:32.484 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:13:32.485 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 11:13:32.485 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:13:32.486 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:13:32.488 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-17 11:13:32.489 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:13:32.490 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:13:32.492 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 11:13:32.492 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:13:32.493 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:13:32.494 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 11:13:32.494 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:13:32.495 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:13:32.495 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 11:13:32.496 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:13:32.496 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:13:32.497 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 11:13:32.497 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:13:32.498 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:13:32.499 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 11:13:32.500 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:13:32.501 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:13:32.502 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 11:13:32.502 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:13:32.503 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:13:32.504 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 11:13:32.505 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:13:32.506 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:13:32.507 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-17 11:13:32.508 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:13:32.509 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:13:32.509 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 11:13:32.510 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:13:32.510 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:13:32.511 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 11:13:32.511 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:13:32.512 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:13:32.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 11:13:32.512 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:13:32.514 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:13:32.516 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 11:13:32.516 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:13:32.517 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:13:32.517 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 11:13:32.517 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:13:32.519 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:13:32.520 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 11:13:32.521 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:13:32.522 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:13:32.524 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 11:13:32.524 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:13:32.525 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:13:32.526 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-17 11:13:32.526 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:13:32.527 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:13:32.529 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 11:13:32.529 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:13:32.530 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:13:32.532 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 11:13:32.532 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:13:32.533 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:13:32.535 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 11:13:32.535 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:13:32.537 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:13:32.538 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 11:13:32.538 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:13:32.540 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:13:32.541 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 11:13:32.542 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:13:32.543 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:13:32.545 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-17 11:13:32.545 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:13:32.546 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:13:32.548 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 11:13:32.548 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:13:32.551 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:13:32.553 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 11:13:32.553 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:13:32.554 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:13:32.556 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 11:13:32.556 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:13:32.559 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:13:32.561 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 11:13:32.561 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:13:32.564 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:13:32.566 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 11:13:32.567 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:13:32.568 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:13:32.571 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 11:13:32.571 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:13:32.573 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:13:32.576 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-17 11:13:32.576 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:13:32.577 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:13:32.579 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 11:13:32.579 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:13:32.580 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:13:32.581 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-17 11:13:32.581 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:13:32.582 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:13:32.583 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-17 11:13:32.583 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:13:32.584 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:13:32.586 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-17 11:13:32.586 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:13:32.586 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:13:32.587 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-17 11:13:32.587 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:13:32.587 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:13:32.588 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 11:13:32.589 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:13:32.589 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:13:32.590 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 11:13:32.591 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:13:32.591 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:13:32.592 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 11:13:32.593 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:13:32.594 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:13:32.595 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 11:13:32.595 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:13:32.595 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:13:32.596 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-17 11:13:32.596 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:13:32.598 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:13:32.599 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 11:13:32.600 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:13:32.602 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:13:32.604 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 11:13:32.605 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:13:32.607 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:13:32.610 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-17 11:13:32.610 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:13:32.611 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:13:32.612 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-17 11:13:32.613 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:13:32.614 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:13:32.615 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 11:13:34.756 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 11:14:34.115 | DEBUG    | __main__:algorithm_chat:30 - [message]可以区间修改并且也可以区间查询的算法
2024-07-17 11:14:34.115 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-17 11:14:34.800 | DEBUG    | __main__:algorithm_chat:34 - [message after noise removal]可以区间修改可以区间查询算法
2024-07-17 11:14:36.037 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n线段树（区间修改）\n过程:\n节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。\n核心功能:\neval 函数: 更新当前节点的值，考虑到乘法和加法的影响。\npushup 函数: 更新父节点的和，基于子节点的和。\npushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。\nbuild 函数: 构建线段树，初始化区间。\nmodify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。\nquery 函数: 查询给定区间的和，同时处理懒惰更新。\n\n应用场景: \n线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。\n线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。\n\n时间复杂度:\n建树: O(n)\n修改: O(logn)（使用懒惰标记）\n查询: O(logn)\n此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。\n\n[回答]\n(线段树区间修改)')]
2024-07-17 11:14:36.038 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](线段树区间修改)
2024-07-17 11:14:37.273 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]64
2024-07-17 11:14:37.274 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:15:09.538 | DEBUG    | chatbot.chatbot:GetResult:52 - [result]这段代码看起来是一个基于线段树的数据结构实现，用于处理区间的乘法和加法更新，以及区间求和查询。下面我将重新排版这段代码，并逐行添加注释以便理解。

```cpp
#include <bits/stdc++.h> // Include this header for using the data types like ll (long long)

using namespace std;

const int N = 1e5 + 10; // Assuming N is the maximum number of elements in the array, adjust as necessary
const int p = 1e9 + 7;  // Assuming p is the modulo for calculations, adjust as necessary

// Segment tree node structure
struct node {
    int l, r;            // Segment [l, r] that this node represents
    long long sum;       // Sum of the segment
    long long add;       // Pending addition to be applied to the segment
    long long mul;       // Pending multiplication to be applied to the segment
} tr[4 * N]; // Segment tree array

// Apply the pending addition and multiplication to the node
void eval(node &root, int add, int mul) {
    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;
    root.mul = root.mul * mul % p;
    root.add = (root.add * mul + add) % p;
}

// Merge the information from the children nodes to the parent node
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p;
}

// Push down the pending operations to the children nodes
void pushdown(int u) {
    eval(tr[u << 1], tr[u].add, tr[u].mul);
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul);
    tr[u].add = 0; // Clear the pending operations from the current node
    tr[u].mul = 1; // Reset multiplication to identity
}

// Build the segment tree
void build(int u, int l, int r) {
    if (l == r) {
        // Leaf node represents a single element
        tr[u] = {l, r, w[r], 0, 1}; // Assuming w[] is the input array
    } else {
        // Interior node represents a segment
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1; // Divide by 2, assuming the segment is split evenly
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u); // Merge the children's information
    }
}

// Modify the segment tree by applying addition and multiplication to a range
void modify(int u, int l, int r, int add, int mul) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // The current segment is completely inside the query range
        eval(tr[u], add, mul);
    } else {
        // The current segment is partially inside the query range
        pushdown(u); // Push down the pending operations to children
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u); // Merge the children's information
    }
}

// Query the segment tree for the sum of a range
node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // The current segment is completely inside the query range
        return tr[u];
    } else {
        // The current segment is partially inside the query range
        pushdown(u); // Push down the pending operations to children
        node res = {0, 0, 0, 0, 1}; // Initialize the result node
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;
        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;
        return res; // Return the result
    }
}
```

请注意，代码中的`w[]`数组是未定义的，它应该是输入数组，包含了原始的数据，用于初始化线段树的叶子节点。此外，由于代码中没有定义`ll`类型，我假设它是`long long`的简写，因此包含了`<
2024-07-17 11:24:11.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 11:24:11.834 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:24:11.836 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 11:24:11.838 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-17 11:24:11.838 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:24:11.839 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 11:24:11.840 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-17 11:24:11.841 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:24:11.842 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 11:24:11.843 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-17 11:24:11.844 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:24:11.845 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 11:24:11.847 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 11:24:11.847 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:24:11.848 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 11:24:11.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-17 11:24:11.849 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:24:11.850 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:24:11.851 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 11:24:11.852 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:24:11.852 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 11:24:11.853 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 11:24:11.853 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:24:11.854 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 11:24:11.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 11:24:11.856 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:24:11.857 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:24:11.858 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 11:24:11.858 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:24:11.859 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 11:24:11.869 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 11:24:11.869 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:24:11.870 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 11:24:11.871 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 11:24:11.871 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:24:11.872 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 11:24:11.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 11:24:11.872 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:24:11.873 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 11:24:11.873 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 11:24:11.874 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:24:11.874 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 11:24:11.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 11:24:11.875 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:24:11.876 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 11:24:11.877 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 11:24:11.877 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:24:11.878 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 11:24:11.898 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-17 11:24:11.905 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:24:11.907 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 11:24:11.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 11:24:11.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:24:11.910 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 11:24:11.912 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 11:24:11.913 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:24:11.916 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 11:24:11.917 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 11:24:11.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:24:11.919 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 11:24:11.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 11:24:11.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:24:11.923 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 11:24:11.924 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 11:24:11.925 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:24:11.926 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 11:24:11.927 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-17 11:24:11.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:24:11.929 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 11:24:11.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 11:24:11.931 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:24:11.932 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 11:24:11.933 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 11:24:11.933 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:24:11.934 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 11:24:11.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 11:24:11.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:24:11.935 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 11:24:11.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 11:24:11.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:24:11.937 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 11:24:11.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 11:24:11.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:24:11.940 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 11:24:11.941 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 11:24:11.941 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:24:11.942 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 11:24:11.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 11:24:11.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:24:11.944 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 11:24:11.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-17 11:24:11.946 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:24:11.946 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 11:24:11.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 11:24:11.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:24:11.948 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:24:11.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 11:24:11.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:24:11.950 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 11:24:11.950 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 11:24:11.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:24:11.952 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 11:24:11.954 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 11:24:11.954 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:24:11.955 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 11:24:11.956 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 11:24:11.956 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:24:11.957 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 11:24:11.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 11:24:11.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:24:11.959 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 11:24:11.961 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 11:24:11.962 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:24:11.962 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 11:24:11.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-17 11:24:11.964 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:24:11.964 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 11:24:11.965 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 11:24:11.966 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:24:11.968 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 11:24:11.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 11:24:11.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:24:11.971 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:24:11.973 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 11:24:11.973 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:24:11.975 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 11:24:11.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 11:24:11.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:24:11.978 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 11:24:11.980 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 11:24:11.980 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:24:11.982 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 11:24:11.983 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-17 11:24:11.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:24:11.985 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 11:24:11.986 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 11:24:11.987 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:24:11.990 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 11:24:11.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 11:24:11.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:24:11.993 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 11:24:11.995 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 11:24:11.995 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:24:11.998 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 11:24:12.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 11:24:12.000 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:24:12.003 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 11:24:12.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 11:24:12.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:24:12.007 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 11:24:12.009 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 11:24:12.009 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:24:12.012 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 11:24:12.015 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-17 11:24:12.015 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:24:12.017 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 11:24:12.018 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 11:24:12.018 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:24:12.019 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 11:24:12.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-17 11:24:12.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:24:12.021 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 11:24:12.023 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-17 11:24:12.023 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:24:12.024 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 11:24:12.025 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-17 11:24:12.025 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:24:12.026 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 11:24:12.027 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-17 11:24:12.027 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:24:12.027 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 11:24:12.028 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 11:24:12.028 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:24:12.029 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 11:24:12.030 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 11:24:12.030 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:24:12.031 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 11:24:12.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 11:24:12.032 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:24:12.033 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 11:24:12.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 11:24:12.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:24:12.035 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 11:24:12.036 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-17 11:24:12.037 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:24:12.038 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 11:24:12.039 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 11:24:12.039 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:24:12.041 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 11:24:12.044 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 11:24:12.045 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:24:12.047 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 11:24:12.049 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-17 11:24:12.050 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:24:12.051 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 11:24:12.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-17 11:24:12.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:24:12.053 | DEBUG    | sql.mysql:Insert_Data:41 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 11:24:12.054 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 11:24:14.234 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 11:25:04.022 | DEBUG    | __main__:algorithm_chat:30 - [message]我想要一个可以得到最近比自身值大的算法
2024-07-17 11:25:04.023 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-17 11:25:04.709 | DEBUG    | __main__:algorithm_chat:34 - [message after noise removal]一个得到比自身值大算法
2024-07-17 11:25:09.738 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n该算法使用位运算来实现快速的加法计算，以应对大数乘法的问题。通过不断地将加数 a 左移（相当于乘以 2）并逐步减少乘数 b，可以有效地计算出 (a * b) % p。这是一种通过分解问题来提高效率的方法。\n\n应用场景: \n适合在处理需要大数相乘的场合，特别是当数值范围超出常规数据类型限制时，比如在大数计算、密码学、数论等领域，能够有效避免溢出问题。\n\n时间复杂度: \n时间复杂度为 O(logb)，其中 b 是乘数，效率较高。\n\n[回答]\n(位运算处理大数相乘)')]
2024-07-17 11:25:09.739 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]对不起，您提供的信息不足以直接回答您的新问题。不过，根据您之前提供的内容，如果您的意思是询问如何使用位运算来处理大数相乘以得到比自身值大的结果，可以参考以下答案：

(通过位运算处理大数相乘来得到比自身值大的结果)

但是，如果需要具体的算法或代码示例来实现这一目的，我需要更多的上下文信息。通常，位运算在大数相乘中用于提高效率和避免溢出，但如果要得到比自身值大的结果，可能涉及到特定的数学操作或逻辑。请提供更多的细节，以便我能够给出更准确的回答。
2024-07-17 11:25:11.595 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]38
2024-07-17 11:25:11.595 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 11:25:25.682 | DEBUG    | chatbot.chatbot:GetResult:52 - [result]下面是重新排版并添加了逐行注释的代码。这段代码实现了快速幂算法，可以在\(O(\log b)\)的时间复杂度内计算出\(a^b \mod p\)的值。

```cpp
// 定义快速幂函数，计算 (a^b) % p
long long quick_add(long long a, long long b, long long p) {
    // 初始化结果为0
    long long res = 0;

    // 当b不为0时循环
    while (b) {
        // 如果b的当前最低位是1，那么将a累加到结果中（并取模p）
        if (b & 1) {
            res = (res + a) % p; // 累加a，并保持结果在p的模意义下
        }

        // a自乘（并取模p），为下一次幂运算做准备
        a = (a + a) % p; // a *= 2，并保持a在p的模意义下

        // b右移一位，相当于b /= 2
        b >>= 1; // 更新b的值，进行下一轮循环
    }

    // 返回计算结果
    return res;
}
```

注释说明：
- `long long`：64位整数类型，用于存储较大的整数值。
- `quick_add`：函数名，用于计算快速幂。
- `a`：底数。
- `b`：指数。
- `p`：模数。
- `% p`：取模运算，确保结果在模p的意义下计算，防止整数溢出。
- `b >>= 1`：位运算中的右移操作，等价于`b = b / 2`。在这里，它用来将指数b减半，以实现快速幂算法。
2024-07-17 11:26:47.339 | DEBUG    | __main__:algorithm_chat:30 - [message]我想要可以找到每个元素左边离它最近的比它大或小的元素的算法
2024-07-17 11:26:47.340 | DEBUG    | __main__:algorithm_chat:31 - [history][['我想要一个可以得到最近比自身值大的算法', '下面是重新排版并添加了逐行注释的代码。这段代码实现了快速幂算法，可以在\\(O(\\log b)\\)的时间复杂度内计算出\\(a^b \\mod p\\)的值。\n\n```cpp\n// 定义快速幂函数，计算 (a^b) % p\nlong long quick_add(long long a, long long b, long long p) {\n    // 初始化结果为0\n    long long res = 0;\n\n    // 当b不为0时循环\n    while (b) {\n        // 如果b的当前最低位是1，那么将a累加到结果中（并取模p）\n        if (b & 1) {\n            res = (res + a) % p; // 累加a，并保持结果在p的模意义下\n        }\n\n        // a自乘（并取模p），为下一次幂运算做准备\n        a = (a + a) % p; // a *= 2，并保持a在p的模意义下\n\n        // b右移一位，相当于b /= 2\n        b >>= 1; // 更新b的值，进行下一轮循环\n    }\n\n    // 返回计算结果\n    return res;\n}\n```\n\n注释说明：\n- `long long`：64位整数类型，用于存储较大的整数值。\n- `quick_add`：函数名，用于计算快速幂。\n- `a`：底数。\n- `b`：指数。\n- `p`：模数。\n- `% p`：取模运算，确保结果在模p的意义下计算，防止整数溢出。\n- `b >>= 1`：位运算中的右移操作，等价于`b = b / 2`。在这里，它用来将指数b减半，以实现快速幂算法。']]
2024-07-17 11:26:47.341 | DEBUG    | __main__:algorithm_chat:34 - [message after noise removal]找到每个元素左边离比大小元素算法
2024-07-17 11:26:58.564 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n该算法通过维护一个距离数组 dist，初始时将所有距离设为无穷大（0x3f3f3f3f），然后逐步更新从起点到每个节点的最短距离。每次选择未处理的节点中距离最小的节点 t，并更新与其相连的其他节点的距离。该过程重复 n-1 次，直到所有节点的最短路径被计算完成。\n\n应用场景: \n朴素版 Dijkstra 算法适用于计算图中单源最短路径的场景，如地图路径规划、网络路由、物流配送等。它在点数和边数较小的情况下表现良好。\n\n时间复杂度: 该算法的时间复杂度为 \nO(n^2+m)，其中 n 为图中的节点数，m 为边数。由于使用了简单的循环查找最小距离节点的方法，因此在节点数较大时效率较低，不适合密集图。\n\n[回答]\n(朴素版Dijkstra算法)')]
2024-07-17 11:26:58.565 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]在您提供的内容中，没有直接提到“找到每个元素左边离比它小的元素”的算法。然而，根据您的问题描述，这听起来像是数据结构中的一类问题，可能可以通过二叉搜索树、线段树或是树状数组等数据结构来解决。

但是，如果要用类似的思路来回答，我们可以考虑一种简单的线性搜索方法，这在一定程度上与朴素版 Dijkstra 算法中查找最小距离节点的思想相似。以下是解决您描述问题的朴素方法：

对于数组 `arr[]` 中的每个元素，找到它左边第一个比它小的元素的索引。

```
[问题]
过程:
对于数组中的每个元素，从数组的开始位置向当前元素的位置进行遍历，记录下遇到的所有小于当前元素值的元素的索引。这样，对于每个元素，我们都能找到它左边离它最近的比它小的元素的索引。

应用场景:
这类问题常见于某些排序算法的优化（比如快速排序中的partition过程），或者在处理某些特定动态规划问题时。

时间复杂度:
该算法的时间复杂度为 O(n^2)，其中 n 是数组的长度。这是因为它需要对每个元素执行一次线性搜索。

[回答]
(朴素方法)
```

但请注意，这个问题通常可以用更高效的算法来解决，比如通过构建一个索引平衡树（例如，通过二叉搜索树或红黑树）来降低时间复杂度到 O(n log n)。这种数据结构可以在 O(log n) 的时间内找到每个元素左边比它小的最近的元素。
2024-07-17 11:26:59.980 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]47
2024-07-17 11:26:59.981 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 11:27:21.617 | DEBUG    | chatbot.chatbot:GetResult:52 - [result]这段代码看起来是一个SPFA（Shortest Path Faster Algorithm）算法的实现，用于在加权图中寻找最短路径。下面我将重新排版这段代码，并加上逐行注释以便理解。

```cpp
void spfa() {
    int hh = 0, tt = 0; // 初始化队头和队尾指针

    // 初始化距离数组，所有顶点到源点的距离设为无穷大
    for (int i = 1; i <= n; i++) 
        dist[i] = INF;

    // 源点（通常是顶点1）到自身的距离设为0
    dist[1] = 0;

    // 将源点加入队列
    q[tt++] = 1; 
    st[1] = 1; // 标记源点在队列中

    // 当队列不为空时继续执行
    while (hh != tt) {
        int t = q[hh++]; // 获取队列中的下一个顶点
        st[t] = 0; // 标记顶点t不在队列中

        // 如果队头指针到达数组末尾，将其重置为0，实现循环队列
        if (hh == n) 
            hh = 0;

        // 遍历顶点t的所有邻接边
        for (int i = h[t]; i != -1; i = ne[i]) {
            // 如果通过顶点t到达顶点e[i]的距离更短
            if (dist[e[i]] > dist[t] + v[i]) {
                dist[e[i]] = dist[t] + v[i]; // 更新顶点e[i]的最短距离

                // 如果顶点e[i]不在队列中，将其加入队列
                if (!st[e[i]]) {
                    st[e[i]] = 1; // 标记顶点e[i]在队列中
                    q[tt++] = e[i]; // 将顶点e[i]加入队列

                    // 如果队尾指针到达数组末尾，将其重置为0，实现循环队列
                    if (tt == n) 
                        tt = 0;
                }
            }
        }
    }
}
```

注释说明：
- `dist[]`：存储从源点到各个顶点的最短距离。
- `q[]`：用于SPFA算法的队列，存储待处理的顶点。
- `st[]`：标记数组，表示顶点是否在队列中。
- `h[]`、`e[]`、`ne[]`、`v[]`：分别表示邻接表的顶点头指针、边的终点、边的下一个边和边的权重。
- `n`：顶点的数量。
- `INF`：表示无穷大的常量。

请注意，代码中的一些变量（如`h[]`、`e[]`、`ne[]`等）没有定义，它们应该是作为全局变量在其他地方定义的。此外，`n`和`INF`也应该是全局定义的常量。
2024-07-17 13:06:55.908 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 13:06:55.909 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 13:06:55.910 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 13:06:55.913 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速排序
2024-07-17 13:06:55.913 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 13:06:55.914 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 13:06:55.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]归并排序
2024-07-17 13:06:55.915 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 13:06:55.916 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 13:06:55.917 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数二分
2024-07-17 13:06:55.918 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 13:06:55.919 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 13:06:55.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 13:06:55.921 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 13:06:55.922 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 13:06:55.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]整数三分
2024-07-17 13:06:55.923 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 13:06:55.924 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 13:06:55.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 13:06:55.926 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 13:06:55.927 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 13:06:55.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 13:06:55.928 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 13:06:55.929 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 13:06:55.930 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 13:06:55.930 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 13:06:55.931 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 13:06:55.932 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 13:06:55.932 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 13:06:55.933 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 13:06:55.934 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 13:06:55.935 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 13:06:55.935 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 13:06:55.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 13:06:55.936 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 13:06:55.936 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 13:06:55.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 13:06:55.937 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 13:06:55.938 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 13:06:55.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 13:06:55.939 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 13:06:55.939 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 13:06:55.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 13:06:55.940 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 13:06:55.941 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 13:06:55.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 13:06:55.942 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 13:06:55.943 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 13:06:55.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]RMQ
2024-07-17 13:06:55.943 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 13:06:55.944 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 13:06:55.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 13:06:55.945 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 13:06:55.945 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 13:06:55.947 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 13:06:55.948 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 13:06:55.948 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 13:06:55.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 13:06:55.949 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 13:06:55.950 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 13:06:55.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 13:06:55.951 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 13:06:55.951 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 13:06:55.952 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 13:06:55.952 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 13:06:55.954 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 13:06:55.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Min_25
2024-07-17 13:06:55.955 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 13:06:55.956 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 13:06:55.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 13:06:55.958 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 13:06:55.959 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 13:06:55.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 13:06:55.960 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 13:06:55.961 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 13:06:55.962 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 13:06:55.962 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 13:06:55.963 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 13:06:55.963 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 13:06:55.964 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 13:06:55.964 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 13:06:55.965 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 13:06:55.966 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 13:06:55.966 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 13:06:55.967 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 13:06:55.968 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 13:06:55.969 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 13:06:55.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 13:06:55.970 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 13:06:55.971 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 13:06:55.972 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]快速幂
2024-07-17 13:06:55.972 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 13:06:55.973 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 13:06:55.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 13:06:55.974 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 13:06:55.975 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 13:06:55.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 13:06:55.976 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 13:06:55.976 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 13:06:55.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 13:06:55.977 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 13:06:55.979 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 13:06:55.980 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 13:06:55.980 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 13:06:55.981 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 13:06:55.982 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 13:06:55.982 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 13:06:55.983 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 13:06:55.984 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 13:06:55.985 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 13:06:55.986 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 13:06:55.987 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 13:06:55.987 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 13:06:55.988 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 13:06:55.990 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树的直径
2024-07-17 13:06:55.990 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 13:06:55.991 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 13:06:55.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 13:06:55.992 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 13:06:55.993 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 13:06:55.995 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 13:06:55.995 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 13:06:55.997 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 13:06:55.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 13:06:55.998 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 13:06:55.999 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 13:06:56.001 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 13:06:56.001 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 13:06:56.003 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 13:06:56.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 13:06:56.005 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 13:06:56.006 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 13:06:56.008 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]prim算法
2024-07-17 13:06:56.008 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 13:06:56.010 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 13:06:56.012 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 13:06:56.012 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 13:06:56.014 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 13:06:56.017 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 13:06:56.017 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 13:06:56.019 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 13:06:56.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 13:06:56.020 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 13:06:56.022 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 13:06:56.025 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 13:06:56.026 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 13:06:56.027 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 13:06:56.029 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 13:06:56.030 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 13:06:56.031 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 13:06:56.033 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 13:06:56.034 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 13:06:56.036 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 13:06:56.039 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]二分图
2024-07-17 13:06:56.039 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 13:06:56.040 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 13:06:56.042 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 13:06:56.042 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 13:06:56.043 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 13:06:56.045 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单链表
2024-07-17 13:06:56.045 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 13:06:56.046 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 13:06:56.047 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]双链表
2024-07-17 13:06:56.047 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 13:06:56.048 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 13:06:56.049 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调栈
2024-07-17 13:06:56.049 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 13:06:56.049 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 13:06:56.050 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]单调队列
2024-07-17 13:06:56.050 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 13:06:56.051 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 13:06:56.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 13:06:56.052 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 13:06:56.052 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 13:06:56.053 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 13:06:56.053 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 13:06:56.054 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 13:06:56.055 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 13:06:56.055 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 13:06:56.056 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 13:06:56.057 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 13:06:56.057 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 13:06:56.058 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 13:06:56.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]KMP
2024-07-17 13:06:56.059 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 13:06:56.060 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 13:06:56.061 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 13:06:56.061 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 13:06:56.063 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 13:06:56.066 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 13:06:56.066 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 13:06:56.068 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 13:06:56.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]树状数组
2024-07-17 13:06:56.071 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 13:06:56.072 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 13:06:56.073 | DEBUG    | sql.local_to_db:CodeLocalToDB:46 - [algorithm_name]Trie树
2024-07-17 13:06:56.073 | DEBUG    | sql.local_to_db:CodeLocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 13:06:56.074 | DEBUG    | sql.mysql:Insert_Data:42 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 13:06:56.075 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 13:06:58.175 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 13:26:43.583 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 13:27:39.765 | DEBUG    | __main__:algorithm_chat:30 - [message]时间复杂度为O(nlogn)的排序算法
2024-07-17 13:27:39.765 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-17 13:27:40.474 | DEBUG    | __main__:algorithm_chat:34 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 13:27:44.067 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 13:27:44.068 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](快速排序)
2024-07-17 13:27:45.126 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]8
2024-07-17 13:27:45.127 | ERROR    | chatbot.algorithm_code:GetAlgorithmCode:83 - Retrieval failed: tuple index out of range
2024-07-17 13:32:20.026 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 13:32:46.506 | DEBUG    | __main__:algorithm_chat:30 - [message]间复杂度为Onlogn排序算法
2024-07-17 13:32:46.506 | DEBUG    | __main__:algorithm_chat:31 - [history][]
2024-07-17 13:32:47.208 | DEBUG    | __main__:algorithm_chat:34 - [message after noise removal]间复杂度为Onlogn排序算法
2024-07-17 13:32:56.420 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 13:32:56.421 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]快速排序（Quick Sort）是一种时间复杂度为 O(n log n) 的排序算法。它采用了分治策略，将大问题分解为小问题来处理。具体而言，快速排序通过选择一个“枢轴”（pivot）元素，然后将数组分为两部分：一部分的所有元素都不大于枢轴，另一部分的所有元素都不小于枢轴。这个过程称为“划分”（partitioning）。之后，递归地对这两部分进行快速排序。

在平均情况下，快速排序每次大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)，因此它的时间复杂度为 O(n log n)。尽管在最坏情况下时间复杂度会退化到 O(n^2)，但通过随机化枢轴选择或使用如“三数取中”的技巧，可以避免最坏情况的发生，使得算法在实际应用中表现良好。

快速排序因其高效性和在许多实际应用中的适用性而被广泛使用，例如数据库查询优化、计算机图形学中的图像处理、大规模数据的排序等。
2024-07-17 13:32:57.818 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]8
2024-07-17 13:32:57.818 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 13:33:13.524 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组只有一个元素或者没有元素，直接返回
    if (l >= r) return;

    // 初始化变量i和j，i指向左边界前一个位置，j指向右边界后一个位置
    // x为子数组的中间元素，用于作为基准值
    int i = l - 1, j = r + 1, x = q[l + r >> 1]; // 使用位运算符计算中点，等同于(l + r) / 2

    // 使用两个do-while循环进行分割操作，直到i和j相遇
    while (i < j) {
        // 向右移动i，直到找到大于等于x的元素
        do i ++; while (q[i] < x);
        // 向左移动j，直到找到小于等于x的元素
        do j --; while (q[j] > x);
        // 如果i仍然小于j，交换这两个位置的元素，保证左边的元素都小于x，右边的元素都大于x
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左子数组和右子数组进行快速排序
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：提供的代码中缺少了`swap`函数的实现。我假设这个函数是存在的，并且它接受两个整数的引用，交换它们的值。

此外，代码使用了C++风格的注释（`//`），但实际上这段代码看起来像是C语言风格的代码，因为使用了C语言的数组声明方式和位运算符来计算中点。如果需要在C++中编译，确保包含`<algorithm>`头文件并在需要使用`swap`函数的地方加上`using namespace std;`，或者使用`std::swap`。
2024-07-17 14:11:12.550 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:11:55.789 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:11:55.791 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:11:56.484 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:11:59.737 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:11:59.738 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](快速排序)是一种时间复杂度为O(n log n)的排序算法。
2024-07-17 14:12:01.094 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]8
2024-07-17 14:12:01.095 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:12:17.912 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]这段代码是一个快速排序（Quick Sort）算法的实现，但是它的排版和可读性不是很高。下面我将重新排版这段代码，并逐行添加注释以便理解：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界索引大于等于右边界索引，说明子数组已经排序完毕，直接返回
    if (l >= r) return;

    // 初始化变量，i和j是左右扫描指针，x是子数组的中间值用于分区
    int i = l - 1, j = r + 1, x = q[(l + r) / 2]; // 注意：原代码使用了位运算符>>，这里使用/进行除法

    // 当左指针i小于右指针j时，执行以下循环
    while (i < j) {
        // 向右移动i直到找到一个大于等于x的元素
        do i++; while (q[i] < x);
        // 向左移动j直到找到一个小于等于x的元素
        do j--; while (q[j] > x);
        // 如果i小于j，交换两个元素的位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归对左侧子数组进行快速排序，然后对右侧子数组进行快速排序
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

// 交换两个元素的位置的辅助函数，此函数在代码中未定义，需要自行实现
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}
```

请注意，`swap` 函数并未在提供的代码片段中给出，但是根据上下文，我们知道需要这样一个函数来交换两个元素的值。这里我给出了一个简单的实现。

此外，原代码中使用了位运算符 `>>` 来计算中位数索引，这在大多数情况下是正确的，但是当 `l + r` 的结果超过整数范围时可能会导致问题。为了安全起见，我使用了标准的除法运算符 `/`。
2024-07-17 14:12:17.914 | ERROR    | __main__:algorithm_chat:42 - Insert failed
2024-07-17 14:16:59.462 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
有向图的强连通分量:1
__int128读写模板子:2
无向图的点双连通分量:3
二分图:4
匈牙利算法:5
单链表:6
双链表:7
快速排序:8
归并排序:9
整数二分:10
浮点数二分:11
整数三分:12
浮点数三分:13
高精度加法:14
高精度减法:15
高精度乘低精度:16
高精度除以低精度:17
子矩阵的和:18
差分矩阵:19
双指针算法:20
数据离散化_保序离散化:21
数据离散化_非保序离散化:22
RMQ:23
试除法判定质数:24
试除法分解质因数:25
朴素素数筛法:26
线性素数筛法:27
区间素数筛法:28
Min_25:29
试除法求约数:30
欧几里得算法:31
欧拉函数:32
筛法求欧拉函数:33
卡特兰数求模:34
快速求第n位卡特兰数:35
Java大数打表卡特兰数:36
快速幂:37
位运算处理大数相乘:38
扩展欧几里得算法:39
高斯消元:40
递归法求组合数:41
预处理逆元的方式求组合数:42
Lucas定理:43
有向图的拓扑序:44
树的直径:45
堆优化版Dijkstra:46
朴素版spfa:47
SFA优化版的spfa:48
SPFA判负环正环:49
loyd算法 O(n^3):50
prim算法:51
kruskal算法:52
最小生成森林:53
倍增在线算法:54
targin离线算法:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:17:24.671 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:17:24.673 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:17:25.871 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:17:29.151 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:17:29.151 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](快速排序)
2024-07-17 14:17:30.180 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]8
2024-07-17 14:17:30.180 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:17:43.970 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]以下是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组只有一个元素或为空，无需排序直接返回
    if (l >= r) return;

    // 初始化变量
    int i = l - 1; // 左指针，从左边开始向右移动
    int j = r + 1; // 右指针，从右边开始向左移动
    int x = q[(l + r) / 2]; // 选择中位数作为基准值

    // 进行分割操作，直到左指针超过右指针
    while (i < j) {
        // 移动左指针直到找到一个大于或等于基准值的元素
        do i++; while (q[i] < x);
        // 移动右指针直到找到一个小于或等于基准值的元素
        do j--; while (q[j] > x);
        // 如果左指针仍然在右指针左边，交换两个元素
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

请注意，我假设存在一个名为 `swap` 的函数用于交换两个元素，因为在原代码中没有包含这个函数的实现。如果原代码中没有提供这个函数，那么你还需要实现这个 `swap` 函数。

另外，我注意到原始代码中的条件判断 `if (l >= r)` 在某些快速排序的实现中可能不会出现，因为通常这部分逻辑包含在递归调用的终止条件中。如果 `l` 和 `r` 是相邻或相同，则递归会自然终止。但是，我在这里保留了这一行，因为它是原始代码的一部分。
2024-07-17 14:17:43.971 | DEBUG    | __main__:algorithm_chat:38 - [result]以下是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组只有一个元素或为空，无需排序直接返回
    if (l >= r) return;

    // 初始化变量
    int i = l - 1; // 左指针，从左边开始向右移动
    int j = r + 1; // 右指针，从右边开始向左移动
    int x = q[(l + r) / 2]; // 选择中位数作为基准值

    // 进行分割操作，直到左指针超过右指针
    while (i < j) {
        // 移动左指针直到找到一个大于或等于基准值的元素
        do i++; while (q[i] < x);
        // 移动右指针直到找到一个小于或等于基准值的元素
        do j--; while (q[j] > x);
        // 如果左指针仍然在右指针左边，交换两个元素
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

请注意，我假设存在一个名为 `swap` 的函数用于交换两个元素，因为在原代码中没有包含这个函数的实现。如果原代码中没有提供这个函数，那么你还需要实现这个 `swap` 函数。

另外，我注意到原始代码中的条件判断 `if (l >= r)` 在某些快速排序的实现中可能不会出现，因为通常这部分逻辑包含在递归调用的终止条件中。如果 `l` 和 `r` 是相邻或相同，则递归会自然终止。但是，我在这里保留了这一行，因为它是原始代码的一部分。
[statue]1
[id]8
2024-07-17 14:17:43.973 | ERROR    | __main__:algorithm_chat:47 - Error invoking retrieval chain: no such column: result
2024-07-17 14:19:17.213 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:19:17.214 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:19:17.215 | DEBUG    | sql.mysql:Insert_Data_name_and_id:47 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:22:27.509 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:22:27.510 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:22:27.511 | DEBUG    | sql.mysql:Insert_Data_name_and_id:48 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:24:23.178 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:24:23.178 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:24:23.180 | DEBUG    | sql.mysql:Insert_Data_name_and_id:48 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:26:45.662 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:26:45.663 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:26:45.664 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:27:02.740 | DEBUG    | sql.mysql:__init__:25 - 建立表成功
2024-07-17 14:27:02.746 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:27:02.747 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:27:02.748 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:27:02.751 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速排序
2024-07-17 14:27:02.751 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:27:02.752 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:27:02.756 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]归并排序
2024-07-17 14:27:02.756 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:27:02.757 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:27:02.761 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数二分
2024-07-17 14:27:02.761 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:27:02.762 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:27:02.765 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 14:27:02.766 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:27:02.767 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:27:02.770 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数三分
2024-07-17 14:27:02.770 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:27:02.771 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:27:02.775 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 14:27:02.775 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:27:02.776 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:27:02.779 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 14:27:02.780 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:27:02.781 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:27:02.784 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 14:27:02.785 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:27:02.786 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:27:02.789 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 14:27:02.790 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:27:02.790 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:27:02.793 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 14:27:02.794 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:27:02.796 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:27:02.799 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 14:27:02.799 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:27:02.800 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:27:02.803 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 14:27:02.804 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:27:02.805 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:27:02.808 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 14:27:02.808 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:27:02.809 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:27:02.812 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 14:27:02.813 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:27:02.814 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:27:02.818 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 14:27:02.818 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:27:02.819 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:27:02.822 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]RMQ
2024-07-17 14:27:02.823 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:27:02.825 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:27:02.828 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 14:27:02.829 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:27:02.830 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:27:02.833 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 14:27:02.833 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:27:02.835 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:27:02.838 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 14:27:02.839 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:27:02.839 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:27:02.843 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 14:27:02.844 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:27:02.846 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:27:02.849 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 14:27:02.850 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:27:02.851 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:27:02.855 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Min_25
2024-07-17 14:27:02.856 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:27:02.859 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:27:02.863 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 14:27:02.863 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:27:02.864 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:27:02.868 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 14:27:02.869 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:27:02.869 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:27:02.873 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 14:27:02.873 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:27:02.874 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:27:02.878 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 14:27:02.879 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:27:02.880 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:27:02.884 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 14:27:02.884 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:27:02.886 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:27:02.889 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 14:27:02.890 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:27:02.891 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:27:02.895 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 14:27:02.895 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:27:02.896 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:27:02.900 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速幂
2024-07-17 14:27:02.901 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:27:02.902 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:27:02.905 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 14:27:02.906 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:27:02.907 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:27:02.911 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 14:27:02.911 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:27:02.912 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:27:02.916 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 14:27:02.916 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:27:02.918 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:27:02.922 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 14:27:02.922 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:27:02.923 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:27:02.927 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 14:27:02.928 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:27:02.929 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:27:02.933 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 14:27:02.934 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:27:02.936 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:27:02.940 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 14:27:02.941 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:27:02.942 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:27:02.946 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树的直径
2024-07-17 14:27:02.947 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:27:02.948 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:27:02.951 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 14:27:02.952 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:27:02.953 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:27:02.957 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 14:27:02.958 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:27:02.959 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:27:02.963 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 14:27:02.963 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:27:02.964 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:27:02.990 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 14:27:02.992 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:27:02.998 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:27:03.002 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 14:27:03.003 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:27:03.005 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:27:03.010 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]prim算法
2024-07-17 14:27:03.010 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:27:03.012 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:27:03.017 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 14:27:03.017 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:27:03.019 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:27:03.023 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 14:27:03.024 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:27:03.025 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:27:03.028 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 14:27:03.029 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:27:03.031 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:27:03.035 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 14:27:03.036 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:27:03.038 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:27:03.042 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 14:27:03.042 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:27:03.045 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:27:03.050 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 14:27:03.051 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:27:03.054 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:27:03.060 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]二分图
2024-07-17 14:27:03.061 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:27:03.063 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:27:03.067 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 14:27:03.068 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:27:03.070 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:27:03.074 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单链表
2024-07-17 14:27:03.074 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:27:03.076 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:27:03.079 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双链表
2024-07-17 14:27:03.079 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:27:03.081 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:27:03.085 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调栈
2024-07-17 14:27:03.085 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:27:03.086 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:27:03.089 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调队列
2024-07-17 14:27:03.090 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:27:03.090 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:27:03.093 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 14:27:03.094 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:27:03.094 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:27:03.097 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 14:27:03.098 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:27:03.099 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:27:03.102 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 14:27:03.103 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:27:03.104 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:27:03.108 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 14:27:03.108 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:27:03.109 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:27:03.112 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]KMP
2024-07-17 14:27:03.113 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:27:03.115 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:27:03.118 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 14:27:03.119 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:27:03.122 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:27:03.126 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 14:27:03.127 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:27:03.130 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:27:03.134 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树状数组
2024-07-17 14:27:03.135 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:27:03.136 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:27:03.139 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Trie树
2024-07-17 14:27:03.139 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:27:03.141 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:27:03.145 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 14:27:05.275 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:27:54.897 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:27:54.897 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:27:55.674 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:27:58.849 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:27:58.850 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]快速排序（Quick Sort）是一种时间复杂度为 O(n log n) 的排序算法。
2024-07-17 14:28:00.900 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 14:28:00.900 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:28:16.159 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 14:28:16.161 | DEBUG    | __main__:algorithm_chat:38 - [result]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
[statue]1
[id]2
2024-07-17 14:28:16.174 | DEBUG    | __main__:algorithm_chat:41 - Insert successful
2024-07-17 14:28:26.406 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:28:26.406 | DEBUG    | __main__:algorithm_chat:30 - [history][['时间复杂度为Onlogn排序算法', '下面是重新排版并添加逐行注释的代码：\n\n```cpp\n// 快速排序函数\nvoid quick_sort(int q[], int l, int r) {\n    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回\n    if (l >= r) return;\n\n    // 初始化i和j分别为左边界和右边界的前一个位置\n    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n\n    // 当i小于j时，进行以下循环\n    while (i < j) {\n        // 向右移动i，直到找到一个大于等于x的元素\n        do i ++ ; while (q[i] < x);\n        // 向左移动j，直到找到一个小于等于x的元素\n        do j -- ; while (q[j] > x);\n        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置\n        if (i < j) swap(q[i], q[j]);\n    }\n\n    // 递归地对左半部分和右半部分进行快速排序\n    quick_sort(q, l, j); // 排序左半部分\n    quick_sort(q, j + 1, r); // 排序右半部分\n}\n\n// 交换两个元素的值\nvoid swap(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n```\n\n注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。\n\n此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。']]
2024-07-17 14:28:26.407 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:28:37.781 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:28:37.782 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]快速排序（Quick Sort）是一种时间复杂度为 O(n log n) 的排序算法。它采用分治策略，将大问题分解为小问题，在平均情况下显示出很高的效率。具体而言，快速排序通过选择一个“枢轴”（pivot）元素，将数组分为两部分，左边部分的元素都不大于枢轴，右边部分的元素都不小于枢轴，然后对这两部分递归地进行快速排序。

在最佳和平均情况下，快速排序的时间复杂度都是 O(n log n)，这是因为每次递归都能将数组大致对半分，并且递归的深度大约是 log n。然而，在最坏的情况下，即每次选择的枢轴都是当前子数组中的最小或最大元素，其时间复杂度会退化到 O(n^2)。为了避免最坏情况的发生，通常会采用随机化选择枢轴或三数取中等策略。

快速排序由于其平均情况下的高效性，在许多实际应用场景中非常受欢迎，例如数据库查询优化、计算机图形学中的图像处理等。尽管其空间复杂度为 O(log n)，但由于其出色的平均时间性能，仍然是一种非常实用的排序算法。
2024-07-17 14:28:39.189 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 14:28:39.190 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 14:28:39.191 | ERROR    | chatbot.chatbot:GetResult:60 - chatbot : Retrieval failed: cannot access local variable 'result' where it is not associated with a value
2024-07-17 14:28:39.191 | ERROR    | __main__:algorithm_chat:47 - Error invoking retrieval chain: too many values to unpack (expected 3)
2024-07-17 14:30:51.398 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:30:51.399 | DEBUG    | __main__:algorithm_chat:30 - [history][['时间复杂度为Onlogn排序算法', '下面是重新排版并添加逐行注释的代码：\n\n```cpp\n// 快速排序函数\nvoid quick_sort(int q[], int l, int r) {\n    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回\n    if (l >= r) return;\n\n    // 初始化i和j分别为左边界和右边界的前一个位置\n    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n\n    // 当i小于j时，进行以下循环\n    while (i < j) {\n        // 向右移动i，直到找到一个大于等于x的元素\n        do i ++ ; while (q[i] < x);\n        // 向左移动j，直到找到一个小于等于x的元素\n        do j -- ; while (q[j] > x);\n        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置\n        if (i < j) swap(q[i], q[j]);\n    }\n\n    // 递归地对左半部分和右半部分进行快速排序\n    quick_sort(q, l, j); // 排序左半部分\n    quick_sort(q, j + 1, r); // 排序右半部分\n}\n\n// 交换两个元素的值\nvoid swap(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n```\n\n注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。\n\n此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。'], ['时间复杂度为Onlogn排序算法', 'An error occurred. Please try again.']]
2024-07-17 14:30:51.400 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:31:12.671 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:31:12.672 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:31:12.673 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:31:12.675 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速排序
2024-07-17 14:31:12.675 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:31:12.676 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:31:12.677 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]归并排序
2024-07-17 14:31:12.677 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:31:12.678 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:31:12.679 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数二分
2024-07-17 14:31:12.679 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:31:12.680 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:31:12.681 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 14:31:12.681 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:31:12.682 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:31:12.684 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数三分
2024-07-17 14:31:12.684 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:31:12.685 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:31:12.686 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 14:31:12.686 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:31:12.687 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:31:12.687 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 14:31:12.687 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:31:12.688 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:31:12.690 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 14:31:12.690 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:31:12.691 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:31:12.693 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 14:31:12.693 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:31:12.694 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:31:12.695 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 14:31:12.695 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:31:12.696 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:31:12.697 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 14:31:12.698 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:31:12.698 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:31:12.699 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 14:31:12.699 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:31:12.700 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:31:12.700 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 14:31:12.701 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:31:12.701 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:31:12.702 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 14:31:12.702 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:31:12.703 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:31:12.704 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 14:31:12.705 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:31:12.705 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:31:12.706 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]RMQ
2024-07-17 14:31:12.707 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:31:12.707 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:31:12.708 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 14:31:12.708 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:31:12.709 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:31:12.710 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 14:31:12.710 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:31:12.712 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:31:12.713 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 14:31:12.713 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:31:12.714 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:31:12.715 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 14:31:12.715 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:31:12.716 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:31:12.717 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 14:31:12.718 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:31:12.719 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:31:12.721 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Min_25
2024-07-17 14:31:12.721 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:31:12.724 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:31:12.725 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 14:31:12.725 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:31:12.726 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:31:12.727 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 14:31:12.727 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:31:12.728 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:31:12.728 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 14:31:12.729 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:31:12.729 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:31:12.731 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 14:31:12.731 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:31:12.733 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:31:12.734 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 14:31:12.734 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:31:12.735 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:31:12.736 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 14:31:12.736 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:31:12.737 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:31:12.738 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 14:31:12.739 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:31:12.740 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:31:12.741 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速幂
2024-07-17 14:31:12.741 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:31:12.742 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:31:12.743 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 14:31:12.743 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:31:12.743 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:31:12.744 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 14:31:12.745 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:31:12.746 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:31:12.747 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 14:31:12.747 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:31:12.748 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:31:12.750 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 14:31:12.750 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:31:12.751 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:31:12.752 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 14:31:12.752 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:31:12.753 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:31:12.754 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 14:31:12.754 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:31:12.755 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:31:12.757 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 14:31:12.757 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:31:12.758 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:31:12.760 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树的直径
2024-07-17 14:31:12.760 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:31:12.761 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:31:12.762 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 14:31:12.762 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:31:12.763 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:31:12.765 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 14:31:12.765 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:31:12.767 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:31:12.768 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 14:31:12.768 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:31:12.770 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:31:12.771 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 14:31:12.772 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:31:12.773 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:31:12.775 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 14:31:12.775 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:31:12.776 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:31:12.777 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]prim算法
2024-07-17 14:31:12.777 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:31:12.778 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:31:12.780 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 14:31:12.780 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:31:12.782 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:31:12.783 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 14:31:12.784 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:31:12.785 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:31:12.786 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 14:31:12.786 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:31:12.788 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:31:12.790 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 14:31:12.790 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:31:12.792 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:31:12.794 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 14:31:12.794 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:31:12.796 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:31:12.799 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 14:31:12.799 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:31:12.803 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:31:12.807 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]二分图
2024-07-17 14:31:12.807 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:31:12.809 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:31:12.811 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 14:31:12.811 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:31:12.812 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:31:12.814 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单链表
2024-07-17 14:31:12.814 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:31:12.816 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:31:12.817 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双链表
2024-07-17 14:31:12.817 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:31:12.818 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:31:12.820 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调栈
2024-07-17 14:31:12.820 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:31:12.821 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:31:12.822 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调队列
2024-07-17 14:31:12.822 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:31:12.823 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:31:12.823 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 14:31:12.824 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:31:12.825 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:31:12.826 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 14:31:12.826 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:31:12.827 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:31:12.828 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 14:31:12.829 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:31:12.830 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:31:12.831 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 14:31:12.831 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:31:12.832 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:31:12.832 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]KMP
2024-07-17 14:31:12.833 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:31:12.834 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:31:12.835 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 14:31:12.836 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:31:12.838 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:31:12.840 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 14:31:12.841 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:31:12.843 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:31:12.846 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树状数组
2024-07-17 14:31:12.846 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:31:12.847 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:31:12.848 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Trie树
2024-07-17 14:31:12.848 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:31:12.849 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:31:12.851 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 14:31:14.985 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:31:39.489 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:31:39.489 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:31:40.561 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:31:51.616 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:31:51.617 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]根据您提供的信息，您所询问的时间复杂度为 \(O(n \log n)\) 的排序算法是指快速排序（Quick Sort）。

快速排序是一种高效的排序算法，它基于分治策略，通过以下步骤进行：

1. 选择一个“枢轴”（pivot）元素。
2. 将数组分为两部分：一部分包含所有小于枢轴的元素，另一部分包含所有大于或等于枢轴的元素。
3. 对这两部分递归地应用快速排序。

快速排序的平均时间复杂度为 \(O(n \log n)\)，这是因为在平均情况下，每次可以大致将数组分成两个大小相等的部分，并且递归树的高度大约为 \(\log n\)，每层需要的时间为 \(O(n)\)。

请注意，虽然快速排序的平均时间复杂度为 \(O(n \log n)\)，但在最坏情况下（例如，当输入数组已经是有序的或者每次选择的枢轴都是当前区间的最小或最大元素）时间复杂度会退化到 \(O(n^2)\)。为了避免最坏情况的发生，通常会采用一些策略，比如随机选择枢轴或使用“三数取中”法来选择枢轴。

快速排序由于其效率和 \(O(\log n)\) 的空间复杂度，在多种场景中被广泛应用，特别是在需要处理大量数据的场景下。
2024-07-17 14:31:52.890 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 14:31:52.891 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 14:32:17.548 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def quick_select(l, r):
            pivot_index = random.randint(l, r)
            nums[r], nums[pivot_index] = nums[pivot_index], nums[r]
            pivot = nums[r]
            i = l - 1
            for j in range(l, r):
                if nums[j] <= pivot:
                    i += 1
                    nums[i], nums[j] = nums[j], nums[i]
            nums[i + 1], nums[r] = nums[j], nums[pivot_index]
            if i + 1 == k - 1:
                return nums[i + 1]
            elif i + 1 > k - 1:
                return quick_select(l, i)
            else:
                return quick_select(i + 2, r)

        return quick_select(0, len(nums) - 1)
```

以下是重新排版并添加逐行注释的Python代码：

```python
from typing import List
import random

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        # 定义快速选择函数
        def quick_select(l, r):
            # 随机选择一个枢轴，减少性能退化情况
            pivot_index = random.randint(l, r)
            # 将随机选中的枢轴与数组末尾的元素交换
            nums[r], nums[pivot_index] = nums[pivot_index], nums[r]
            # 选择数组最后一个元素作为枢轴
            pivot = nums[r]
            # 初始化i为比枢轴小的元素的索引
            i = l - 1
            # 遍历数组，将小于等于枢轴的元素放到数组前面
            for j in range(l, r):
                if nums[j] <= pivot:
                    i += 1
                    nums[i], nums[j] = nums[j], nums[i]
            # 将枢轴元素放到正确的位置
            nums[i + 1], nums[r] = nums[i + 1], nums[r]
            # 如果枢轴的位置正好是我们要找的第k大的元素，返回该元素
            if i + 1 == k - 1:
                return nums[i + 1]
            # 如果枢轴的位置大于我们要找的第k大的元素的位置，递归在左子数组中查找
            elif i + 1 > k - 1:
                return quick_select(l, i)
            # 如果枢轴的位置小于我们要找的第k大的元素的位置，递归在右子数组中查找
            else:
                return quick_select(i + 2, r)

        # 从整个数组开始快速选择
        return quick_select(0, len(nums) - 1)
```

这段代码实现了快速选择算法（Quickselect），它是快速排序算法的变体，用于在未排序的数组中找到第k大的元素。算法复杂度平均为O(n)，最坏情况为O(n^2)。
2024-07-17 14:34:54.128 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:34:54.129 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:34:54.130 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:34:54.131 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速排序
2024-07-17 14:34:54.131 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:34:54.132 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:34:54.133 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]归并排序
2024-07-17 14:34:54.133 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:34:54.135 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:34:54.136 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数二分
2024-07-17 14:34:54.136 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:34:54.137 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:34:54.138 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 14:34:54.138 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:34:54.139 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:34:54.140 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数三分
2024-07-17 14:34:54.140 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:34:54.141 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:34:54.142 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 14:34:54.142 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:34:54.143 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:34:54.144 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 14:34:54.144 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:34:54.145 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:34:54.145 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 14:34:54.145 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:34:54.146 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:34:54.147 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 14:34:54.147 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:34:54.149 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:34:54.150 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 14:34:54.150 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:34:54.150 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:34:54.151 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 14:34:54.151 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:34:54.152 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:34:54.152 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 14:34:54.152 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:34:54.153 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:34:54.154 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 14:34:54.154 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:34:54.155 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:34:54.155 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 14:34:54.156 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:34:54.156 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:34:54.157 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 14:34:54.158 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:34:54.158 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:34:54.159 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]RMQ
2024-07-17 14:34:54.159 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:34:54.160 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:34:54.161 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 14:34:54.161 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:34:54.162 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:34:54.163 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 14:34:54.163 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:34:54.164 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:34:54.165 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 14:34:54.165 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:34:54.166 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:34:54.166 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 14:34:54.167 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:34:54.168 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:34:54.169 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 14:34:54.169 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:34:54.170 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:34:54.172 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Min_25
2024-07-17 14:34:54.172 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:34:54.174 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:34:54.176 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 14:34:54.176 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:34:54.177 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:34:54.178 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 14:34:54.178 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:34:54.179 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:34:54.179 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 14:34:54.180 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:34:54.181 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:34:54.182 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 14:34:54.182 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:34:54.184 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:34:54.185 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 14:34:54.185 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:34:54.186 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:34:54.186 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 14:34:54.187 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:34:54.187 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:34:54.189 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 14:34:54.189 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:34:54.190 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:34:54.191 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速幂
2024-07-17 14:34:54.191 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:34:54.192 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:34:54.193 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 14:34:54.193 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:34:54.194 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:34:54.194 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 14:34:54.194 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:34:54.195 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:34:54.196 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 14:34:54.196 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:34:54.197 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:34:54.199 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 14:34:54.199 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:34:54.199 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:34:54.200 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 14:34:54.200 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:34:54.201 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:34:54.202 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 14:34:54.202 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:34:54.204 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:34:54.205 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 14:34:54.205 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:34:54.206 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:34:54.207 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树的直径
2024-07-17 14:34:54.207 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:34:54.208 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:34:54.209 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 14:34:54.210 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:34:54.211 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:34:54.212 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 14:34:54.213 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:34:54.214 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:34:54.215 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 14:34:54.215 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:34:54.216 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:34:54.218 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 14:34:54.218 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:34:54.219 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:34:54.220 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 14:34:54.221 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:34:54.221 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:34:54.222 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]prim算法
2024-07-17 14:34:54.223 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:34:54.224 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:34:54.225 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 14:34:54.226 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:34:54.227 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:34:54.229 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 14:34:54.229 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:34:54.230 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:34:54.231 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 14:34:54.232 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:34:54.234 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:34:54.235 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 14:34:54.235 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:34:54.237 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:34:54.239 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 14:34:54.240 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:34:54.241 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:34:54.243 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 14:34:54.244 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:34:54.246 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:34:54.249 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]二分图
2024-07-17 14:34:54.250 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:34:54.251 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:34:54.253 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 14:34:54.253 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:34:54.255 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:34:54.256 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单链表
2024-07-17 14:34:54.257 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:34:54.258 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:34:54.259 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双链表
2024-07-17 14:34:54.259 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:34:54.260 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:34:54.262 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调栈
2024-07-17 14:34:54.262 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:34:54.262 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:34:54.263 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调队列
2024-07-17 14:34:54.264 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:34:54.264 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:34:54.265 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 14:34:54.265 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:34:54.266 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:34:54.267 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 14:34:54.268 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:34:54.268 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:34:54.269 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 14:34:54.270 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:34:54.271 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:34:54.272 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 14:34:54.273 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:34:54.274 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:34:54.275 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]KMP
2024-07-17 14:34:54.276 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:34:54.277 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:34:54.279 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 14:34:54.279 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:34:54.282 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:34:54.284 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 14:34:54.284 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:34:54.287 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:34:54.290 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树状数组
2024-07-17 14:34:54.290 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:34:54.291 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:34:54.292 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Trie树
2024-07-17 14:34:54.292 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:34:54.293 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:34:54.295 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 14:34:56.361 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:35:26.526 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:35:26.526 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:35:27.274 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:35:30.537 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:35:30.538 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](快速排序)
2024-07-17 14:35:31.551 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 14:35:31.552 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 14:35:31.553 | ERROR    | chatbot.chatbot:GetResult:60 - chatbot : Retrieval failed: cannot access local variable 'result' where it is not associated with a value
2024-07-17 14:35:31.554 | ERROR    | __main__:algorithm_chat:47 - Error invoking retrieval chain: too many values to unpack (expected 3)
2024-07-17 14:37:59.692 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:37:59.693 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:37:59.694 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:37:59.695 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速排序
2024-07-17 14:37:59.695 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:37:59.696 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:37:59.699 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]归并排序
2024-07-17 14:37:59.699 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:37:59.700 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:37:59.701 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数二分
2024-07-17 14:37:59.701 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:37:59.702 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:37:59.704 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 14:37:59.704 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:37:59.705 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:37:59.706 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数三分
2024-07-17 14:37:59.707 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:37:59.707 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:37:59.708 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 14:37:59.708 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:37:59.709 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:37:59.711 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 14:37:59.711 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:37:59.712 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:37:59.714 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 14:37:59.714 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:37:59.714 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:37:59.715 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 14:37:59.716 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:37:59.716 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:37:59.718 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 14:37:59.718 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:37:59.719 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:37:59.720 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 14:37:59.720 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:37:59.721 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:37:59.721 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 14:37:59.722 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:37:59.722 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:37:59.723 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 14:37:59.723 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:37:59.724 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:37:59.725 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 14:37:59.725 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:37:59.726 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:37:59.728 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 14:37:59.728 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:37:59.729 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:37:59.729 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]RMQ
2024-07-17 14:37:59.730 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:37:59.730 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:37:59.732 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 14:37:59.732 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:37:59.733 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:37:59.734 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 14:37:59.734 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:37:59.735 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:37:59.735 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 14:37:59.736 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:37:59.736 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:37:59.737 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 14:37:59.738 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:37:59.739 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:37:59.740 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 14:37:59.740 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:37:59.742 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:37:59.743 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Min_25
2024-07-17 14:37:59.743 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:37:59.746 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:37:59.749 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 14:37:59.749 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:37:59.750 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:37:59.751 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 14:37:59.752 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:37:59.752 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:37:59.753 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 14:37:59.754 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:37:59.755 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:37:59.756 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 14:37:59.756 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:37:59.758 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:37:59.759 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 14:37:59.760 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:37:59.761 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:37:59.762 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 14:37:59.763 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:37:59.764 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:37:59.767 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 14:37:59.768 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:37:59.770 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:37:59.772 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速幂
2024-07-17 14:37:59.772 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:37:59.774 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:37:59.776 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 14:37:59.777 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:37:59.778 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:37:59.779 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 14:37:59.779 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:37:59.781 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:37:59.782 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 14:37:59.783 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:37:59.784 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:37:59.786 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 14:37:59.786 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:37:59.787 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:37:59.789 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 14:37:59.789 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:37:59.790 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:37:59.791 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 14:37:59.791 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:37:59.792 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:37:59.793 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 14:37:59.794 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:37:59.795 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:37:59.797 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树的直径
2024-07-17 14:37:59.797 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:37:59.799 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:37:59.800 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 14:37:59.800 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:37:59.802 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:37:59.804 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 14:37:59.804 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:37:59.805 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:37:59.806 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 14:37:59.807 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:37:59.808 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:37:59.810 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 14:37:59.811 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:37:59.812 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:37:59.813 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 14:37:59.813 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:37:59.815 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:37:59.816 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]prim算法
2024-07-17 14:37:59.817 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:37:59.818 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:37:59.819 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 14:37:59.820 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:37:59.821 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:37:59.824 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 14:37:59.824 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:37:59.825 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:37:59.826 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 14:37:59.827 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:37:59.829 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:37:59.831 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 14:37:59.831 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:37:59.833 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:37:59.835 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 14:37:59.835 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:37:59.837 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:37:59.839 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 14:37:59.840 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:37:59.842 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:37:59.845 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]二分图
2024-07-17 14:37:59.846 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:37:59.847 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:37:59.848 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 14:37:59.849 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:37:59.850 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:37:59.852 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单链表
2024-07-17 14:37:59.852 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:37:59.853 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:37:59.854 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双链表
2024-07-17 14:37:59.854 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:37:59.855 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:37:59.856 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调栈
2024-07-17 14:37:59.857 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:37:59.858 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:37:59.859 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调队列
2024-07-17 14:37:59.859 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:37:59.860 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:37:59.860 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 14:37:59.861 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:37:59.862 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:37:59.862 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 14:37:59.863 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:37:59.864 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:37:59.866 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 14:37:59.866 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:37:59.868 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:37:59.869 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 14:37:59.870 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:37:59.871 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:37:59.873 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]KMP
2024-07-17 14:37:59.873 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:37:59.874 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:37:59.876 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 14:37:59.876 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:37:59.880 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:37:59.884 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 14:37:59.885 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:37:59.889 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:37:59.893 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树状数组
2024-07-17 14:37:59.893 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:37:59.894 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:37:59.895 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Trie树
2024-07-17 14:37:59.896 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:37:59.897 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:37:59.899 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 14:38:02.228 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:38:31.725 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:38:31.725 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:38:32.426 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:38:45.550 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:38:45.551 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]快速排序（Quick Sort）是一种时间复杂度为 O(n log n) 的排序算法。它采用了分治策略，将大问题分解为小问题来递归解决。在快速排序中，通过选择一个“枢轴”（pivot）元素，将数组分为两部分，左边部分的元素都不大于枢轴，右边部分的元素都不小于枢轴。然后对这两部分独立地进行快速排序。

快速排序的平均时间复杂度为 O(n log n)，这是因为每次分解能将数组大致对半分，递归深度为 log n，并且在每一层上需要 O(n) 的时间来完成划分。尽管在最坏的情况下时间复杂度会退化到 O(n^2)，但通过随机化选择枢轴或使用如“三数取中”等策略可以有效避免这种情况。

快速排序由于其效率高，在许多实际应用中非常受欢迎，特别是在处理大型数据集时表现出色。尽管它不是稳定的排序算法，且在最坏情况下空间复杂度为 O(n)，但在平均情况下它的空间复杂度仍为 O(log n)，因此是一种非常高效的排序算法。
2024-07-17 14:38:46.717 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 14:38:46.718 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 14:38:46.719 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
[statue]2
[id]2
2024-07-17 14:38:46.721 | ERROR    | chatbot.chatbot:GetResult:61 - chatbot : Retrieval failed: cannot access local variable 'result' where it is not associated with a value
2024-07-17 14:38:46.721 | ERROR    | __main__:algorithm_chat:47 - Error invoking retrieval chain: too many values to unpack (expected 3)
2024-07-17 14:42:01.491 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:42:01.492 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:42:01.493 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:42:01.495 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速排序
2024-07-17 14:42:01.495 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:42:01.496 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:42:01.497 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]归并排序
2024-07-17 14:42:01.497 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:42:01.498 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:42:01.499 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数二分
2024-07-17 14:42:01.499 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:42:01.500 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:42:01.501 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 14:42:01.502 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:42:01.503 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:42:01.504 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数三分
2024-07-17 14:42:01.504 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:42:01.505 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:42:01.506 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 14:42:01.506 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:42:01.507 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:42:01.507 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 14:42:01.508 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:42:01.509 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:42:01.511 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 14:42:01.511 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:42:01.512 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:42:01.513 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 14:42:01.513 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:42:01.513 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:42:01.514 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 14:42:01.514 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:42:01.516 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:42:01.517 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 14:42:01.517 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:42:01.518 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:42:01.519 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 14:42:01.519 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:42:01.519 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:42:01.520 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 14:42:01.520 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:42:01.521 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:42:01.521 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 14:42:01.522 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:42:01.523 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:42:01.524 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 14:42:01.524 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:42:01.525 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:42:01.525 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]RMQ
2024-07-17 14:42:01.526 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:42:01.526 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:42:01.527 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 14:42:01.527 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:42:01.528 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:42:01.528 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 14:42:01.529 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:42:01.530 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:42:01.531 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 14:42:01.531 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:42:01.532 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:42:01.533 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 14:42:01.533 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:42:01.534 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:42:01.534 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 14:42:01.535 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:42:01.536 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:42:01.539 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Min_25
2024-07-17 14:42:01.539 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:42:01.540 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:42:01.542 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 14:42:01.542 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:42:01.543 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:42:01.545 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 14:42:01.545 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:42:01.546 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:42:01.547 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 14:42:01.547 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:42:01.548 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:42:01.549 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 14:42:01.549 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:42:01.551 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:42:01.553 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 14:42:01.553 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:42:01.554 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:42:01.555 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 14:42:01.555 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:42:01.556 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:42:01.559 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 14:42:01.559 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:42:01.560 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:42:01.562 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速幂
2024-07-17 14:42:01.562 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:42:01.563 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:42:01.564 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 14:42:01.564 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:42:01.566 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:42:01.567 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 14:42:01.567 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:42:01.568 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:42:01.569 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 14:42:01.569 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:42:01.571 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:42:01.574 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 14:42:01.574 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:42:01.575 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:42:01.576 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 14:42:01.576 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:42:01.577 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:42:01.579 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 14:42:01.579 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:42:01.581 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:42:01.582 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 14:42:01.583 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:42:01.583 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:42:01.585 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树的直径
2024-07-17 14:42:01.585 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:42:01.587 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:42:01.588 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 14:42:01.588 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:42:01.589 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:42:01.590 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 14:42:01.591 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:42:01.592 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:42:01.594 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 14:42:01.594 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:42:01.596 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:42:01.597 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 14:42:01.597 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:42:01.599 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:42:01.601 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 14:42:01.601 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:42:01.602 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:42:01.603 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]prim算法
2024-07-17 14:42:01.603 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:42:01.604 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:42:01.605 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 14:42:01.605 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:42:01.608 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:42:01.609 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 14:42:01.609 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:42:01.610 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:42:01.611 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 14:42:01.611 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:42:01.613 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:42:01.616 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 14:42:01.616 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:42:01.617 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:42:01.619 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 14:42:01.620 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:42:01.622 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:42:01.624 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 14:42:01.624 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:42:01.627 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:42:01.630 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]二分图
2024-07-17 14:42:01.630 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:42:01.632 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:42:01.633 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 14:42:01.633 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:42:01.635 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:42:01.636 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单链表
2024-07-17 14:42:01.637 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:42:01.637 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:42:01.638 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双链表
2024-07-17 14:42:01.638 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:42:01.639 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:42:01.640 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调栈
2024-07-17 14:42:01.641 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:42:01.642 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:42:01.643 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调队列
2024-07-17 14:42:01.643 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:42:01.644 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:42:01.644 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 14:42:01.645 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:42:01.645 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:42:01.646 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 14:42:01.646 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:42:01.647 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:42:01.649 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 14:42:01.649 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:42:01.650 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:42:01.652 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 14:42:01.652 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:42:01.653 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:42:01.654 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]KMP
2024-07-17 14:42:01.654 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:42:01.656 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:42:01.658 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 14:42:01.658 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:42:01.662 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:42:01.666 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 14:42:01.667 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:42:01.670 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:42:01.674 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树状数组
2024-07-17 14:42:01.674 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:42:01.676 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:42:01.677 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Trie树
2024-07-17 14:42:01.678 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:42:01.679 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:42:01.680 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 14:42:03.792 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:42:41.069 | DEBUG    | __main__:algorithm_chat:29 - [message]时间复杂度为Onlogn排序算法
2024-07-17 14:42:41.069 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:42:41.771 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]时间复杂度为Onlogn排序算法
2024-07-17 14:42:52.342 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 14:42:52.342 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]快速排序（Quick Sort）是一种时间复杂度为 O(n log n) 的排序算法。它采用分治策略，将大问题分解为小问题来处理。在快速排序中，通过选择一个“枢轴”（pivot）元素，然后将数组分成两部分，一部分的所有元素都比枢轴小，另一部分的所有元素都比枢轴大。这个步骤称为“划分”（partition）。之后对这两部分递归地进行快速排序。

在平均情况下，快速排序的时间复杂度是 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。尽管在最坏的情况下，其时间复杂度可能退化到 O(n^2)，但通过改进枢轴的选择方法（如随机化或三数取中）等方法可以避免最坏情况的发生。

快速排序由于其平均情况下的高效性，以及相对较低的空间复杂度（O(log n)），在各种需要对数据进行排序的场景中得到了广泛的应用，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。
2024-07-17 14:42:53.808 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 14:42:53.809 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 14:42:53.810 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
[statue]2
[id]2
2024-07-17 14:42:53.811 | DEBUG    | chatbot.chatbot:GetResult:54 - [chatbot : The algorithm analysis result does not exist, analyze through code]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 14:43:12.383 | DEBUG    | __main__:algorithm_chat:29 - [message]树状数组
2024-07-17 14:43:12.384 | DEBUG    | __main__:algorithm_chat:30 - [history][['时间复杂度为Onlogn排序算法', '下面是重新排版并添加逐行注释的代码：\n\n```cpp\n// 快速排序函数\nvoid quick_sort(int q[], int l, int r) {\n    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回\n    if (l >= r) return;\n\n    // 初始化i和j分别为左边界和右边界的前一个位置\n    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n\n    // 当i小于j时，进行以下循环\n    while (i < j) {\n        // 向右移动i，直到找到一个大于等于x的元素\n        do i ++ ; while (q[i] < x);\n        // 向左移动j，直到找到一个小于等于x的元素\n        do j -- ; while (q[j] > x);\n        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置\n        if (i < j) swap(q[i], q[j]);\n    }\n\n    // 递归地对左半部分和右半部分进行快速排序\n    quick_sort(q, l, j); // 排序左半部分\n    quick_sort(q, j + 1, r); // 排序右半部分\n}\n\n// 交换两个元素的值\nvoid swap(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n```\n\n注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。\n\n此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。']]
2024-07-17 14:43:12.384 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]树状数组
2024-07-17 14:43:15.605 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程：\n概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。\n核心操作:\nlowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。\nmodify(int x, int c): 更新树状数组中位置 x 的值，增加 c。\nquery(int x): 查询数组前 x 个元素的和。\n\n应用场景:\n常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。\n该数据结构简单而高效，适合处理频繁的更新和查询操作。\n\n时间复杂度:\n更新操作和查询操作均为 O(logn)。\n\n[回答]\n(树状数组)')]
2024-07-17 14:43:15.606 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](树状数组) 
                
2024-07-17 14:43:16.594 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]65
2024-07-17 14:43:16.594 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:43:16.595 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
[statue]1
[id]65
2024-07-17 14:43:31.264 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]下面是重新排版并添加了逐行注释的代码。该代码段实现了基于树状数组的两个常见操作：单点更新（modify）和前缀和查询（query）。

```cpp
#include <iostream> // 预处理指令，包含输入输出流库

// 计算最低有效位（Lowest Bit）
int lowbit(int x) {
    return x & -x; // 返回x最低位的1及其后面的所有0构成的数值
}

// 更新树状数组中位置x的值，增加c
void modify(int x, int c) {
    // 从x开始，不断加上lowbit(x)，直到超出数组范围
    // 这个循环是为了更新所有包含x的区间
    for (int i = x; i <= n; i += lowbit(i)) {
        tr[i] += c; // 在树状数组的位置i加上c
    }
}

// 查询从1到x的所有元素的和
int query(int x) {
    int res = 0; // 初始化结果为0
    // 从x开始，不断减去lowbit(x)，直到x为0
    // 这个循环是为了累加所有包含x的区间的值
    for (int i = x; i >= 1; i -= lowbit(i)) {
        res += tr[i]; // 累加树状数组中的值到结果中
    }
    return res; // 返回从1到x的所有元素的和
}

// 注意：上述代码中有一个外部变量n和一个数组tr，它们应该在使用这些函数之前被定义。
```

注意：上述代码假设变量`n`和数组`tr`已经在其他部分被定义和初始化。此外，由于代码中没有提供这些变量的定义，所以它们需要在实际使用这段代码时被添加。这里假设`n`是树状数组的大小，`tr`是树状数组本身。
2024-07-17 14:43:31.265 | DEBUG    | __main__:algorithm_chat:38 - [result]下面是重新排版并添加了逐行注释的代码。该代码段实现了基于树状数组的两个常见操作：单点更新（modify）和前缀和查询（query）。

```cpp
#include <iostream> // 预处理指令，包含输入输出流库

// 计算最低有效位（Lowest Bit）
int lowbit(int x) {
    return x & -x; // 返回x最低位的1及其后面的所有0构成的数值
}

// 更新树状数组中位置x的值，增加c
void modify(int x, int c) {
    // 从x开始，不断加上lowbit(x)，直到超出数组范围
    // 这个循环是为了更新所有包含x的区间
    for (int i = x; i <= n; i += lowbit(i)) {
        tr[i] += c; // 在树状数组的位置i加上c
    }
}

// 查询从1到x的所有元素的和
int query(int x) {
    int res = 0; // 初始化结果为0
    // 从x开始，不断减去lowbit(x)，直到x为0
    // 这个循环是为了累加所有包含x的区间的值
    for (int i = x; i >= 1; i -= lowbit(i)) {
        res += tr[i]; // 累加树状数组中的值到结果中
    }
    return res; // 返回从1到x的所有元素的和
}

// 注意：上述代码中有一个外部变量n和一个数组tr，它们应该在使用这些函数之前被定义。
```

注意：上述代码假设变量`n`和数组`tr`已经在其他部分被定义和初始化。此外，由于代码中没有提供这些变量的定义，所以它们需要在实际使用这段代码时被添加。这里假设`n`是树状数组的大小，`tr`是树状数组本身。
[statue]1
[id]65
2024-07-17 14:43:31.269 | DEBUG    | __main__:algorithm_chat:41 - Insert successful
2024-07-17 14:43:42.189 | DEBUG    | __main__:algorithm_chat:29 - [message]树状数组
2024-07-17 14:43:42.189 | DEBUG    | __main__:algorithm_chat:30 - [history][['时间复杂度为Onlogn排序算法', '下面是重新排版并添加逐行注释的代码：\n\n```cpp\n// 快速排序函数\nvoid quick_sort(int q[], int l, int r) {\n    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回\n    if (l >= r) return;\n\n    // 初始化i和j分别为左边界和右边界的前一个位置\n    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免\n    int i = l - 1, j = r + 1, x = q[l + r >> 1];\n\n    // 当i小于j时，进行以下循环\n    while (i < j) {\n        // 向右移动i，直到找到一个大于等于x的元素\n        do i ++ ; while (q[i] < x);\n        // 向左移动j，直到找到一个小于等于x的元素\n        do j -- ; while (q[j] > x);\n        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置\n        if (i < j) swap(q[i], q[j]);\n    }\n\n    // 递归地对左半部分和右半部分进行快速排序\n    quick_sort(q, l, j); // 排序左半部分\n    quick_sort(q, j + 1, r); // 排序右半部分\n}\n\n// 交换两个元素的值\nvoid swap(int &a, int &b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n```\n\n注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。\n\n此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。'], ['树状数组', '下面是重新排版并添加了逐行注释的代码。该代码段实现了基于树状数组的两个常见操作：单点更新（modify）和前缀和查询（query）。\n\n```cpp\n#include <iostream> // 预处理指令，包含输入输出流库\n\n// 计算最低有效位（Lowest Bit）\nint lowbit(int x) {\n    return x & -x; // 返回x最低位的1及其后面的所有0构成的数值\n}\n\n// 更新树状数组中位置x的值，增加c\nvoid modify(int x, int c) {\n    // 从x开始，不断加上lowbit(x)，直到超出数组范围\n    // 这个循环是为了更新所有包含x的区间\n    for (int i = x; i <= n; i += lowbit(i)) {\n        tr[i] += c; // 在树状数组的位置i加上c\n    }\n}\n\n// 查询从1到x的所有元素的和\nint query(int x) {\n    int res = 0; // 初始化结果为0\n    // 从x开始，不断减去lowbit(x)，直到x为0\n    // 这个循环是为了累加所有包含x的区间的值\n    for (int i = x; i >= 1; i -= lowbit(i)) {\n        res += tr[i]; // 累加树状数组中的值到结果中\n    }\n    return res; // 返回从1到x的所有元素的和\n}\n\n// 注意：上述代码中有一个外部变量n和一个数组tr，它们应该在使用这些函数之前被定义。\n```\n\n注意：上述代码假设变量`n`和数组`tr`已经在其他部分被定义和初始化。此外，由于代码中没有提供这些变量的定义，所以它们需要在实际使用这段代码时被添加。这里假设`n`是树状数组的大小，`tr`是树状数组本身。']]
2024-07-17 14:43:42.190 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]树状数组
2024-07-17 14:43:49.726 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程：\n概述: 树状数组是一种数据结构，用于支持动态数组的前缀和查询和元素更新操作。它允许在 O(logn) 时间内进行更新和查询。\n核心操作:\nlowbit(int x): 返回 x 的最低位的 1 的位置，用于更新和查询的步长。\nmodify(int x, int c): 更新树状数组中位置 x 的值，增加 c。\nquery(int x): 查询数组前 x 个元素的和。\n\n应用场景:\n常用于解决区间和查询问题，如动态数组求和、频率计数等问题，特别是在在线算法和数据流处理中的表现优异。\n该数据结构简单而高效，适合处理频繁的更新和查询操作。\n\n时间复杂度:\n更新操作和查询操作均为 O(logn)。\n\n[回答]\n(树状数组)')]
2024-07-17 14:43:49.727 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]】(Binary Indexed Tree, BIT)
                
                ```plaintext
                树状数组（Binary Indexed Tree, BIT），又称为斐波那契堆，是一种数据结构，用于高效地解决以下问题：
                - 单点更新：在数组的某个位置增加或减少一个值。
                - 区间查询：查询数组中一段连续区间的元素之和。
                树状数组的核心思想是使用一个数组来存储原数组的累积和，然后利用数组的偏移来快速计算区间和。这种数据结构在时间复杂度上具有优势，对于单点更新和区间查询，它们的时间复杂度都是 O(log n)。
                ```
2024-07-17 14:43:50.942 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]65
2024-07-17 14:43:50.943 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加了逐行注释的代码。该代码段实现了基于树状数组的两个常见操作：单点更新（modify）和前缀和查询（query）。

```cpp
#include <iostream> // 预处理指令，包含输入输出流库

// 计算最低有效位（Lowest Bit）
int lowbit(int x) {
    return x & -x; // 返回x最低位的1及其后面的所有0构成的数值
}

// 更新树状数组中位置x的值，增加c
void modify(int x, int c) {
    // 从x开始，不断加上lowbit(x)，直到超出数组范围
    // 这个循环是为了更新所有包含x的区间
    for (int i = x; i <= n; i += lowbit(i)) {
        tr[i] += c; // 在树状数组的位置i加上c
    }
}

// 查询从1到x的所有元素的和
int query(int x) {
    int res = 0; // 初始化结果为0
    // 从x开始，不断减去lowbit(x)，直到x为0
    // 这个循环是为了累加所有包含x的区间的值
    for (int i = x; i >= 1; i -= lowbit(i)) {
        res += tr[i]; // 累加树状数组中的值到结果中
    }
    return res; // 返回从1到x的所有元素的和
}

// 注意：上述代码中有一个外部变量n和一个数组tr，它们应该在使用这些函数之前被定义。
```

注意：上述代码假设变量`n`和数组`tr`已经在其他部分被定义和初始化。此外，由于代码中没有提供这些变量的定义，所以它们需要在实际使用这段代码时被添加。这里假设`n`是树状数组的大小，`tr`是树状数组本身。
2024-07-17 14:43:50.944 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]下面是重新排版并添加了逐行注释的代码。该代码段实现了基于树状数组的两个常见操作：单点更新（modify）和前缀和查询（query）。

```cpp
#include <iostream> // 预处理指令，包含输入输出流库

// 计算最低有效位（Lowest Bit）
int lowbit(int x) {
    return x & -x; // 返回x最低位的1及其后面的所有0构成的数值
}

// 更新树状数组中位置x的值，增加c
void modify(int x, int c) {
    // 从x开始，不断加上lowbit(x)，直到超出数组范围
    // 这个循环是为了更新所有包含x的区间
    for (int i = x; i <= n; i += lowbit(i)) {
        tr[i] += c; // 在树状数组的位置i加上c
    }
}

// 查询从1到x的所有元素的和
int query(int x) {
    int res = 0; // 初始化结果为0
    // 从x开始，不断减去lowbit(x)，直到x为0
    // 这个循环是为了累加所有包含x的区间的值
    for (int i = x; i >= 1; i -= lowbit(i)) {
        res += tr[i]; // 累加树状数组中的值到结果中
    }
    return res; // 返回从1到x的所有元素的和
}

// 注意：上述代码中有一个外部变量n和一个数组tr，它们应该在使用这些函数之前被定义。
```

注意：上述代码假设变量`n`和数组`tr`已经在其他部分被定义和初始化。此外，由于代码中没有提供这些变量的定义，所以它们需要在实际使用这段代码时被添加。这里假设`n`是树状数组的大小，`tr`是树状数组本身。
[statue]2
[id]65
2024-07-17 14:43:50.945 | DEBUG    | chatbot.chatbot:GetResult:54 - [chatbot : The algorithm analysis result does not exist, analyze through code]下面是重新排版并添加了逐行注释的代码。该代码段实现了基于树状数组的两个常见操作：单点更新（modify）和前缀和查询（query）。

```cpp
#include <iostream> // 预处理指令，包含输入输出流库

// 计算最低有效位（Lowest Bit）
int lowbit(int x) {
    return x & -x; // 返回x最低位的1及其后面的所有0构成的数值
}

// 更新树状数组中位置x的值，增加c
void modify(int x, int c) {
    // 从x开始，不断加上lowbit(x)，直到超出数组范围
    // 这个循环是为了更新所有包含x的区间
    for (int i = x; i <= n; i += lowbit(i)) {
        tr[i] += c; // 在树状数组的位置i加上c
    }
}

// 查询从1到x的所有元素的和
int query(int x) {
    int res = 0; // 初始化结果为0
    // 从x开始，不断减去lowbit(x)，直到x为0
    // 这个循环是为了累加所有包含x的区间的值
    for (int i = x; i >= 1; i -= lowbit(i)) {
        res += tr[i]; // 累加树状数组中的值到结果中
    }
    return res; // 返回从1到x的所有元素的和
}

// 注意：上述代码中有一个外部变量n和一个数组tr，它们应该在使用这些函数之前被定义。
```

注意：上述代码假设变量`n`和数组`tr`已经在其他部分被定义和初始化。此外，由于代码中没有提供这些变量的定义，所以它们需要在实际使用这段代码时被添加。这里假设`n`是树状数组的大小，`tr`是树状数组本身。
2024-07-17 14:45:24.401 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 14:45:24.402 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:45:24.403 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 14:45:24.405 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速排序
2024-07-17 14:45:24.405 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:45:24.406 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 14:45:24.407 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]归并排序
2024-07-17 14:45:24.407 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:45:24.408 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 14:45:24.409 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数二分
2024-07-17 14:45:24.409 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:45:24.410 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 14:45:24.410 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 14:45:24.411 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:45:24.412 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 14:45:24.413 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数三分
2024-07-17 14:45:24.413 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:45:24.414 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:45:24.415 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 14:45:24.415 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:45:24.415 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 14:45:24.416 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 14:45:24.416 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:45:24.417 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 14:45:24.418 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 14:45:24.418 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:45:24.420 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:45:24.421 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 14:45:24.421 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:45:24.422 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 14:45:24.423 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 14:45:24.423 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:45:24.424 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 14:45:24.424 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 14:45:24.425 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:45:24.425 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 14:45:24.425 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 14:45:24.426 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:45:24.426 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 14:45:24.427 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 14:45:24.427 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:45:24.428 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 14:45:24.429 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 14:45:24.429 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:45:24.430 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 14:45:24.430 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 14:45:24.430 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:45:24.431 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 14:45:24.431 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]RMQ
2024-07-17 14:45:24.432 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:45:24.432 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 14:45:24.434 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 14:45:24.434 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:45:24.435 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 14:45:24.436 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 14:45:24.436 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:45:24.437 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 14:45:24.437 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 14:45:24.438 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:45:24.438 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 14:45:24.439 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 14:45:24.440 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:45:24.441 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 14:45:24.442 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 14:45:24.442 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:45:24.443 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 14:45:24.445 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Min_25
2024-07-17 14:45:24.445 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:45:24.446 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 14:45:24.449 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 14:45:24.449 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:45:24.450 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 14:45:24.451 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 14:45:24.451 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:45:24.452 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 14:45:24.452 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 14:45:24.453 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:45:24.454 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 14:45:24.455 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 14:45:24.455 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:45:24.457 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 14:45:24.458 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 14:45:24.459 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:45:24.459 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 14:45:24.460 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 14:45:24.460 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:45:24.462 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 14:45:24.463 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 14:45:24.463 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:45:24.464 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 14:45:24.465 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速幂
2024-07-17 14:45:24.465 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:45:24.466 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 14:45:24.466 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 14:45:24.467 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:45:24.467 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 14:45:24.468 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 14:45:24.469 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:45:24.470 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 14:45:24.470 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 14:45:24.471 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:45:24.472 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 14:45:24.473 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 14:45:24.473 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:45:24.474 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 14:45:24.475 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 14:45:24.475 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:45:24.476 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 14:45:24.477 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 14:45:24.477 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:45:24.479 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 14:45:24.480 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 14:45:24.480 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:45:24.481 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 14:45:24.482 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树的直径
2024-07-17 14:45:24.483 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:45:24.484 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 14:45:24.485 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 14:45:24.486 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:45:24.487 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 14:45:24.488 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 14:45:24.488 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:45:24.490 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 14:45:24.491 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 14:45:24.492 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:45:24.493 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 14:45:24.494 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 14:45:24.494 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:45:24.495 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 14:45:24.497 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 14:45:24.497 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:45:24.498 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 14:45:24.499 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]prim算法
2024-07-17 14:45:24.500 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:45:24.500 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 14:45:24.502 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 14:45:24.502 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:45:24.505 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 14:45:24.507 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 14:45:24.507 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:45:24.508 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 14:45:24.509 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 14:45:24.510 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:45:24.512 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 14:45:24.522 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 14:45:24.522 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:45:24.524 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 14:45:24.525 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 14:45:24.526 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:45:24.527 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 14:45:24.529 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 14:45:24.529 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:45:24.532 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 14:45:24.535 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]二分图
2024-07-17 14:45:24.535 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:45:24.536 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 14:45:24.539 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 14:45:24.539 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:45:24.540 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 14:45:24.542 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单链表
2024-07-17 14:45:24.542 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:45:24.543 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 14:45:24.544 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双链表
2024-07-17 14:45:24.545 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:45:24.546 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 14:45:24.547 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调栈
2024-07-17 14:45:24.548 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:45:24.548 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 14:45:24.549 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调队列
2024-07-17 14:45:24.549 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:45:24.550 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:45:24.551 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 14:45:24.551 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:45:24.552 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 14:45:24.553 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 14:45:24.554 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:45:24.554 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 14:45:24.555 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 14:45:24.556 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:45:24.557 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 14:45:24.559 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 14:45:24.559 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:45:24.560 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 14:45:24.562 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]KMP
2024-07-17 14:45:24.562 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:45:24.563 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 14:45:24.565 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 14:45:24.565 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:45:24.568 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 14:45:24.570 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 14:45:24.570 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:45:24.574 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 14:45:24.576 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树状数组
2024-07-17 14:45:24.576 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:45:24.577 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 14:45:24.577 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Trie树
2024-07-17 14:45:24.578 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:45:24.579 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 14:45:24.581 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 14:45:26.724 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 14:46:09.470 | DEBUG    | __main__:algorithm_chat:29 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-17 14:46:09.471 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 14:46:10.130 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]一种用于优化滑动窗口问题数据结构
2024-07-17 14:46:11.196 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：\n使用两个指针 hh 和 tt 表示队列的头和尾。\n在每次迭代中，首先移除队列头部超出滑动窗口的元素。\n然后，移除队列尾部不符合条件的元素（例如不再是最优解）。\n将当前元素加入队列。\n\n应用场景: \n常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。\n\n时间复杂度: \n每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。\n\n[回答]\n(单调队列)')]
2024-07-17 14:46:11.197 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](单调队列)
2024-07-17 14:46:12.343 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]57
2024-07-17 14:46:12.345 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 14:46:12.348 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
[statue]1
[id]57
2024-07-17 14:46:32.580 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]下面是对您提供的代码的重新排版和逐行注释。为了提高可读性，我假设 `check_out` 和 `check` 函数是代码上下文中定义的，它们分别用于检查队头元素是否应该从队列中移除和检查当前元素是否与队列中的某个元素冲突。

```cpp
// 初始化队头和队尾指针，队列初始为空
int hh = 0, tt = -1;

// 遍历输入序列中的每个元素
for (int i = 0; i < n; i++) {
    // 如果队头元素需要被移除，则移动队头指针直到队列为空或队头元素不需要被移除
    while (hh <= tt && check_out(q[hh])) {
        hh++;
    }

    // 如果队列非空且当前元素与队列中某个元素冲突，则移动队尾指针直到队列为空或没有冲突
    while (hh <= tt && check(q[tt], i)) {
        tt--;
    }

    // 将当前元素添加到队列尾部，并更新队尾指针
    q[++tt] = i;
}
```

每一行注释的说明如下：

- `int hh = 0, tt = -1;`: 初始化队列的头部和尾部指针，这里假设使用的是数组模拟队列，`tt` 初始化为 `-1` 表示队列是空的。
- `for (int i = 0; i < n; i++)`: 遍历输入序列的每个元素。
- `while (hh <= tt && check_out(q[hh])) { hh++; }`: 如果队列不为空且队头元素需要被移除，则持续移动队头指针。
- `while (hh <= tt && check(q[tt], i)) { tt--; }`: 如果队列不为空且当前元素与队列中的某个元素冲突，则持续移动队尾指针。
- `q[++tt] = i;`: 将当前元素添加到队列的末尾，并更新队尾指针。

请注意，代码中的 `check_out` 和 `check` 函数的具体行为取决于您的代码上下文，这里只是根据它们的名称提供了可能的解释。
2024-07-17 14:46:32.581 | DEBUG    | __main__:algorithm_chat:38 - [result]下面是对您提供的代码的重新排版和逐行注释。为了提高可读性，我假设 `check_out` 和 `check` 函数是代码上下文中定义的，它们分别用于检查队头元素是否应该从队列中移除和检查当前元素是否与队列中的某个元素冲突。

```cpp
// 初始化队头和队尾指针，队列初始为空
int hh = 0, tt = -1;

// 遍历输入序列中的每个元素
for (int i = 0; i < n; i++) {
    // 如果队头元素需要被移除，则移动队头指针直到队列为空或队头元素不需要被移除
    while (hh <= tt && check_out(q[hh])) {
        hh++;
    }

    // 如果队列非空且当前元素与队列中某个元素冲突，则移动队尾指针直到队列为空或没有冲突
    while (hh <= tt && check(q[tt], i)) {
        tt--;
    }

    // 将当前元素添加到队列尾部，并更新队尾指针
    q[++tt] = i;
}
```

每一行注释的说明如下：

- `int hh = 0, tt = -1;`: 初始化队列的头部和尾部指针，这里假设使用的是数组模拟队列，`tt` 初始化为 `-1` 表示队列是空的。
- `for (int i = 0; i < n; i++)`: 遍历输入序列的每个元素。
- `while (hh <= tt && check_out(q[hh])) { hh++; }`: 如果队列不为空且队头元素需要被移除，则持续移动队头指针。
- `while (hh <= tt && check(q[tt], i)) { tt--; }`: 如果队列不为空且当前元素与队列中的某个元素冲突，则持续移动队尾指针。
- `q[++tt] = i;`: 将当前元素添加到队列的末尾，并更新队尾指针。

请注意，代码中的 `check_out` 和 `check` 函数的具体行为取决于您的代码上下文，这里只是根据它们的名称提供了可能的解释。
[statue]1
[id]57
2024-07-17 14:46:32.594 | DEBUG    | __main__:algorithm_chat:41 - Insert successful
2024-07-17 14:47:08.495 | DEBUG    | __main__:algorithm_chat:29 - [message]一种用于优化滑动窗口问题的数据结构
2024-07-17 14:47:08.495 | DEBUG    | __main__:algorithm_chat:30 - [history][['一种用于优化滑动窗口问题的数据结构', '下面是对您提供的代码的重新排版和逐行注释。为了提高可读性，我假设 `check_out` 和 `check` 函数是代码上下文中定义的，它们分别用于检查队头元素是否应该从队列中移除和检查当前元素是否与队列中的某个元素冲突。\n\n```cpp\n// 初始化队头和队尾指针，队列初始为空\nint hh = 0, tt = -1;\n\n// 遍历输入序列中的每个元素\nfor (int i = 0; i < n; i++) {\n    // 如果队头元素需要被移除，则移动队头指针直到队列为空或队头元素不需要被移除\n    while (hh <= tt && check_out(q[hh])) {\n        hh++;\n    }\n\n    // 如果队列非空且当前元素与队列中某个元素冲突，则移动队尾指针直到队列为空或没有冲突\n    while (hh <= tt && check(q[tt], i)) {\n        tt--;\n    }\n\n    // 将当前元素添加到队列尾部，并更新队尾指针\n    q[++tt] = i;\n}\n```\n\n每一行注释的说明如下：\n\n- `int hh = 0, tt = -1;`: 初始化队列的头部和尾部指针，这里假设使用的是数组模拟队列，`tt` 初始化为 `-1` 表示队列是空的。\n- `for (int i = 0; i < n; i++)`: 遍历输入序列的每个元素。\n- `while (hh <= tt && check_out(q[hh])) { hh++; }`: 如果队列不为空且队头元素需要被移除，则持续移动队头指针。\n- `while (hh <= tt && check(q[tt], i)) { tt--; }`: 如果队列不为空且当前元素与队列中的某个元素冲突，则持续移动队尾指针。\n- `q[++tt] = i;`: 将当前元素添加到队列的末尾，并更新队尾指针。\n\n请注意，代码中的 `check_out` 和 `check` 函数的具体行为取决于您的代码上下文，这里只是根据它们的名称提供了可能的解释。']]
2024-07-17 14:47:08.496 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]一种用于优化滑动窗口问题数据结构
2024-07-17 14:47:09.657 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n单调队列是一种用于优化滑动窗口问题的数据结构，通过维护一个单调递增或递减的序列来快速找到窗口内的最小值或最大值。实现过程如下：\n使用两个指针 hh 和 tt 表示队列的头和尾。\n在每次迭代中，首先移除队列头部超出滑动窗口的元素。\n然后，移除队列尾部不符合条件的元素（例如不再是最优解）。\n将当前元素加入队列。\n\n应用场景: \n常用于求解最小值/最大值滑动窗口问题，如在图像处理、信号处理等领域，以及在动态规划中优化某些状态转移。\n\n时间复杂度: \n每个元素最多被加入和移除一次，因此整体时间复杂度为 O(n)，其中 n 是输入序列的长度。\n\n[回答]\n(单调队列)')]
2024-07-17 14:47:09.657 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](单调队列)
2024-07-17 14:47:10.805 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]57
2024-07-17 14:47:10.806 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是对您提供的代码的重新排版和逐行注释。为了提高可读性，我假设 `check_out` 和 `check` 函数是代码上下文中定义的，它们分别用于检查队头元素是否应该从队列中移除和检查当前元素是否与队列中的某个元素冲突。

```cpp
// 初始化队头和队尾指针，队列初始为空
int hh = 0, tt = -1;

// 遍历输入序列中的每个元素
for (int i = 0; i < n; i++) {
    // 如果队头元素需要被移除，则移动队头指针直到队列为空或队头元素不需要被移除
    while (hh <= tt && check_out(q[hh])) {
        hh++;
    }

    // 如果队列非空且当前元素与队列中某个元素冲突，则移动队尾指针直到队列为空或没有冲突
    while (hh <= tt && check(q[tt], i)) {
        tt--;
    }

    // 将当前元素添加到队列尾部，并更新队尾指针
    q[++tt] = i;
}
```

每一行注释的说明如下：

- `int hh = 0, tt = -1;`: 初始化队列的头部和尾部指针，这里假设使用的是数组模拟队列，`tt` 初始化为 `-1` 表示队列是空的。
- `for (int i = 0; i < n; i++)`: 遍历输入序列的每个元素。
- `while (hh <= tt && check_out(q[hh])) { hh++; }`: 如果队列不为空且队头元素需要被移除，则持续移动队头指针。
- `while (hh <= tt && check(q[tt], i)) { tt--; }`: 如果队列不为空且当前元素与队列中的某个元素冲突，则持续移动队尾指针。
- `q[++tt] = i;`: 将当前元素添加到队列的末尾，并更新队尾指针。

请注意，代码中的 `check_out` 和 `check` 函数的具体行为取决于您的代码上下文，这里只是根据它们的名称提供了可能的解释。
2024-07-17 14:47:10.807 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]下面是对您提供的代码的重新排版和逐行注释。为了提高可读性，我假设 `check_out` 和 `check` 函数是代码上下文中定义的，它们分别用于检查队头元素是否应该从队列中移除和检查当前元素是否与队列中的某个元素冲突。

```cpp
// 初始化队头和队尾指针，队列初始为空
int hh = 0, tt = -1;

// 遍历输入序列中的每个元素
for (int i = 0; i < n; i++) {
    // 如果队头元素需要被移除，则移动队头指针直到队列为空或队头元素不需要被移除
    while (hh <= tt && check_out(q[hh])) {
        hh++;
    }

    // 如果队列非空且当前元素与队列中某个元素冲突，则移动队尾指针直到队列为空或没有冲突
    while (hh <= tt && check(q[tt], i)) {
        tt--;
    }

    // 将当前元素添加到队列尾部，并更新队尾指针
    q[++tt] = i;
}
```

每一行注释的说明如下：

- `int hh = 0, tt = -1;`: 初始化队列的头部和尾部指针，这里假设使用的是数组模拟队列，`tt` 初始化为 `-1` 表示队列是空的。
- `for (int i = 0; i < n; i++)`: 遍历输入序列的每个元素。
- `while (hh <= tt && check_out(q[hh])) { hh++; }`: 如果队列不为空且队头元素需要被移除，则持续移动队头指针。
- `while (hh <= tt && check(q[tt], i)) { tt--; }`: 如果队列不为空且当前元素与队列中的某个元素冲突，则持续移动队尾指针。
- `q[++tt] = i;`: 将当前元素添加到队列的末尾，并更新队尾指针。

请注意，代码中的 `check_out` 和 `check` 函数的具体行为取决于您的代码上下文，这里只是根据它们的名称提供了可能的解释。
[statue]2
[id]57
2024-07-17 14:47:10.808 | DEBUG    | chatbot.chatbot:GetResult:54 - [chatbot : The algorithm analysis result does not exist, analyze through code]下面是对您提供的代码的重新排版和逐行注释。为了提高可读性，我假设 `check_out` 和 `check` 函数是代码上下文中定义的，它们分别用于检查队头元素是否应该从队列中移除和检查当前元素是否与队列中的某个元素冲突。

```cpp
// 初始化队头和队尾指针，队列初始为空
int hh = 0, tt = -1;

// 遍历输入序列中的每个元素
for (int i = 0; i < n; i++) {
    // 如果队头元素需要被移除，则移动队头指针直到队列为空或队头元素不需要被移除
    while (hh <= tt && check_out(q[hh])) {
        hh++;
    }

    // 如果队列非空且当前元素与队列中某个元素冲突，则移动队尾指针直到队列为空或没有冲突
    while (hh <= tt && check(q[tt], i)) {
        tt--;
    }

    // 将当前元素添加到队列尾部，并更新队尾指针
    q[++tt] = i;
}
```

每一行注释的说明如下：

- `int hh = 0, tt = -1;`: 初始化队列的头部和尾部指针，这里假设使用的是数组模拟队列，`tt` 初始化为 `-1` 表示队列是空的。
- `for (int i = 0; i < n; i++)`: 遍历输入序列的每个元素。
- `while (hh <= tt && check_out(q[hh])) { hh++; }`: 如果队列不为空且队头元素需要被移除，则持续移动队头指针。
- `while (hh <= tt && check(q[tt], i)) { tt--; }`: 如果队列不为空且当前元素与队列中的某个元素冲突，则持续移动队尾指针。
- `q[++tt] = i;`: 将当前元素添加到队列的末尾，并更新队尾指针。

请注意，代码中的 `check_out` 和 `check` 函数的具体行为取决于您的代码上下文，这里只是根据它们的名称提供了可能的解释。
2024-07-17 15:35:14.713 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]__int128读写模板子
2024-07-17 15:35:14.714 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 15:35:14.715 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]__int128读写模板子 
 [Insert_code]```
inline __int128 read(){
__int128 x=0,f=1;
char ch=getchar();
while(ch<'0'||ch>'9'){
if(ch=='-')
f=-1;
ch=getchar();
}
while(ch>='0'&&ch<='9'){
x=x*10+ch-'0';
ch=getchar();
}
return x*f;
}

inline void print(__int128 x){
if(x<0){
putchar('-');
x=-x;
}
if(x>9)
print(x/10);
putchar(x%10+'0');
}
```
2024-07-17 15:35:14.717 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速排序
2024-07-17 15:35:14.718 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 15:35:14.718 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速排序 
 [Insert_code]```
void quick_sort(int q[], int l, int r)
{
if (l >= r) return;

int i = l - 1, j = r + 1, x = q[l + r >> 1];
while (i < j)
{
do i ++ ; while (q[i] < x);
do j -- ; while (q[j] > x);
if (i < j) swap(q[i], q[j]);
}
quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```
2024-07-17 15:35:14.719 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]归并排序
2024-07-17 15:35:14.719 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 15:35:14.720 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]归并排序 
 [Insert_code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 15:35:14.721 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数二分
2024-07-17 15:35:14.721 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 15:35:14.723 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数二分 
 [Insert_code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 15:35:14.724 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数二分
2024-07-17 15:35:14.724 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 15:35:14.725 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数二分 
 [Insert_code]```
const double eps=1e-6;
bool check(double x) {/* ... */}

double bsearch_3(double l,double r)
{
while (r-l>eps)
{
double mid = (l + r) / 2;
if (check(mid))  r = mid;
else l = mid;
}
return l;
}
```
2024-07-17 15:35:14.725 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]整数三分
2024-07-17 15:35:14.726 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 15:35:14.726 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]整数三分 
 [Insert_code]```
//以凸函数位例子
int check(x){.....} 	//返回判断当前点对应的函数值
int bsearch_1(int l, int r)
{
while (l < r-1)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = l+r>>1;
m2 = m1+r>>1;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 15:35:14.728 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]浮点数三分
2024-07-17 15:35:14.728 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 15:35:14.729 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]浮点数三分 
 [Insert_code]```
//以凸函数位例子
double check(x){.....} 	//返回判断当前点对应的函数值
double bsearch_1(double l, double r)
{
while (r-l>eps)
{
//三分的两个中点有两种写法
// m1 = l+(r-l)/3;
// m2 = r-(r-l)/3;
m1 = (l+r)/2;
m2 = (m1+r)/2;
if(check(m1) > check(m2)) r=m2;
else l=m1;
}
return l;
}
```
2024-07-17 15:35:14.730 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度加法
2024-07-17 15:35:14.731 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 15:35:14.732 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度加法 
 [Insert_code]```
vector<int> add(vector<int> &A, vector<int> &B)
{
if (A.size() < B.size()) return add(B, A);

vector<int> C;
int t = 0;
for (int i = 0; i < A.size(); i ++ )
{
t += A[i];
if (i < B.size()) t += B[i];
C.push_back(t % 10);
t /= 10;
}

if (t) C.push_back(t);
return C;
}
```
2024-07-17 15:35:14.733 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度减法
2024-07-17 15:35:14.733 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 15:35:14.734 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度减法 
 [Insert_code]```
vector<int> sub(vector<int> &A, vector<int> &B)
{
vector<int> C;
for (int i = 0, t = 0; i < A.size(); i ++ )
{
t = A[i] - t;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);
if (t < 0) t = 1;
else t = 0;
}

while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 15:35:14.736 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度乘低精度
2024-07-17 15:35:14.736 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 15:35:14.737 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度乘低精度 
 [Insert_code]```
vector<int> mul(vector<int> &A, int b)
{
vector<int> C;
int t = 0;
for (int i = 0; i < A.size() || t; i ++ )
{
if (i < A.size()) t += A[i] * b;
C.push_back(t % 10);
t /= 10;
}

return C;
}
```
2024-07-17 15:35:14.738 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高精度除以低精度
2024-07-17 15:35:14.739 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 15:35:14.739 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高精度除以低精度 
 [Insert_code]```
vector<int> div(vector<int> &A, int b, int &r)
{
vector<int> C;
r = 0;
for (int i = A.size() - 1; i >= 0; i -- )
{
r = r * 10 + A[i];
C.push_back(r / b);
r %= b;
}
reverse(C.begin(), C.end());
while (C.size() > 1 && C.back() == 0) C.pop_back();
return C;
}
```
2024-07-17 15:35:14.740 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]子矩阵的和
2024-07-17 15:35:14.741 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 15:35:14.741 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]子矩阵的和 
 [Insert_code]```
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```
2024-07-17 15:35:14.742 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]差分矩阵
2024-07-17 15:35:14.742 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 15:35:14.743 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]差分矩阵 
 [Insert_code]```
简单的区间差分插入操作：
void insert(int l,int r,int x)
{
b[l]+=x,b[r+1]-=x;
}
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```
2024-07-17 15:35:14.744 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双指针算法
2024-07-17 15:35:14.744 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 15:35:14.745 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双指针算法 
 [Insert_code]```
for (int i = 0, j = 0; i < n; i ++ )
{
while (j < i && check(i, j)) j ++ ;
}
```
2024-07-17 15:35:14.746 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_保序离散化
2024-07-17 15:35:14.746 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 15:35:14.747 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_保序离散化 
 [Insert_code]```
vector<int> alls;
sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

int find(int x) // 找到第一个大于等于x的位置
{
int l = 0, r = alls.size() - 1;
while (l < r)
{
int mid = l + r >> 1;
if (alls[mid] >= x) r = mid;
else l = mid + 1;
}
return r + 1;
}
```
2024-07-17 15:35:14.748 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]数据离散化_非保序离散化
2024-07-17 15:35:14.748 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 15:35:14.749 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]数据离散化_非保序离散化 
 [Insert_code]```
unordered_map<int,int> mp;
int res;
int find(int x)
{
if(mp.count(x)==0) return mp[x]=++res;
return mp[x];
}
```
2024-07-17 15:35:14.750 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]RMQ
2024-07-17 15:35:14.750 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 15:35:14.751 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]RMQ 
 [Insert_code]```
const int N=2e5+7,M=20;
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
for(int i=1;i+(1<<j)-1<=n;i++)
{
if(!j) dp[i][j]=a[i];
else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```
2024-07-17 15:35:14.752 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法判定质数
2024-07-17 15:35:14.753 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 15:35:14.753 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法判定质数 
 [Insert_code]```
bool is_prime(int x)
{
if (x < 2) return false;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
return false;
return true;
}
```
2024-07-17 15:35:14.754 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法分解质因数
2024-07-17 15:35:14.754 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 15:35:14.755 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法分解质因数 
 [Insert_code]```
void divide(int x)
{
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
int s = 0;
while (x % i == 0) x /= i, s ++ ;
cout << i << ' ' << s << endl;
}
if (x > 1) cout << x << ' ' << 1 << endl;
cout << endl;
}
```
2024-07-17 15:35:14.756 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素素数筛法
2024-07-17 15:35:14.757 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 15:35:14.758 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (st[i]) continue;
primes[cnt ++ ] = i;
for (int j = i + i; j <= n; j += i)
st[j] = true;
}
}
```
2024-07-17 15:35:14.759 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线性素数筛法
2024-07-17 15:35:14.759 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 15:35:14.760 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线性素数筛法 
 [Insert_code]```
int primes[N], cnt;
bool st[N];
void get_primes(int n)
{
for (int i = 2; i <= n; i ++ )
{
if (!st[i]) primes[cnt ++ ] = i;
for (int j = 0; primes[j] <= n / i; j ++ )
{
st[primes[j] * i] = true;
if (i % primes[j] == 0) break;
}
}
}
```
2024-07-17 15:35:14.762 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]区间素数筛法
2024-07-17 15:35:14.762 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 15:35:14.764 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]区间素数筛法 
 [Insert_code]```
#define MAX_L 1000007
#define MAX_SORT_B 1000007

bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];

void segment_sieve(LL a,LL b)
{
for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
for(int i=0; i<b-a; i++)is_prime[i]=true;
for(int i=2; (LL)i * i<b; i++)
{
if(is_prime_small[i])
{
for(int j=2*i; (LL)j * j < b; j += i)
{
is_prime_small[j]=false;
}
for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i)
{
is_prime[j - a] =false;
}
}
}
}
```
2024-07-17 15:35:14.766 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Min_25
2024-07-17 15:35:14.766 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 15:35:14.768 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Min_25 
 [Insert_code]```
const int N=1000010;

namespace Min25 {
int prime[N], id1[N], id2[N], flag[N], ncnt, m;
ll g[N], sum[N], a[N], T, n;
inline int ID(ll x) {
return x <= T ? id1[x] : id2[n / x];
}
inline ll calc(ll x) {
return x * (x + 1) / 2 - 1;
}
inline ll f(ll x) {
return x;
}
inline void init() {
//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
ncnt=m=0;
T = sqrt(n + 0.5);
for (int i = 2; i <= T; i++) {
if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
flag[i * prime[j]] = 1;
if (i % prime[j] == 0) break;
}
}
for (ll l = 1; l <= n; l = n / (n / l) + 1) {
a[++m] = n / l;
if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
g[m] = calc(a[m]);
}
for (int i = 1; i <= ncnt; i++)
for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++)
g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
}

inline ll solve(ll x) {
if (x <= 1) return x;
return n = x, init(), g[ID(n)];
}
}
```
2024-07-17 15:35:14.772 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]试除法求约数
2024-07-17 15:35:14.773 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 15:35:14.774 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]试除法求约数 
 [Insert_code]```
vector<int> get_divisors(int x)
{
vector<int> res;
for (int i = 1; i <= x / i; i ++ )
if (x % i == 0)
{
res.push_back(i);
if (i != x / i) res.push_back(x / i);
}
sort(res.begin(), res.end());
return res;
}
```
2024-07-17 15:35:14.774 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧几里得算法
2024-07-17 15:35:14.775 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 15:35:14.775 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧几里得算法 
 [Insert_code]```
int gcd(int a, int b)
{
return b ? gcd(b, a % b) : a;
}
```
2024-07-17 15:35:14.776 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]欧拉函数
2024-07-17 15:35:14.776 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 15:35:14.777 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]欧拉函数 
 [Insert_code]```
//1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
int phi(int x)
{
int res = x;
for (int i = 2; i <= x / i; i ++ )
if (x % i == 0)
{
res = res / i * (i - 1);
while (x % i == 0) x /= i;
}
if (x > 1) res = res / x * (x - 1);

return res;
}
```
2024-07-17 15:35:14.779 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]筛法求欧拉函数
2024-07-17 15:35:14.779 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 15:35:14.780 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]筛法求欧拉函数 
 [Insert_code]```
void get_eulers(int n)
{
euler[1] = 1;
for (int i = 2; i <= n; i ++ )
{
if (!st[i])
{
primes[cnt ++ ] = i;
euler[i] = i - 1;
}
for (int j = 0; primes[j] <= n / i; j ++ )
{
int t = primes[j] * i;
st[t] = true;
if (i % primes[j] == 0)
{
euler[t] = euler[i] * primes[j];
break;
}
euler[t] = euler[i] * (primes[j] - 1);
}
}
}
```
2024-07-17 15:35:14.781 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]卡特兰数求模
2024-07-17 15:35:14.781 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 15:35:14.782 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]卡特兰数求模 
 [Insert_code]```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
inv[1] = 1;
for(int i=2; i<=N+1; i++)
inv[i] = (mod - mod / i) * inv[mod % i] % mod;

CatalanNum[0] = CatalanNum[1] = 1;

for(int i=2; i<=N; i++)
CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```
2024-07-17 15:35:14.783 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速求第n位卡特兰数
2024-07-17 15:35:14.783 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 15:35:14.785 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速求第n位卡特兰数 
 [Insert_code]```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;

void init()
{
inv[1]=1;
for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}

int main()
{
scanf("%lld",&n);
init();
for(int i=2;i<=n;i++)
{
last=now;
now=last*(4*i-2)%M*inv[i+1]%M;
}
printf("%lld\n",last);
return 0;
}
```
2024-07-17 15:35:14.786 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Java大数打表卡特兰数
2024-07-17 15:35:14.786 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 15:35:14.787 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Java大数打表卡特兰数 
 [Insert_code]```
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner cin=new Scanner(System.in);
BigInteger s[]=new BigInteger[105];
s[1]=BigInteger.ONE;
for(int i=2;i<105;i++){
s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
}
while(cin.hasNext()){
int n=cin.nextInt();
System.out.println(s[n]);
}
}
}
```
2024-07-17 15:35:14.788 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]快速幂
2024-07-17 15:35:14.789 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 15:35:14.789 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]快速幂 
 [Insert_code]```
long long pow(long long m, long long k, long long p){
long long res = 1 % p, t = m;
while (k>0)
{
if ((k&1)>0) res = res * t % p;
t = t * t % p;
k >>= 1;
}
return res%p;
}
```
2024-07-17 15:35:14.790 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]位运算处理大数相乘
2024-07-17 15:35:14.790 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 15:35:14.791 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]位运算处理大数相乘 
 [Insert_code]```
ll quick_add(ll a,ll b,ll p)
{
ll res=0;
while(b)
{
if(b&1) res=(res+a)%p;
a=(a+a)%p;
b>>=1;
}
return res;
}
```
2024-07-17 15:35:14.792 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]扩展欧几里得算法
2024-07-17 15:35:14.793 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 15:35:14.793 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]扩展欧几里得算法 
 [Insert_code]```
int exgcd(int a, int b, int &x, int &y)
{
if (!b)
{
x = 1; y = 0;
return a;
}
int d = exgcd(b, a % b, y, x);
y -= (a/b) * x;
return d;
}
```
2024-07-17 15:35:14.794 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]高斯消元
2024-07-17 15:35:14.794 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 15:35:14.795 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]高斯消元 
 [Insert_code]```
// a[N][N]是增广矩阵
int gauss()
{
int c, r;
for (c = 0, r = 0; c < n; c ++ )
{
int t = r;
for (int i = r; i < n; i ++ )
if (fabs(a[i][c]) > fabs(a[t][c]))
t = i;
if (fabs(a[t][c]) < eps) continue;
for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);
for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];
for (int i = r + 1; i < n; i ++ )
if (fabs(a[i][c]) > eps)
for (int j = n; j >= c; j -- )
a[i][j] -= a[r][j] * a[i][c];

r ++ ;
}
if (r < n)
{
for (int i = r; i < n; i ++ )
if (fabs(a[i][n]) > eps)
return 2;
return 1;
}
for (int i = n - 1; i >= 0; i -- )
for (int j = i + 1; j < n; j ++ )
a[i][n] -= a[i][j] * a[j][n];
return 0;
}
```
2024-07-17 15:35:14.797 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]递归法求组合数
2024-07-17 15:35:14.797 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 15:35:14.798 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]递归法求组合数 
 [Insert_code]```
void init(int x,int y)
{
C[0][0]=C[1][0] = C[1][1] = 1;
for (int i = 2; i <=x; i++)
{
C[i][0] = 1;
for (int j = 1; j <=y; j++)
C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
}
}
```
2024-07-17 15:35:14.799 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]预处理逆元的方式求组合数
2024-07-17 15:35:14.800 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 15:35:14.801 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]预处理逆元的方式求组合数 
 [Insert_code]```
int qmi(int a, int k, int p)
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
fact[i] = (LL)fact[i - 1] * i % mod;
infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```
2024-07-17 15:35:14.801 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Lucas定理
2024-07-17 15:35:14.801 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 15:35:14.803 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Lucas定理 
 [Insert_code]```
int qmi(int a, int k)       // 快速幂模板
{
int res = 1;
while (k)
{
if (k & 1) res = (LL)res * a % p;
a = (LL)a * a % p;
k >>= 1;
}
return res;
}

int C(int a, int b)     // 通过定理求组合数C(a, b)
{
int res = 1;
for (int i = 1, j = a; i <= b; i ++, j -- )
{
res = (LL)res * j % p;
res = (LL)res * qmi(i, p - 2) % p;
}
return res;
}


int lucas(LL a, LL b)
{
if (a < p && b < p) return C(a, b);
return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```
2024-07-17 15:35:14.805 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的拓扑序
2024-07-17 15:35:14.805 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 15:35:14.807 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的拓扑序 
 [Insert_code]```
bool topsort()
{
for(int i=1;i<=n;i++)
{
if(inv[i]==0) q.push(i);
}
while(!q.empty())
{
int res=q.front();
q.pop();
p.push(res);
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
inv[j]--;
if(inv[j]==0) q.push(j);
}
}
if(p.size()==n) return true;
else return false;
}
```
2024-07-17 15:35:14.808 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树的直径
2024-07-17 15:35:14.808 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 15:35:14.809 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树的直径 
 [Insert_code]```
//树的直径求法有很多：
//两次BFS或者两次DFS；树形DP
//树形DP的基本思路：
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{		int j=e[i];
if(j==fa) continue;
dfs(j,u);
if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
dmax=max(dmax,d[0][u]+d[1][u]);
}
}
```
2024-07-17 15:35:14.810 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]堆优化版Dijkstra
2024-07-17 15:35:14.810 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 15:35:14.812 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]堆优化版Dijkstra 
 [Insert_code]```
int dijkstra()
{
memset(dist, 0x3f, sizeof dist);
dist[1] = 0;
priority_queue<PII, vector<PII>, greater<PII>> heap;
heap.push({0, 1});

while (heap.size())
{
auto t = heap.top();
heap.pop();

int ver = t.second, distance = t.first;

if (st[ver]) continue;
st[ver] = true;

for (int i = h[ver]; i != -1; i = ne[i])
{
int j = e[i];
if (dist[j] > distance + w[i])
{
dist[j] = distance + w[i];
heap.push({dist[j], j});
}
}
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```
2024-07-17 15:35:14.814 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素版spfa
2024-07-17 15:35:14.814 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 15:35:14.815 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素版spfa 
 [Insert_code]```
void spfa()
{
int hh = 0, tt = 0;
for (int i = 1; i <= n; i++) dist[i] = INF;
dist[1] = 0;
q[tt++] = 1, st[1] = 1;
while (hh != tt)
{
int t = q[hh++];
st[t] = 0;
if (hh == n) hh = 0;
for (int i = h[t]; i != -1; i = ne[i])
if (dist[e[i]] > dist[t] + v[i])
{
dist[e[i]] = dist[t] + v[i];
if (!st[e[i]])
{
st[e[i]] = 1;
q[tt++] = e[i];
if (tt == n) tt = 0;
}
}
}
}
```
2024-07-17 15:35:14.816 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SFA优化版的spfa
2024-07-17 15:35:14.816 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 15:35:14.817 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SFA优化版的spfa 
 [Insert_code]```
void spfa(int root,int dist[])
{
memset(dist,0x3f,sizeof dis);
dist[root] = 0;
memset(st, false, sizeof st);
deque<int> q;
q.push_back(root);
st[root]=true;
while (q.size())
{
int res=q.front();
q.pop_front();
st[res]=false;
for(int i=h[res];i!=-1;i=ne[i])
{
int j=e[i];
if(dist[j]>dist[res]+w[i])
{
dist[j]=dist[res]+w[i];
if(!st[j])
{
st[j]=true;
if(dist[j]>dist[q.front()]) q.push_back(j);
else q.push_front(j);
}
}
}
}
}
```
2024-07-17 15:35:14.819 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]SPFA判负环正环
2024-07-17 15:35:14.819 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 15:35:14.821 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]SPFA判负环正环 
 [Insert_code]```
bool spfa()
{
memset(dis,0,sizeof dis);
memset(st,false,sizeof st);
memset(cnt,0,sizeof cnt);
queue<int> q;
for(int i=0;i<=n;i++) q.push(i),st[i]=true;
int count=0;
while(q.size())
{
int t=q.front();
st[t]=false;
q.pop();
for(int i=h[t];i!=-1;i=ne[i])
{
int j=e[i];
if(dis[j]>dis[t]+w[i])
{
dis[j]=dis[t]+w[i];
cnt[j]=cnt[t]+1;
if(cnt[j]>=n) return true;
if(!st[j])
{
q.push(j);
st[j]=true;
}
}
}
}
return false;
}
```
2024-07-17 15:35:14.822 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]loyd算法 O(n^3)
2024-07-17 15:35:14.822 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 15:35:14.823 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]loyd算法 O(n^3) 
 [Insert_code]```
int main()
{
cin >> m >> n;
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = i == j ? 0 : INF;
for (int i = 0; i < m; i++)
{
int a, b, c;
cin >> a >> b >> c;
d[a][b] = d[b][a] = min(c, d[a][b]);
}
// floyd 算法核心
for (int k = 1; k <= n; k++)
for (int i = 1; i <= n; i++)
for (int j = 1; j <= n; j++)
d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
cout << d[1][n] << endl;
return 0;
}
```
2024-07-17 15:35:14.824 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]prim算法
2024-07-17 15:35:14.824 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 15:35:14.826 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]prim算法 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;

if (i && dist[t] == INF) return INF;

if (i) res += dist[t];
st[t] = true;

for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
}

return res;
}
```
2024-07-17 15:35:14.828 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]kruskal算法
2024-07-17 15:35:14.828 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 15:35:14.830 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]kruskal算法 
 [Insert_code]```
struct Edge
{
int a, b, w;

bool operator< (const Edge &W)const
{
return w < W.w;
}
}edges[M];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

int kruskal()
{
sort(edges, edges + m);

for (int i = 1; i <= n; i ++ ) p[i] = i;

int res = 0, cnt = 0;
for (int i = 0; i < m; i ++ )
{
int a = edges[i].a, b = edges[i].b, w = edges[i].w;

a = find(a), b = find(b);
if (a != b)
{
p[a] = b;
res += w;
cnt ++ ;
}
}

if (cnt < n - 1) return INF;
return res;
}
```
2024-07-17 15:35:14.832 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]最小生成森林
2024-07-17 15:35:14.832 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 15:35:14.833 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]最小生成森林 
 [Insert_code]```
int prim()
{
memset(dist, 0x3f, sizeof dist);

int res = 0;
for (int i = 0; i < n; i ++ )
{
int t = -1;
for (int j = 1; j <= n; j ++ )
if (!st[j] && (t == -1 || dist[t] > dist[j]))
t = j;
st[t] = true;
for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
if(i&&dist[t]==0x3f3f3f3f) continue;
if (i) res += dist[t];
}

return res;
}
```
2024-07-17 15:35:14.835 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]倍增在线算法
2024-07-17 15:35:14.835 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 15:35:14.837 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]倍增在线算法 
 [Insert_code]```
void bfs(int root)
{
memset(depth,0x3f,sizeof depth);
queue<int> q;
q.push(root);
depth[0]=0,depth[root]=1;
while(q.size())
{
int t=q.front();
q.pop();
for(int i=h[t];~i;i=ne[i])
{
int j=e[i];
if(depth[j]>depth[t]+1)
{
depth[j]=depth[t]+1;
fa[j][0]=t;
q.push(j);
for(int k=1;k<16;k++)
fa[j][k]=fa[fa[j][k-1]][k-1];
}
}
}
}
int lca(int a,int b)
{
if(depth[a]<depth[b]) swap(a,b);
for(int k=15;k>=0;k--)
if(depth[fa[a][k]]>=depth[b])
a=fa[a][k];
if(a==b) return a;
for(int k=15;k>=0;k--)
{
if(fa[a][k]!=fa[b][k])
{
a=fa[a][k];
b=fa[b][k];
}
}
return fa[a][0];
}
```
2024-07-17 15:35:14.839 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]targin离线算法
2024-07-17 15:35:14.840 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 15:35:14.841 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]targin离线算法 
 [Insert_code]```
vector<PII> query[N];

void dfs(int u,int fa)
{
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(j==fa) continue;
dis[j]=dis[u]+w[i];
dfs(j,u);
}
}
int find(int x)
{
if(x!=p[x]) p[x]=find(p[x]);
return p[x];
}
void targin(int u)
{
st[u]=1;
for(int i=h[u];~i;i=ne[i])
{
int j=e[i];
if(!st[j])
{
targin(j);
p[j]=u;
}
}
for(auto it : quiry[u])
{
int x=u,y=it.first,id=it.second;
if(st[y]==2)
{
int lca=find(y);
ans[id]=dis[x]+dis[y]-2*dis[lca];
}
}
st[u]=2;
}
```
2024-07-17 15:35:14.843 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]有向图的强连通分量
2024-07-17 15:35:14.843 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 15:35:14.845 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]有向图的强连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u, in_stk[u] = true;

for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
}
else if (in_stk[j])
low[u] = min(low[u], dfn[j]);
}

if (dfn[u] == low[u])
{
++ scc_cnt;
int y;
do {
y = stk[top -- ];
in_stk[y] = false;
id[y] = scc_cnt;
//size_scc[scc_cnt]++;
} while (y != u);
}
}
for(int i=1;i<=n;i++)
{
if(!dfn[i])
tarjan(i);
}
for(int i=1;i<=n;i++)
{
for(int j=h[i];~j;j=ne[j])
{
int k=e[j];
int a=id[i],b=id[k];
if(a!=b) dout[a]++;
}
}
```
2024-07-17 15:35:14.848 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]无向图的点双连通分量
2024-07-17 15:35:14.848 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 15:35:14.852 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]无向图的点双连通分量 
 [Insert_code]```
void add(int a, int b)
{
e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void tarjan(int u)
{
dfn[u] = low[u] = ++ timestamp;
stk[ ++ top] = u;

if (u == root && h[u] == -1)
{
dcc_cnt ++ ;
dcc[dcc_cnt].push_back(u);
return;
}

int cnt = 0;
for (int i = h[u]; ~i; i = ne[i])
{
int j = e[i];
if (!dfn[j])
{
tarjan(j);
low[u] = min(low[u], low[j]);
if (dfn[u] <= low[j])
{
cnt ++ ;
if (u != root || cnt > 1) cut[u] = true;
++ dcc_cnt;
int y;
do {
y = stk[top -- ];
dcc[dcc_cnt].push_back(y);
} while (y != j);
dcc[dcc_cnt].push_back(u);
}
}
else low[u] = min(low[u], dfn[j]);
}
}

int main()
{
int T = 1;
while (cin >> m, m)
{
for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
idx = n = timestamp = top = dcc_cnt = 0;
memset(h, -1, sizeof h);
memset(dfn, 0, sizeof dfn);
memset(cut, 0, sizeof cut);
while (m -- )
{
int a, b;
cin >> a >> b;
n = max(n, a), n = max(n, b);
add(a, b), add(b, a);
}

for (root = 1; root <= n; root ++ )
if (!dfn[root])
tarjan(root);
}
}
```
2024-07-17 15:35:14.856 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]二分图
2024-07-17 15:35:14.856 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 15:35:14.858 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]二分图 
 [Insert_code]```
bool dfs(int u, int c)
{
color[u] = c;
for (int i = h[u]; i != -1; i = ne[i])
{
int j = e[i];
if (color[j] == -1)
{
if (!dfs(j, !c)) return false;
}
else if (color[j] == c) return false;
}

return true;
}

bool check()
{
memset(color, -1, sizeof color);
bool flag = true;
for (int i = 1; i <= n; i ++ )
if (color[i] == -1)
if (!dfs(i, 0))
{
flag = false;
break;
}
return flag;
}
```
2024-07-17 15:35:14.860 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]匈牙利算法
2024-07-17 15:35:14.860 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 15:35:14.862 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]匈牙利算法 
 [Insert_code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-17 15:35:14.864 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单链表
2024-07-17 15:35:14.864 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 15:35:14.865 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单链表 
 [Insert_code]```
int head, e[N], ne[N], idx;
void init()
{
head = -1;
idx = 0;
}
void insert(int a)
{
e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
head = ne[head];
}
```
2024-07-17 15:35:14.866 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]双链表
2024-07-17 15:35:14.866 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 15:35:14.868 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]双链表 
 [Insert_code]```
void init()
{
r[0] = 1, l[1] = 0;
idx = 2;
}

void insert(int a, int x)
{
e[idx] = x;
l[idx] = a, r[idx] = r[a];
l[r[a]] = idx, r[a] = idx ++ ;
}

void remove(int a)
{
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```
2024-07-17 15:35:14.869 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调栈
2024-07-17 15:35:14.870 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 15:35:14.870 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调栈 
 [Insert_code]```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
while (tt && check(stk[tt], i)) tt -- ;
stk[ ++ tt] = i;
}
```
2024-07-17 15:35:14.871 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]单调队列
2024-07-17 15:35:14.871 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 15:35:14.872 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]单调队列 
 [Insert_code]```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
while (hh <= tt && check(q[tt], i)) tt -- ;
q[ ++ tt] = i;
}
```
2024-07-17 15:35:14.873 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]朴素并查集
2024-07-17 15:35:14.873 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 15:35:14.875 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]朴素并查集 
 [Insert_code]```
int p[N];

int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}

for (int i = 1; i <= n; i ++ ) p[i] = i;

p[find(a)] = find(b);
```
2024-07-17 15:35:14.876 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护size的并查集
2024-07-17 15:35:14.876 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 15:35:14.877 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护size的并查集 
 [Insert_code]```
int p[N], size[N];
int find(int x)
{
if (p[x] != x) p[x] = find(p[x]);
return p[x];
}
for (int i = 1; i <= n; i ++ )
{
p[i] = i;
size[i] = 1;
}

size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```
2024-07-17 15:35:14.877 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]维护到祖宗节点距离的并查集
2024-07-17 15:35:14.878 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 15:35:14.878 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]维护到祖宗节点距离的并查集 
 [Insert_code]```
int p[N], d[N];
int find(int x)
{
if (p[x] != x)
{
int u = find(p[x]);
d[x] += d[p[x]];
p[x] = u;
}
return p[x];
}

for (int i = 1; i <= n; i ++ )
{
p[i] = i;
d[i] = 0;
}

p[find(a)] = find(b);
d[find(a)] = distance;
```
2024-07-17 15:35:14.879 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]字符串哈希
2024-07-17 15:35:14.880 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 15:35:14.881 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]字符串哈希 
 [Insert_code]```
typedef unsigned long long ULL;
ULL h[N], p[N];

p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
h[i] = h[i - 1] * P + str[i];
p[i] = p[i - 1] * P;
}

ULL get(int l, int r)
{
return h[r] - h[l - 1] * p[r - l + 1];
}
```
2024-07-17 15:35:14.882 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]KMP
2024-07-17 15:35:14.882 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 15:35:14.884 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]KMP 
 [Insert_code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 15:35:14.885 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(单点修改)
2024-07-17 15:35:14.886 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 15:35:14.888 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(单点修改) 
 [Insert_code]```
int n,m;

struct node
{
int l,r;
int sum;
int lmax;
int rmax;
int tmax;
}tr[N*4];

void pushup(node &u,node &l,node &r)
{
u.sum=l.sum+r.sum;
u.lmax=max(l.lmax,l.sum+r.lmax);
u.rmax=max(r.rmax,r.sum+l.rmax);
u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}

void pushup(int u)
{
pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}

void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
else
{	tr[u]={l,r};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int x,int v)
{
if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v};
else
{
int mid=tr[u].l+tr[u].r>>1;
if(x<=mid) modify(u<<1,x,v);
else modify(u<<1|1,x,v);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
int mid=tr[u].l+tr[u].r>>1;
if(r<=mid) return query(u<<1,l,r);
else if(l>mid) return query(u<<1|1,l,r);
else
{
auto left=query(u<<1,l,r);
auto right=query(u<<1|1,l,r);
node res;
pushup(res,left,right);
return res;
}
}
}
```
2024-07-17 15:35:14.891 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]线段树(区间修改)
2024-07-17 15:35:14.891 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 15:35:14.894 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]线段树(区间修改) 
 [Insert_code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 15:35:14.897 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]树状数组
2024-07-17 15:35:14.897 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 15:35:14.898 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]树状数组 
 [Insert_code]```
int lowbit(int x)
{
return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
int res=0;
for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
return res;
}
```
2024-07-17 15:35:14.899 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:46 - [algorithm_name]Trie树
2024-07-17 15:35:14.899 | DEBUG    | sql.local_to_db:Name_And_Code_LocalToDB:47 - [algorithm_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 15:35:14.900 | DEBUG    | sql.mysql:Insert_Data_name_and_id:51 - [Insert_name]Trie树 
 [Insert_code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 15:35:14.901 | DEBUG    | __main__:init:20 - Code of local to DB successful
2024-07-17 15:35:15.613 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 15:37:54.639 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 15:42:29.266 | DEBUG    | __main__:algorithm_chat:29 - [message]快速排序
2024-07-17 15:42:29.267 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 15:42:29.936 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]快速排序
2024-07-17 15:42:31.197 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 15:42:31.198 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]```plaintext
(Quick Sort)
```
2024-07-17 15:42:32.435 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 15:42:32.435 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 15:42:32.437 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
[statue]2
[id]2
2024-07-17 15:42:32.438 | DEBUG    | chatbot.chatbot:GetResult:54 - [chatbot : The algorithm analysis result does not exist, analyze through code]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 22:07:41.239 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 22:08:29.338 | DEBUG    | __main__:algorithm_chat:29 - [message]可以区间查询，区间修改的算法
2024-07-17 22:08:29.338 | DEBUG    | __main__:algorithm_chat:30 - [history][]
2024-07-17 22:08:30.087 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]区间查询区间修改算法
2024-07-17 22:08:33.732 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n线段树（区间修改）\n过程:\n节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。\n核心功能:\neval 函数: 更新当前节点的值，考虑到乘法和加法的影响。\npushup 函数: 更新父节点的和，基于子节点的和。\npushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。\nbuild 函数: 构建线段树，初始化区间。\nmodify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。\nquery 函数: 查询给定区间的和，同时处理懒惰更新。\n\n应用场景: \n线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。\n线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。\n\n时间复杂度:\n建树: O(n)\n修改: O(logn)（使用懒惰标记）\n查询: O(logn)\n此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。\n\n[回答]\n(线段树区间修改)')]
2024-07-17 22:08:33.733 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](线段树区间修改)
2024-07-17 22:08:34.967 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]64
2024-07-17 22:08:34.968 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
2024-07-17 22:08:34.972 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]```
struct node
{
ll l,r;
ll sum;
ll add;
ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
root.mul=root.mul*mul%p;
root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
eval(tr[u<<1],tr[u].add,tr[u].mul);
eval(tr[u<<1|1],tr[u].add,tr[u].mul);
tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
if(l==r) tr[u]={l,r,w[r],0,1};
else
{	tr[u]={l,r,0,0,1};
int mid=l+r>>1;
build(u<<1,l,mid);
build(u<<1|1,mid+1,r);
pushup(u);
}
}

void modify(int u,int l,int r,int add,int mul)
{
if(tr[u].l>=l&&tr[u].r<=r)
{
eval(tr[u],add,mul);
}
else
{
pushdown(u);
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) modify(u<<1,l,r,add,mul);
if(r>mid) modify(u<<1|1,l,r,add,mul);
pushup(u);
}
}

node query(int u,int l,int r)
{
if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
else
{
pushdown(u);
node res;
res.sum=0;
int mid=tr[u].l+tr[u].r>>1;
if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
pushup(u);
return res;
}
}
```
[statue]1
[id]64
2024-07-17 22:09:06.565 | DEBUG    | chatbot.chatbot:GetResult:52 - [chatbot : Algorithm analysis results already exist]这段代码看起来是一个基于线段树的数据结构，用于处理区间查询和更新问题，包括乘法、加法以及区间求和。下面我将重新排版代码，并逐行添加注释。

```cpp
#include <cstdio> // 需要包含输入输出头文件，这里假设使用C++，如果是C需要改为#include <stdio.h>
#include <vector>

using namespace std;

const int N = 1e5 + 10; // 假设N是节点数量的常数，可以根据实际情况调整
const int p = 1e9 + 7; // 模数，用于求模运算

// 定义节点结构体，存储线段树节点的信息
struct Node {
    int l, r; // 当前节点表示的区间左右端点
    long long sum; // 区间和
    long long add; // 区间加法lazy标记
    long long mul; // 区间乘法lazy标记
} tr[N * 4]; // 存储线段树节点的数组

// 计算当前节点的值，考虑到乘法和加法的lazy标记
void eval(Node &root, int add, int mul) {
    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;
    root.mul = root.mul * mul % p;
    root.add = (root.add * mul + add) % p;
}

// 合并子节点的信息到当前节点
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 合并左右子节点的和
}

// 将当前节点的lazy标记下推到子节点
void pushdown(int u) {
    eval(tr[u << 1], tr[u].add, tr[u].mul); // 应用lazy标记到左子节点
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul); // 应用lazy标记到右子节点
    tr[u].add = 0, tr[u].mul = 1; // 清除当前节点的lazy标记
}

// 建立线段树
void build(int u, int l, int r) {
    if (l == r) {
        // 叶子节点，直接赋值
        tr[u] = {l, r, w[r], 0, 1}; // 注意这里有一个未定义的数组w[]，需要根据实际情况给出定义
    } else {
        // 内部节点，递归构建子树
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u); // 合并子节点的信息
    }
}

// 更新区间
void modify(int u, int l, int r, int add, int mul) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接修改
        eval(tr[u], add, mul);
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归更新子节点
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u); // 合并子节点的信息
    }
}

// 查询区间和
Node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接返回当前节点的信息
        return tr[u];
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归查询子节点
        pushdown(u);
        Node res = {0, 0, 0, 0, 1}; // 初始化返回结构体
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;
        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;
        return res; // 返回查询结果
    }
}

// 主函数或其他相关函数...
```

请注意，我在这段代码中添加了一些可能的遗漏，比如
2024-07-17 22:09:06.570 | DEBUG    | __main__:algorithm_chat:38 - [result]这段代码看起来是一个基于线段树的数据结构，用于处理区间查询和更新问题，包括乘法、加法以及区间求和。下面我将重新排版代码，并逐行添加注释。

```cpp
#include <cstdio> // 需要包含输入输出头文件，这里假设使用C++，如果是C需要改为#include <stdio.h>
#include <vector>

using namespace std;

const int N = 1e5 + 10; // 假设N是节点数量的常数，可以根据实际情况调整
const int p = 1e9 + 7; // 模数，用于求模运算

// 定义节点结构体，存储线段树节点的信息
struct Node {
    int l, r; // 当前节点表示的区间左右端点
    long long sum; // 区间和
    long long add; // 区间加法lazy标记
    long long mul; // 区间乘法lazy标记
} tr[N * 4]; // 存储线段树节点的数组

// 计算当前节点的值，考虑到乘法和加法的lazy标记
void eval(Node &root, int add, int mul) {
    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;
    root.mul = root.mul * mul % p;
    root.add = (root.add * mul + add) % p;
}

// 合并子节点的信息到当前节点
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 合并左右子节点的和
}

// 将当前节点的lazy标记下推到子节点
void pushdown(int u) {
    eval(tr[u << 1], tr[u].add, tr[u].mul); // 应用lazy标记到左子节点
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul); // 应用lazy标记到右子节点
    tr[u].add = 0, tr[u].mul = 1; // 清除当前节点的lazy标记
}

// 建立线段树
void build(int u, int l, int r) {
    if (l == r) {
        // 叶子节点，直接赋值
        tr[u] = {l, r, w[r], 0, 1}; // 注意这里有一个未定义的数组w[]，需要根据实际情况给出定义
    } else {
        // 内部节点，递归构建子树
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u); // 合并子节点的信息
    }
}

// 更新区间
void modify(int u, int l, int r, int add, int mul) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接修改
        eval(tr[u], add, mul);
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归更新子节点
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u); // 合并子节点的信息
    }
}

// 查询区间和
Node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接返回当前节点的信息
        return tr[u];
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归查询子节点
        pushdown(u);
        Node res = {0, 0, 0, 0, 1}; // 初始化返回结构体
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;
        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;
        return res; // 返回查询结果
    }
}

// 主函数或其他相关函数...
```

请注意，我在这段代码中添加了一些可能的遗漏，比如
[statue]1
[id]64
2024-07-17 22:09:06.577 | DEBUG    | __main__:algorithm_chat:41 - Insert successful
2024-07-17 22:09:33.969 | DEBUG    | __main__:algorithm_chat:29 - [message]可以区间查询，区间修改的算法
2024-07-17 22:09:33.969 | DEBUG    | __main__:algorithm_chat:30 - [history][['可以区间查询，区间修改的算法', '这段代码看起来是一个基于线段树的数据结构，用于处理区间查询和更新问题，包括乘法、加法以及区间求和。下面我将重新排版代码，并逐行添加注释。\n\n```cpp\n#include <cstdio> // 需要包含输入输出头文件，这里假设使用C++，如果是C需要改为#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e5 + 10; // 假设N是节点数量的常数，可以根据实际情况调整\nconst int p = 1e9 + 7; // 模数，用于求模运算\n\n// 定义节点结构体，存储线段树节点的信息\nstruct Node {\n    int l, r; // 当前节点表示的区间左右端点\n    long long sum; // 区间和\n    long long add; // 区间加法lazy标记\n    long long mul; // 区间乘法lazy标记\n} tr[N * 4]; // 存储线段树节点的数组\n\n// 计算当前节点的值，考虑到乘法和加法的lazy标记\nvoid eval(Node &root, int add, int mul) {\n    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;\n    root.mul = root.mul * mul % p;\n    root.add = (root.add * mul + add) % p;\n}\n\n// 合并子节点的信息到当前节点\nvoid pushup(int u) {\n    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 合并左右子节点的和\n}\n\n// 将当前节点的lazy标记下推到子节点\nvoid pushdown(int u) {\n    eval(tr[u << 1], tr[u].add, tr[u].mul); // 应用lazy标记到左子节点\n    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul); // 应用lazy标记到右子节点\n    tr[u].add = 0, tr[u].mul = 1; // 清除当前节点的lazy标记\n}\n\n// 建立线段树\nvoid build(int u, int l, int r) {\n    if (l == r) {\n        // 叶子节点，直接赋值\n        tr[u] = {l, r, w[r], 0, 1}; // 注意这里有一个未定义的数组w[]，需要根据实际情况给出定义\n    } else {\n        // 内部节点，递归构建子树\n        tr[u] = {l, r, 0, 0, 1};\n        int mid = l + r >> 1;\n        build(u << 1, l, mid);\n        build(u << 1 | 1, mid + 1, r);\n        pushup(u); // 合并子节点的信息\n    }\n}\n\n// 更新区间\nvoid modify(int u, int l, int r, int add, int mul) {\n    if (tr[u].l >= l && tr[u].r <= r) {\n        // 当前区间完全包含在目标区间内，直接修改\n        eval(tr[u], add, mul);\n    } else {\n        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归更新子节点\n        pushdown(u);\n        int mid = tr[u].l + tr[u].r >> 1;\n        if (l <= mid) modify(u << 1, l, r, add, mul);\n        if (r > mid) modify(u << 1 | 1, l, r, add, mul);\n        pushup(u); // 合并子节点的信息\n    }\n}\n\n// 查询区间和\nNode query(int u, int l, int r) {\n    if (tr[u].l >= l && tr[u].r <= r) {\n        // 当前区间完全包含在目标区间内，直接返回当前节点的信息\n        return tr[u];\n    } else {\n        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归查询子节点\n        pushdown(u);\n        Node res = {0, 0, 0, 0, 1}; // 初始化返回结构体\n        int mid = tr[u].l + tr[u].r >> 1;\n        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;\n        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;\n        return res; // 返回查询结果\n    }\n}\n\n// 主函数或其他相关函数...\n```\n\n请注意，我在这段代码中添加了一些可能的遗漏，比如']]
2024-07-17 22:09:33.971 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]区间查询区间修改算法
2024-07-17 22:09:46.161 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n线段树（区间修改）\n过程:\n节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。\n核心功能:\neval 函数: 更新当前节点的值，考虑到乘法和加法的影响。\npushup 函数: 更新父节点的和，基于子节点的和。\npushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。\nbuild 函数: 构建线段树，初始化区间。\nmodify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。\nquery 函数: 查询给定区间的和，同时处理懒惰更新。\n\n应用场景: \n线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。\n线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。\n\n时间复杂度:\n建树: O(n)\n修改: O(logn)（使用懒惰标记）\n查询: O(logn)\n此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。\n\n[回答]\n(线段树区间修改)')]
2024-07-17 22:09:46.162 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](线段树区间修改) 

根据您提供的信息，线段树是一种高效的数据结构，用于处理数组的区间查询和区间修改操作。具体到区间修改，它通过在每个节点上存储懒惰标记（lazy tag），如`add`和`mul`，来实现对区间的加法和乘法修改。以下是涉及的主要函数和操作：

- **eval 函数**: 用于更新当前节点的值，考虑到乘法和加法的影响。
- **pushup 函数**: 当子节点的值更新后，用来更新父节点的区间和。
- **pushdown 函数**: 将当前节点的懒惰更新传播到子节点，这是延迟更新技术的核心。
- **build 函数**: 构建线段树，初始化每个节点的区间和等属性。
- **modify 函数**: 对给定区间进行加法或乘法修改，利用懒惰标记来优化性能，使得修改操作的时间复杂度降低到O(logn)。
- **query 函数**: 查询给定区间的和，同时处理可能存在的懒惰更新。

这种实现允许线段树在处理动态数组时，能够快速进行区间更新和查询，特别适用于需要频繁更新和查询的场景。

时间复杂度方面，线段树的以下操作达到：

- 建树：O(n)
- 修改：O(logn)（使用懒惰标记）
- 查询：O(logn)

综上所述，线段树是一种灵活、高效的数据结构，适用于处理各种需要区间更新和区间查询的问题。
2024-07-17 22:09:48.263 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]64
```python
tool_call()
```
2024-07-17 22:09:48.265 | ERROR    | chatbot.algorithm_code:GetAlgorithmCode:76 - [algorithm_code :]知识库中无该算法模板
2024-07-17 22:09:48.266 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]知识库中无该算法模板
[statue]0
[id]64
```python
tool_call()
```
2024-07-17 22:10:19.141 | DEBUG    | __main__:algorithm_chat:29 - [message]可以区间查询，区间修改的算法
2024-07-17 22:10:19.141 | DEBUG    | __main__:algorithm_chat:30 - [history][['可以区间查询，区间修改的算法', '这段代码看起来是一个基于线段树的数据结构，用于处理区间查询和更新问题，包括乘法、加法以及区间求和。下面我将重新排版代码，并逐行添加注释。\n\n```cpp\n#include <cstdio> // 需要包含输入输出头文件，这里假设使用C++，如果是C需要改为#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 1e5 + 10; // 假设N是节点数量的常数，可以根据实际情况调整\nconst int p = 1e9 + 7; // 模数，用于求模运算\n\n// 定义节点结构体，存储线段树节点的信息\nstruct Node {\n    int l, r; // 当前节点表示的区间左右端点\n    long long sum; // 区间和\n    long long add; // 区间加法lazy标记\n    long long mul; // 区间乘法lazy标记\n} tr[N * 4]; // 存储线段树节点的数组\n\n// 计算当前节点的值，考虑到乘法和加法的lazy标记\nvoid eval(Node &root, int add, int mul) {\n    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;\n    root.mul = root.mul * mul % p;\n    root.add = (root.add * mul + add) % p;\n}\n\n// 合并子节点的信息到当前节点\nvoid pushup(int u) {\n    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 合并左右子节点的和\n}\n\n// 将当前节点的lazy标记下推到子节点\nvoid pushdown(int u) {\n    eval(tr[u << 1], tr[u].add, tr[u].mul); // 应用lazy标记到左子节点\n    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul); // 应用lazy标记到右子节点\n    tr[u].add = 0, tr[u].mul = 1; // 清除当前节点的lazy标记\n}\n\n// 建立线段树\nvoid build(int u, int l, int r) {\n    if (l == r) {\n        // 叶子节点，直接赋值\n        tr[u] = {l, r, w[r], 0, 1}; // 注意这里有一个未定义的数组w[]，需要根据实际情况给出定义\n    } else {\n        // 内部节点，递归构建子树\n        tr[u] = {l, r, 0, 0, 1};\n        int mid = l + r >> 1;\n        build(u << 1, l, mid);\n        build(u << 1 | 1, mid + 1, r);\n        pushup(u); // 合并子节点的信息\n    }\n}\n\n// 更新区间\nvoid modify(int u, int l, int r, int add, int mul) {\n    if (tr[u].l >= l && tr[u].r <= r) {\n        // 当前区间完全包含在目标区间内，直接修改\n        eval(tr[u], add, mul);\n    } else {\n        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归更新子节点\n        pushdown(u);\n        int mid = tr[u].l + tr[u].r >> 1;\n        if (l <= mid) modify(u << 1, l, r, add, mul);\n        if (r > mid) modify(u << 1 | 1, l, r, add, mul);\n        pushup(u); // 合并子节点的信息\n    }\n}\n\n// 查询区间和\nNode query(int u, int l, int r) {\n    if (tr[u].l >= l && tr[u].r <= r) {\n        // 当前区间完全包含在目标区间内，直接返回当前节点的信息\n        return tr[u];\n    } else {\n        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归查询子节点\n        pushdown(u);\n        Node res = {0, 0, 0, 0, 1}; // 初始化返回结构体\n        int mid = tr[u].l + tr[u].r >> 1;\n        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;\n        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;\n        return res; // 返回查询结果\n    }\n}\n\n// 主函数或其他相关函数...\n```\n\n请注意，我在这段代码中添加了一些可能的遗漏，比如'], ['可以区间查询，区间修改的算法', '知识库中无该算法模板']]
2024-07-17 22:10:19.142 | DEBUG    | __main__:algorithm_chat:33 - [message after noise removal]区间查询区间修改算法
2024-07-17 22:10:22.773 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n线段树（区间修改）\n过程:\n节点结构 (node): 每个节点包含区间的左右边界 l 和 r，当前区间的和 sum，以及懒惰标记 add 和 mul，用于延迟更新。\n核心功能:\neval 函数: 更新当前节点的值，考虑到乘法和加法的影响。\npushup 函数: 更新父节点的和，基于子节点的和。\npushdown 函数: 将当前节点的懒惰更新传播到子节点, 使用懒惰标记。\nbuild 函数: 构建线段树，初始化区间。\nmodify 函数: 对给定区间进行加法和乘法修改，使用懒惰传播优化性能。\nquery 函数: 查询给定区间的和，同时处理懒惰更新。\n\n应用场景: \n线段树适用于需要频繁更新和查询的场景，如在线性时间内处理动态数组的区间和或其他聚合查询。\n线段树是一种数据结构，用于高效处理数组的区间查询和区间修改操作。此实现支持对区间进行加法和乘法修改，并能够在查询时合并结果。\n\n时间复杂度:\n建树: O(n)\n修改: O(logn)（使用懒惰标记）\n查询: O(logn)\n此线段树实现灵活且高效，适合于各种需要区间更新和查询的算法问题。\n\n[回答]\n(线段树区间修改)')]
2024-07-17 22:10:22.773 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](线段树区间修改)
2024-07-17 22:10:23.730 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]64
2024-07-17 22:10:23.731 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]这段代码看起来是一个基于线段树的数据结构，用于处理区间查询和更新问题，包括乘法、加法以及区间求和。下面我将重新排版代码，并逐行添加注释。

```cpp
#include <cstdio> // 需要包含输入输出头文件，这里假设使用C++，如果是C需要改为#include <stdio.h>
#include <vector>

using namespace std;

const int N = 1e5 + 10; // 假设N是节点数量的常数，可以根据实际情况调整
const int p = 1e9 + 7; // 模数，用于求模运算

// 定义节点结构体，存储线段树节点的信息
struct Node {
    int l, r; // 当前节点表示的区间左右端点
    long long sum; // 区间和
    long long add; // 区间加法lazy标记
    long long mul; // 区间乘法lazy标记
} tr[N * 4]; // 存储线段树节点的数组

// 计算当前节点的值，考虑到乘法和加法的lazy标记
void eval(Node &root, int add, int mul) {
    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;
    root.mul = root.mul * mul % p;
    root.add = (root.add * mul + add) % p;
}

// 合并子节点的信息到当前节点
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 合并左右子节点的和
}

// 将当前节点的lazy标记下推到子节点
void pushdown(int u) {
    eval(tr[u << 1], tr[u].add, tr[u].mul); // 应用lazy标记到左子节点
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul); // 应用lazy标记到右子节点
    tr[u].add = 0, tr[u].mul = 1; // 清除当前节点的lazy标记
}

// 建立线段树
void build(int u, int l, int r) {
    if (l == r) {
        // 叶子节点，直接赋值
        tr[u] = {l, r, w[r], 0, 1}; // 注意这里有一个未定义的数组w[]，需要根据实际情况给出定义
    } else {
        // 内部节点，递归构建子树
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u); // 合并子节点的信息
    }
}

// 更新区间
void modify(int u, int l, int r, int add, int mul) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接修改
        eval(tr[u], add, mul);
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归更新子节点
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u); // 合并子节点的信息
    }
}

// 查询区间和
Node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接返回当前节点的信息
        return tr[u];
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归查询子节点
        pushdown(u);
        Node res = {0, 0, 0, 0, 1}; // 初始化返回结构体
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;
        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;
        return res; // 返回查询结果
    }
}

// 主函数或其他相关函数...
```

请注意，我在这段代码中添加了一些可能的遗漏，比如
2024-07-17 22:10:23.734 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]这段代码看起来是一个基于线段树的数据结构，用于处理区间查询和更新问题，包括乘法、加法以及区间求和。下面我将重新排版代码，并逐行添加注释。

```cpp
#include <cstdio> // 需要包含输入输出头文件，这里假设使用C++，如果是C需要改为#include <stdio.h>
#include <vector>

using namespace std;

const int N = 1e5 + 10; // 假设N是节点数量的常数，可以根据实际情况调整
const int p = 1e9 + 7; // 模数，用于求模运算

// 定义节点结构体，存储线段树节点的信息
struct Node {
    int l, r; // 当前节点表示的区间左右端点
    long long sum; // 区间和
    long long add; // 区间加法lazy标记
    long long mul; // 区间乘法lazy标记
} tr[N * 4]; // 存储线段树节点的数组

// 计算当前节点的值，考虑到乘法和加法的lazy标记
void eval(Node &root, int add, int mul) {
    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;
    root.mul = root.mul * mul % p;
    root.add = (root.add * mul + add) % p;
}

// 合并子节点的信息到当前节点
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 合并左右子节点的和
}

// 将当前节点的lazy标记下推到子节点
void pushdown(int u) {
    eval(tr[u << 1], tr[u].add, tr[u].mul); // 应用lazy标记到左子节点
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul); // 应用lazy标记到右子节点
    tr[u].add = 0, tr[u].mul = 1; // 清除当前节点的lazy标记
}

// 建立线段树
void build(int u, int l, int r) {
    if (l == r) {
        // 叶子节点，直接赋值
        tr[u] = {l, r, w[r], 0, 1}; // 注意这里有一个未定义的数组w[]，需要根据实际情况给出定义
    } else {
        // 内部节点，递归构建子树
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u); // 合并子节点的信息
    }
}

// 更新区间
void modify(int u, int l, int r, int add, int mul) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接修改
        eval(tr[u], add, mul);
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归更新子节点
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u); // 合并子节点的信息
    }
}

// 查询区间和
Node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接返回当前节点的信息
        return tr[u];
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归查询子节点
        pushdown(u);
        Node res = {0, 0, 0, 0, 1}; // 初始化返回结构体
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;
        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;
        return res; // 返回查询结果
    }
}

// 主函数或其他相关函数...
```

请注意，我在这段代码中添加了一些可能的遗漏，比如
[statue]2
[id]64
2024-07-17 22:10:23.738 | DEBUG    | chatbot.chatbot:GetResult:54 - [chatbot : The algorithm analysis result does not exist, analyze through code]这段代码看起来是一个基于线段树的数据结构，用于处理区间查询和更新问题，包括乘法、加法以及区间求和。下面我将重新排版代码，并逐行添加注释。

```cpp
#include <cstdio> // 需要包含输入输出头文件，这里假设使用C++，如果是C需要改为#include <stdio.h>
#include <vector>

using namespace std;

const int N = 1e5 + 10; // 假设N是节点数量的常数，可以根据实际情况调整
const int p = 1e9 + 7; // 模数，用于求模运算

// 定义节点结构体，存储线段树节点的信息
struct Node {
    int l, r; // 当前节点表示的区间左右端点
    long long sum; // 区间和
    long long add; // 区间加法lazy标记
    long long mul; // 区间乘法lazy标记
} tr[N * 4]; // 存储线段树节点的数组

// 计算当前节点的值，考虑到乘法和加法的lazy标记
void eval(Node &root, int add, int mul) {
    root.sum = (root.sum * mul + (root.r - root.l + 1) * add) % p;
    root.mul = root.mul * mul % p;
    root.add = (root.add * mul + add) % p;
}

// 合并子节点的信息到当前节点
void pushup(int u) {
    tr[u].sum = (tr[u << 1].sum + tr[u << 1 | 1].sum) % p; // 合并左右子节点的和
}

// 将当前节点的lazy标记下推到子节点
void pushdown(int u) {
    eval(tr[u << 1], tr[u].add, tr[u].mul); // 应用lazy标记到左子节点
    eval(tr[u << 1 | 1], tr[u].add, tr[u].mul); // 应用lazy标记到右子节点
    tr[u].add = 0, tr[u].mul = 1; // 清除当前节点的lazy标记
}

// 建立线段树
void build(int u, int l, int r) {
    if (l == r) {
        // 叶子节点，直接赋值
        tr[u] = {l, r, w[r], 0, 1}; // 注意这里有一个未定义的数组w[]，需要根据实际情况给出定义
    } else {
        // 内部节点，递归构建子树
        tr[u] = {l, r, 0, 0, 1};
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u); // 合并子节点的信息
    }
}

// 更新区间
void modify(int u, int l, int r, int add, int mul) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接修改
        eval(tr[u], add, mul);
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归更新子节点
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, add, mul);
        if (r > mid) modify(u << 1 | 1, l, r, add, mul);
        pushup(u); // 合并子节点的信息
    }
}

// 查询区间和
Node query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) {
        // 当前区间完全包含在目标区间内，直接返回当前节点的信息
        return tr[u];
    } else {
        // 当前区间与目标区间部分重叠，需要下推lazy标记，并递归查询子节点
        pushdown(u);
        Node res = {0, 0, 0, 0, 1}; // 初始化返回结构体
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) res.sum += query(u << 1, l, r).sum % p;
        if (r > mid) res.sum += query(u << 1 | 1, l, r).sum % p;
        return res; // 返回查询结果
    }
}

// 主函数或其他相关函数...
```

请注意，我在这段代码中添加了一些可能的遗漏，比如
2024-07-17 22:33:29.347 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 22:38:46.705 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 22:45:07.220 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 22:48:08.956 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 22:50:32.902 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 23:18:27.953 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 23:19:05.618 | DEBUG    | __main__:algorithm_chat:43 - [message]快速排序算法
2024-07-17 23:19:05.619 | DEBUG    | __main__:algorithm_chat:44 - [history][]
2024-07-17 23:19:05.619 | DEBUG    | __main__:algorithm_chat:45 - [slider_value_now]0.1
2024-07-17 23:19:05.620 | DEBUG    | __main__:algorithm_chat:46 - [bot_model_now]算法模板模式
2024-07-17 23:19:06.341 | DEBUG    | __main__:algorithm_chat:49 - [message after noise removal]快速排序算法
2024-07-17 23:19:09.777 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一个枢轴元素将待排序序列分成两部分，其中一部分元素比枢轴元素小，另一部分元素比枢轴元素大。然后对这两部分元素分别进行递归排序。具体步骤如下：\n选择一个枢轴元素（这里选择的是区间中间的元素）。\n通过交换元素，将比枢轴小的元素放在左边，比枢轴大的元素放在右边。\n递归地对左右子区间进行快速排序。\n\n应用场景:\n快速排序适用于各种需要对数据进行排序的场景，如数据库查询优化、计算机图形学中的图像处理、外排序算法等。它由于其平均时间复杂度较低，且空间复杂度为O(log n)，在许多实际应用中被广泛使用。\n\n时间复杂度:\n快速排序在平均情况下的时间复杂度为 O(n log n)，这是因为每次划分大约能将数组对半分，递归树的高度大约为 log n，每层需要的时间为 O(n)。然而，在最坏情况下（如每次选择的枢轴都是当前区间的最小或最大元素），时间复杂度为 O(n^2)。通过随机化或改进枢轴选择方法（如三数取中），可以在很大程度上避免最坏情况。\n\n[回答]\n(快速排序)')]
2024-07-17 23:19:09.777 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]```plaintext
(快速排序)
```
2024-07-17 23:19:10.810 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]2
2024-07-17 23:19:10.812 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 23:19:10.815 | DEBUG    | chatbot.chatbot:GetResult:48 - chatbot:
[code]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
[statue]2
[id]2
2024-07-17 23:19:10.818 | DEBUG    | chatbot.chatbot:GetResult:54 - [chatbot : The algorithm analysis result does not exist, analyze through code]下面是重新排版并添加逐行注释的代码：

```cpp
// 快速排序函数
void quick_sort(int q[], int l, int r) {
    // 如果左边界大于等于右边界，说明子数组已经有序，直接返回
    if (l >= r) return;

    // 初始化i和j分别为左边界和右边界的前一个位置
    // x为子数组的中位数，这里使用(l + r) / 2可能会溢出，因此使用(l + r) >> 1来避免
    int i = l - 1, j = r + 1, x = q[l + r >> 1];

    // 当i小于j时，进行以下循环
    while (i < j) {
        // 向右移动i，直到找到一个大于等于x的元素
        do i ++ ; while (q[i] < x);
        // 向左移动j，直到找到一个小于等于x的元素
        do j -- ; while (q[j] > x);
        // 如果i仍然小于j，说明此时q[i]和q[j]应该交换位置
        if (i < j) swap(q[i], q[j]);
    }

    // 递归地对左半部分和右半部分进行快速排序
    quick_sort(q, l, j); // 排序左半部分
    quick_sort(q, j + 1, r); // 排序右半部分
}

// 交换两个元素的值
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
```

注意：上面的代码片段中，`swap`函数没有给出定义，但根据上下文，我假设有一个标准的交换函数存在。如果实际上并没有提供这个函数，那么需要自己实现一个交换函数，如上面代码中所示。

此外，由于代码是C++风格，但在C++中应该包含`<algorithm>`头文件并使用`std::swap`函数，除非已经定义了一个自己的`swap`函数。如果使用C++标准库中的`std::swap`，则不需要自己实现`swap`函数，直接使用`std::swap(q[i], q[j]);`即可。
2024-07-17 23:19:49.297 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]0.55
2024-07-17 23:19:55.929 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]算法交流模式
2024-07-17 23:19:59.353 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]0.35
2024-07-17 23:20:02.734 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]算法模板模式
2024-07-17 23:41:24.942 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 23:42:50.818 | DEBUG    | __main__:algorithm_chat:42 - [message]归并排序算法模板
2024-07-17 23:42:50.818 | DEBUG    | __main__:algorithm_chat:43 - [history][]
2024-07-17 23:42:50.818 | DEBUG    | __main__:algorithm_chat:44 - [slider_value_now]0.1
2024-07-17 23:42:50.825 | DEBUG    | __main__:algorithm_chat:45 - [bot_model_now]算法模板模式
2024-07-17 23:42:51.526 | DEBUG    | __main__:algorithm_chat:48 - [message after noise removal]归并排序算法模板
2024-07-17 23:43:02.260 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n归并排序（Merge Sort）是一种基于分治法的高效排序算法。其主要思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序后的子数组合并成一个有序数组。具体步骤如下：\n将数组分成两个子数组，分别对这两个子数组进行递归排序。\n合并两个已排序的子数组。\n重复上述过程，直到整个数组有序。\n\n应用场景:\n归并排序适用于需要稳定排序的大型数据集，尤其在外部排序（如磁盘排序）中表现良好。由于其稳定性和时间复杂度，它被广泛应用于各种排序任务，如商业数据处理、并行计算中的排序、以及需要处理大数据量的应用程序。\n\n时间复杂度:\n归并排序的时间复杂度为 O(n log n)，其中 n 为数组的长度。其主要原因是每次将数组分成两部分，递归深度为 log n，每层的合并操作需要 O(n) 时间。归并排序的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组。\n\n[回答]\n(归并排序)')]
2024-07-17 23:43:02.260 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]以下是归并排序算法的一个基本模板：

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    def merge(left, right):
        # 合并两个有序数组
        merged, left_index, right_index = [], 0, 0
        while left_index < len(left) and right_index < len(right):
            if left[left_index] <= right[right_index]:
                merged.append(left[left_index])
                left_index += 1
            else:
                merged.append(right[right_index])
                right_index += 1
        # 将剩余的元素添加到合并后的数组中
        merged.extend(left[left_index:])
        merged.extend(right[right_index:])
        return merged

    # 分治法递归分解数组
    middle = len(arr) // 2
    left = merge_sort(arr[:middle])
    right = merge_sort(arr[middle:])
    return merge(left, right)

# 使用示例
array_to_sort = [34, 7, 23, 32, 5, 62]
sorted_array = merge_sort(array_to_sort)
print(sorted_array)
```

在这个模板中，`merge_sort` 函数首先检查数组的长度，如果长度小于或等于1，则直接返回数组，因为长度为1的数组已经是有序的。然后，它定义了一个内部函数 `merge`，用来合并两个有序数组。最后，`merge_sort` 通过递归方式将数组分为左右两部分，并对它们分别进行排序，然后调用 `merge` 函数将它们合并成一个有序数组。
2024-07-17 23:43:03.706 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]3
2024-07-17 23:43:03.706 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
2024-07-17 23:43:03.707 | DEBUG    | chatbot.chatbot:CodeAnalysis:59 - chatbot:
[code]```
void merge_sort(int q[], int l, int r)
{
if (l >= r) return;

int mid = l + r >> 1;
merge_sort(q, l, mid);
merge_sort(q, mid + 1, r);

int k = 0, i = l, j = mid + 1;
while (i <= mid && j <= r)
if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
else tmp[k ++ ] = q[j ++ ];

while (i <= mid) tmp[k ++ ] = q[i ++ ];
while (j <= r) tmp[k ++ ] = q[j ++ ];

for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```
[statue]1
[id]3
2024-07-17 23:43:21.836 | DEBUG    | chatbot.chatbot:CodeAnalysis:63 - [chatbot : Algorithm analysis results already exist]这段代码是一个归并排序算法的实现。以下是重新排版并加上逐行注释的代码：

```c
#include <stdio.h> // 需要包含此头文件以使用printf等函数

// 定义全局数组以存储合并过程中的临时数据
int tmp[100010]; // 假设数组大小足够大，以存储排序过程中的临时数据

// 归并排序函数
void merge_sort(int q[], int l, int r) {
    // 如果当前区间只有一个元素或者无元素，直接返回
    if (l >= r) return;

    // 计算中间位置
    int mid = l + r >> 1; // 等同于(l + r) / 2，使用位运算提高效率

    // 递归对左半部分进行排序
    merge_sort(q, l, mid);

    // 递归对右半部分进行排序
    merge_sort(q, mid + 1, r);

    // 合并两个有序数组
    int k = 0, i = l, j = mid + 1;

    // 当两个指针都没有达到各自数组的末尾时，比较并合并
    while (i <= mid && j <= r) {
        // 如果左边的元素小于右边的，将左边的元素加入临时数组
        if (q[i] < q[j]) tmp[k++] = q[i++];
        // 否则，将右边的元素加入临时数组
        else tmp[k++] = q[j++];
    }

    // 将左边剩余的元素加入临时数组
    while (i <= mid) tmp[k++] = q[i++];

    // 将右边剩余的元素加入临时数组
    while (j <= r) tmp[k++] = q[j++];

    // 将临时数组中的元素写回原数组
    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}

// 注意：该代码段没有定义主函数来执行排序，也没有输出结果。
// 主函数需要自己定义，并在其中调用merge_sort函数。
```

请注意，代码中使用了全局数组`tmp`来存储合并过程中的数据。在实际应用中，这可能不是一个好的做法，因为如果排序的数组很大，那么全局数组可能需要很大的内存空间，并且可能存在内存浪费的问题。更好的做法是在需要的时候动态分配内存。

另外，由于代码中没有包含主函数，也没有任何输出语句，所以无法直接执行这段代码来观察排序结果。你需要在主函数中调用`merge_sort`函数，并且在适当的位置加上输出语句来查看排序效果。
2024-07-17 23:43:21.840 | DEBUG    | __main__:algorithm_chat:54 - [result]这段代码是一个归并排序算法的实现。以下是重新排版并加上逐行注释的代码：

```c
#include <stdio.h> // 需要包含此头文件以使用printf等函数

// 定义全局数组以存储合并过程中的临时数据
int tmp[100010]; // 假设数组大小足够大，以存储排序过程中的临时数据

// 归并排序函数
void merge_sort(int q[], int l, int r) {
    // 如果当前区间只有一个元素或者无元素，直接返回
    if (l >= r) return;

    // 计算中间位置
    int mid = l + r >> 1; // 等同于(l + r) / 2，使用位运算提高效率

    // 递归对左半部分进行排序
    merge_sort(q, l, mid);

    // 递归对右半部分进行排序
    merge_sort(q, mid + 1, r);

    // 合并两个有序数组
    int k = 0, i = l, j = mid + 1;

    // 当两个指针都没有达到各自数组的末尾时，比较并合并
    while (i <= mid && j <= r) {
        // 如果左边的元素小于右边的，将左边的元素加入临时数组
        if (q[i] < q[j]) tmp[k++] = q[i++];
        // 否则，将右边的元素加入临时数组
        else tmp[k++] = q[j++];
    }

    // 将左边剩余的元素加入临时数组
    while (i <= mid) tmp[k++] = q[i++];

    // 将右边剩余的元素加入临时数组
    while (j <= r) tmp[k++] = q[j++];

    // 将临时数组中的元素写回原数组
    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}

// 注意：该代码段没有定义主函数来执行排序，也没有输出结果。
// 主函数需要自己定义，并在其中调用merge_sort函数。
```

请注意，代码中使用了全局数组`tmp`来存储合并过程中的数据。在实际应用中，这可能不是一个好的做法，因为如果排序的数组很大，那么全局数组可能需要很大的内存空间，并且可能存在内存浪费的问题。更好的做法是在需要的时候动态分配内存。

另外，由于代码中没有包含主函数，也没有任何输出语句，所以无法直接执行这段代码来观察排序结果。你需要在主函数中调用`merge_sort`函数，并且在适当的位置加上输出语句来查看排序效果。
[statue]1
[id]3
2024-07-17 23:43:21.855 | DEBUG    | __main__:algorithm_chat:57 - Insert successful
2024-07-17 23:44:19.366 | DEBUG    | __main__:algorithm_chat:42 - [message]整数二分
2024-07-17 23:44:19.366 | DEBUG    | __main__:algorithm_chat:43 - [history][['归并排序算法模板', '这段代码是一个归并排序算法的实现。以下是重新排版并加上逐行注释的代码：\n\n```c\n#include <stdio.h> // 需要包含此头文件以使用printf等函数\n\n// 定义全局数组以存储合并过程中的临时数据\nint tmp[100010]; // 假设数组大小足够大，以存储排序过程中的临时数据\n\n// 归并排序函数\nvoid merge_sort(int q[], int l, int r) {\n    // 如果当前区间只有一个元素或者无元素，直接返回\n    if (l >= r) return;\n\n    // 计算中间位置\n    int mid = l + r >> 1; // 等同于(l + r) / 2，使用位运算提高效率\n\n    // 递归对左半部分进行排序\n    merge_sort(q, l, mid);\n\n    // 递归对右半部分进行排序\n    merge_sort(q, mid + 1, r);\n\n    // 合并两个有序数组\n    int k = 0, i = l, j = mid + 1;\n\n    // 当两个指针都没有达到各自数组的末尾时，比较并合并\n    while (i <= mid && j <= r) {\n        // 如果左边的元素小于右边的，将左边的元素加入临时数组\n        if (q[i] < q[j]) tmp[k++] = q[i++];\n        // 否则，将右边的元素加入临时数组\n        else tmp[k++] = q[j++];\n    }\n\n    // 将左边剩余的元素加入临时数组\n    while (i <= mid) tmp[k++] = q[i++];\n\n    // 将右边剩余的元素加入临时数组\n    while (j <= r) tmp[k++] = q[j++];\n\n    // 将临时数组中的元素写回原数组\n    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];\n}\n\n// 注意：该代码段没有定义主函数来执行排序，也没有输出结果。\n// 主函数需要自己定义，并在其中调用merge_sort函数。\n```\n\n请注意，代码中使用了全局数组`tmp`来存储合并过程中的数据。在实际应用中，这可能不是一个好的做法，因为如果排序的数组很大，那么全局数组可能需要很大的内存空间，并且可能存在内存浪费的问题。更好的做法是在需要的时候动态分配内存。\n\n另外，由于代码中没有包含主函数，也没有任何输出语句，所以无法直接执行这段代码来观察排序结果。你需要在主函数中调用`merge_sort`函数，并且在适当的位置加上输出语句来查看排序效果。']]
2024-07-17 23:44:19.366 | DEBUG    | __main__:algorithm_chat:44 - [slider_value_now]0.1
2024-07-17 23:44:19.366 | DEBUG    | __main__:algorithm_chat:45 - [bot_model_now]算法模板模式
2024-07-17 23:44:19.366 | DEBUG    | __main__:algorithm_chat:48 - [message after noise removal]整数二分
2024-07-17 23:44:20.476 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程:\n整数二分模板用于在给定区间内高效查找满足特定条件的整数。主要通过定义一个检查函数 check(x) 来判断某个值是否满足条件，然后通过二分查找算法在区间 [l, r] 中寻找满足条件的边界值。此模板包含两种实现方式：\nbsearch_1：适用于查找最小的满足条件的值，使用 mid 为左半边的上界。\nbsearch_2：适用于查找最大的满足条件的值，使用 mid 为右半边的下界。\n\n应用场景:\n该模板广泛应用于需要通过条件约束来确定数值边界的场景，如最优化问题、搜索问题和计数问题等。具体应用包括寻找最小/大阈值、最优分割点、资源分配等。\n\n时间复杂度:\n二分查找的时间复杂度为 O(log (r - l))，其中 l 和 r 分别为查找区间的左右边界。这使得二分查找在处理大范围数据时仍能保持高效性能。由于每次都能将搜索空间减少一半，因此在解决相关问题时非常高效。\n\n[回答]\n(整数二分)')]
2024-07-17 23:44:20.477 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]```plaintext
(整数二分)
```
2024-07-17 23:44:21.727 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]4
2024-07-17 23:44:21.727 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
2024-07-17 23:44:21.727 | DEBUG    | chatbot.chatbot:CodeAnalysis:59 - chatbot:
[code]```
bool check(int x) {/* ... */}

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
while (l < r)
{
int mid = l + r >> 1;
if (check(mid)) r = mid;
else l = mid + 1;
}
return l;
}
int bsearch_2(int l, int r)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (check(mid)) l = mid;
else r = mid - 1;
}
return l;
}
```
[statue]1
[id]4
2024-07-17 23:44:42.372 | DEBUG    | chatbot.chatbot:CodeAnalysis:63 - [chatbot : Algorithm analysis results already exist]下面是重新排版并添加逐行注释的代码：

```cpp
// 定义一个检查函数，用于检查某个整数x是否满足特定条件
bool check(int x) {
    // ... 实现特定条件的检查逻辑
}

// 二分查找函数1：当区间[l, r]被划分为[l, mid]和[mid + 1, r]时使用
int bsearch_1(int l, int r) {
    // 当左边界小于右边界时，继续进行二分查找
    while (l < r) {
        // 计算中点，这里使用了位运算符进行除以2的操作
        int mid = l + r >> 1; // 等同于(l + r) / 2，但位运算更快
        // 如果check函数返回true，表示满足条件，移动右边界到mid
        if (check(mid)) r = mid;
        // 否则，移动左边界到mid+1，因为我们要找的值在右半部分
        else l = mid + 1;
    }
    // 循环结束后，l和r会相等，此时返回l或r都可以，这是我们要找的满足条件的值
    return l;
}

// 二分查找函数2：与bsearch_1类似，但是当区间划分不同时使用
int bsearch_2(int l, int r) {
    // 当左边界小于右边界时，继续进行二分查找
    while (l < r) {
        // 计算中点，这里使用了位运算符进行除以2的操作，并且加1是为了向上取整
        int mid = l + r + 1 >> 1; // 等同于(l + r + 1) / 2，但位运算更快，向上取整
        // 如果check函数返回true，表示满足条件，移动左边界到mid
        if (check(mid)) l = mid;
        // 否则，移动右边界到mid-1，因为我们要找的值在左半部分
        else r = mid - 1;
    }
    // 循环结束后，l和r会相等，此时返回l或r都可以，这是我们要找的满足条件的值
    return l;
}
```

请注意，原始代码中的 `check` 函数没有给出具体实现，所以这里我只是简单地保留了函数原型，并假设它用于检查某种特定条件。另外，二分查找的实现依赖于 `check` 函数的返回值来决定搜索的方向。在 `bsearch_1` 中，如果 `check(mid)` 为 `true`，表示我们找到了一个满足条件的值，但可能还有更小的值满足条件，因此我们继续在左半部分搜索。在 `bsearch_2` 中，如果 `check(mid)` 为 `true`，我们则直接将左边界移动到 `mid`，因为我们要找的是第一个满足条件的值。两个函数的主要区别在于中点的计算和边界移动的逻辑。
2024-07-17 23:44:42.382 | DEBUG    | __main__:algorithm_chat:54 - [result]下面是重新排版并添加逐行注释的代码：

```cpp
// 定义一个检查函数，用于检查某个整数x是否满足特定条件
bool check(int x) {
    // ... 实现特定条件的检查逻辑
}

// 二分查找函数1：当区间[l, r]被划分为[l, mid]和[mid + 1, r]时使用
int bsearch_1(int l, int r) {
    // 当左边界小于右边界时，继续进行二分查找
    while (l < r) {
        // 计算中点，这里使用了位运算符进行除以2的操作
        int mid = l + r >> 1; // 等同于(l + r) / 2，但位运算更快
        // 如果check函数返回true，表示满足条件，移动右边界到mid
        if (check(mid)) r = mid;
        // 否则，移动左边界到mid+1，因为我们要找的值在右半部分
        else l = mid + 1;
    }
    // 循环结束后，l和r会相等，此时返回l或r都可以，这是我们要找的满足条件的值
    return l;
}

// 二分查找函数2：与bsearch_1类似，但是当区间划分不同时使用
int bsearch_2(int l, int r) {
    // 当左边界小于右边界时，继续进行二分查找
    while (l < r) {
        // 计算中点，这里使用了位运算符进行除以2的操作，并且加1是为了向上取整
        int mid = l + r + 1 >> 1; // 等同于(l + r + 1) / 2，但位运算更快，向上取整
        // 如果check函数返回true，表示满足条件，移动左边界到mid
        if (check(mid)) l = mid;
        // 否则，移动右边界到mid-1，因为我们要找的值在左半部分
        else r = mid - 1;
    }
    // 循环结束后，l和r会相等，此时返回l或r都可以，这是我们要找的满足条件的值
    return l;
}
```

请注意，原始代码中的 `check` 函数没有给出具体实现，所以这里我只是简单地保留了函数原型，并假设它用于检查某种特定条件。另外，二分查找的实现依赖于 `check` 函数的返回值来决定搜索的方向。在 `bsearch_1` 中，如果 `check(mid)` 为 `true`，表示我们找到了一个满足条件的值，但可能还有更小的值满足条件，因此我们继续在左半部分搜索。在 `bsearch_2` 中，如果 `check(mid)` 为 `true`，我们则直接将左边界移动到 `mid`，因为我们要找的是第一个满足条件的值。两个函数的主要区别在于中点的计算和边界移动的逻辑。
[statue]1
[id]4
2024-07-17 23:44:42.399 | DEBUG    | __main__:algorithm_chat:57 - Insert successful
2024-07-17 23:49:15.039 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-17 23:49:47.307 | DEBUG    | __main__:algorithm_chat:42 - [message]可以快速判断字符串是否为子串
2024-07-17 23:49:47.307 | DEBUG    | __main__:algorithm_chat:43 - [history][]
2024-07-17 23:49:47.307 | DEBUG    | __main__:algorithm_chat:44 - [slider_value_now]0.1
2024-07-17 23:49:47.307 | DEBUG    | __main__:algorithm_chat:45 - [bot_model_now]算法模板模式
2024-07-17 23:49:48.014 | DEBUG    | __main__:algorithm_chat:48 - [message after noise removal]快速判断字符串是否为子串
2024-07-17 23:49:49.114 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：\n初始化哈希值数组 h 和幂数组 p。\n在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。\n使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。\n\n应用场景: \n字符串哈希常用于字符串比较、查重、子串搜索等问题，可以快速判断字符串是否为子串。\n\n时间复杂度:\n预处理时间为 O(n)，其中 n 是字符串长度。\n查询时间为 O(1)。\n这种方法因其高效性和简单性而广泛应用于字符串相关算法中。\n\n[回答]\n(字符串哈希)')]
2024-07-17 23:49:49.114 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](子串搜索)
2024-07-17 23:49:50.359 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]62
2024-07-17 23:49:50.359 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
2024-07-17 23:49:50.362 | DEBUG    | chatbot.chatbot:CodeAnalysis:59 - chatbot:
[code]```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
int n;cin >>n>>p+1;
int m;cin >>m>>s+1;
for(int i=2,j=0;i<=n;i++)
{
while(j&&p[i]!=p[j+1]) j=ne[j];
if(p[i]==p[j+1]) j++;
ne[i]=j;
}
for(int i=1,j=0;i<=m;i++)
{
while(j&&s[i]!=p[j+1]) j=ne[j];
if(s[i]==p[j+1]) j++;
//max_p=max(max_p,j);
if(j==n)
{
cout <<i-n<<" ";
j=ne[j];
}
}
}
```
[statue]1
[id]62
2024-07-17 23:50:10.384 | DEBUG    | chatbot.chatbot:CodeAnalysis:63 - [chatbot : Algorithm analysis results already exist]这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。

```cpp
#include <iostream>
using namespace std;

// 预定义常量，N 是数组大小，通常比输入字符串大一些
const int N = 1e6 + 7;

// 字符数组用于存储模式串和文本
char p[N], s[N]; 

// ne数组用于存储部分匹配表（Next数组）
int ne[N];

int main() {
    int n; // 模式串的长度
    cin >> n; // 读取模式串长度
    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性
    
    int m; // 文本字符串的长度
    cin >> m; // 读取文本字符串长度
    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储
    
    // 计算模式串的部分匹配表
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        ne[i] = j; // 存储当前位置的部分匹配表值
    }
    
    // 使用部分匹配表在文本字符串中搜索模式串
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        
        // 如果完全匹配，j 应该等于模式串长度 n
        if (j == n) {
            cout << i - n << " "; // 输出匹配位置（从1开始计数）
            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配
        }
    }
    cout << endl; // 输出换行符，结束输出
    return 0;
}
```

注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。
2024-07-17 23:50:10.384 | DEBUG    | __main__:algorithm_chat:54 - [result]这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。

```cpp
#include <iostream>
using namespace std;

// 预定义常量，N 是数组大小，通常比输入字符串大一些
const int N = 1e6 + 7;

// 字符数组用于存储模式串和文本
char p[N], s[N]; 

// ne数组用于存储部分匹配表（Next数组）
int ne[N];

int main() {
    int n; // 模式串的长度
    cin >> n; // 读取模式串长度
    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性
    
    int m; // 文本字符串的长度
    cin >> m; // 读取文本字符串长度
    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储
    
    // 计算模式串的部分匹配表
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        ne[i] = j; // 存储当前位置的部分匹配表值
    }
    
    // 使用部分匹配表在文本字符串中搜索模式串
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        
        // 如果完全匹配，j 应该等于模式串长度 n
        if (j == n) {
            cout << i - n << " "; // 输出匹配位置（从1开始计数）
            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配
        }
    }
    cout << endl; // 输出换行符，结束输出
    return 0;
}
```

注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。
[statue]1
[id]62
2024-07-17 23:50:10.398 | DEBUG    | __main__:algorithm_chat:57 - Insert successful
2024-07-17 23:51:31.132 | DEBUG    | __main__:get_slider_value:32 - [slider_value_now]算法交流模式
2024-07-17 23:51:41.562 | DEBUG    | __main__:get_slider_value:32 - [slider_value_now]算法模板模式
2024-07-17 23:51:42.541 | DEBUG    | __main__:get_slider_value:32 - [slider_value_now]0.1
2024-07-17 23:51:47.525 | DEBUG    | __main__:algorithm_chat:42 - [message]可以快速判断字符串是否为子串
2024-07-17 23:51:47.525 | DEBUG    | __main__:algorithm_chat:43 - [history][['可以快速判断字符串是否为子串', '这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 预定义常量，N 是数组大小，通常比输入字符串大一些\nconst int N = 1e6 + 7;\n\n// 字符数组用于存储模式串和文本\nchar p[N], s[N]; \n\n// ne数组用于存储部分匹配表（Next数组）\nint ne[N];\n\nint main() {\n    int n; // 模式串的长度\n    cin >> n; // 读取模式串长度\n    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性\n    \n    int m; // 文本字符串的长度\n    cin >> m; // 读取文本字符串长度\n    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储\n    \n    // 计算模式串的部分匹配表\n    for (int i = 2, j = 0; i <= n; i++) {\n        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置\n        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度\n        ne[i] = j; // 存储当前位置的部分匹配表值\n    }\n    \n    // 使用部分匹配表在文本字符串中搜索模式串\n    for (int i = 1, j = 0; i <= m; i++) {\n        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置\n        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度\n        \n        // 如果完全匹配，j 应该等于模式串长度 n\n        if (j == n) {\n            cout << i - n << " "; // 输出匹配位置（从1开始计数）\n            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配\n        }\n    }\n    cout << endl; // 输出换行符，结束输出\n    return 0;\n}\n```\n\n注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。']]
2024-07-17 23:51:47.525 | DEBUG    | __main__:algorithm_chat:44 - [slider_value_now]0.1
2024-07-17 23:51:47.525 | DEBUG    | __main__:algorithm_chat:45 - [bot_model_now]算法模板模式
2024-07-17 23:51:47.532 | DEBUG    | __main__:algorithm_chat:48 - [message after noise removal]快速判断字符串是否为子串
2024-07-17 23:51:48.505 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n字符串哈希是一种用于快速计算子串哈希值的算法。通过预先计算每个位置的哈希值和对应的幂值，能够在 O(1) 时间内获得任意子串的哈希值。具体步骤如下：\n初始化哈希值数组 h 和幂数组 p。\n在遍历字符串时，更新哈希值 h[i] 和幂值 p[i]。\n使用 get(l, r) 函数计算从位置 l 到 r 的子串哈希值。\n\n应用场景: \n字符串哈希常用于字符串比较、查重、子串搜索等问题，可以快速判断字符串是否为子串。\n\n时间复杂度:\n预处理时间为 O(n)，其中 n 是字符串长度。\n查询时间为 O(1)。\n这种方法因其高效性和简单性而广泛应用于字符串相关算法中。\n\n[回答]\n(字符串哈希)')]
2024-07-17 23:51:48.506 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](子串搜索)
2024-07-17 23:51:49.570 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]62
2024-07-17 23:51:49.570 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:73 - [algorithm_code : Algorithm analysis results already exist]这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。

```cpp
#include <iostream>
using namespace std;

// 预定义常量，N 是数组大小，通常比输入字符串大一些
const int N = 1e6 + 7;

// 字符数组用于存储模式串和文本
char p[N], s[N]; 

// ne数组用于存储部分匹配表（Next数组）
int ne[N];

int main() {
    int n; // 模式串的长度
    cin >> n; // 读取模式串长度
    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性
    
    int m; // 文本字符串的长度
    cin >> m; // 读取文本字符串长度
    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储
    
    // 计算模式串的部分匹配表
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        ne[i] = j; // 存储当前位置的部分匹配表值
    }
    
    // 使用部分匹配表在文本字符串中搜索模式串
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        
        // 如果完全匹配，j 应该等于模式串长度 n
        if (j == n) {
            cout << i - n << " "; // 输出匹配位置（从1开始计数）
            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配
        }
    }
    cout << endl; // 输出换行符，结束输出
    return 0;
}
```

注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。
2024-07-17 23:51:49.570 | DEBUG    | chatbot.chatbot:CodeAnalysis:59 - chatbot:
[code]这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。

```cpp
#include <iostream>
using namespace std;

// 预定义常量，N 是数组大小，通常比输入字符串大一些
const int N = 1e6 + 7;

// 字符数组用于存储模式串和文本
char p[N], s[N]; 

// ne数组用于存储部分匹配表（Next数组）
int ne[N];

int main() {
    int n; // 模式串的长度
    cin >> n; // 读取模式串长度
    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性
    
    int m; // 文本字符串的长度
    cin >> m; // 读取文本字符串长度
    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储
    
    // 计算模式串的部分匹配表
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        ne[i] = j; // 存储当前位置的部分匹配表值
    }
    
    // 使用部分匹配表在文本字符串中搜索模式串
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        
        // 如果完全匹配，j 应该等于模式串长度 n
        if (j == n) {
            cout << i - n << " "; // 输出匹配位置（从1开始计数）
            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配
        }
    }
    cout << endl; // 输出换行符，结束输出
    return 0;
}
```

注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。
[statue]2
[id]62
2024-07-17 23:51:49.575 | DEBUG    | chatbot.chatbot:CodeAnalysis:65 - [chatbot : The algorithm analysis result does not exist, analyze through code]这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。

```cpp
#include <iostream>
using namespace std;

// 预定义常量，N 是数组大小，通常比输入字符串大一些
const int N = 1e6 + 7;

// 字符数组用于存储模式串和文本
char p[N], s[N]; 

// ne数组用于存储部分匹配表（Next数组）
int ne[N];

int main() {
    int n; // 模式串的长度
    cin >> n; // 读取模式串长度
    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性
    
    int m; // 文本字符串的长度
    cin >> m; // 读取文本字符串长度
    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储
    
    // 计算模式串的部分匹配表
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        ne[i] = j; // 存储当前位置的部分匹配表值
    }
    
    // 使用部分匹配表在文本字符串中搜索模式串
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置
        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度
        
        // 如果完全匹配，j 应该等于模式串长度 n
        if (j == n) {
            cout << i - n << " "; // 输出匹配位置（从1开始计数）
            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配
        }
    }
    cout << endl; // 输出换行符，结束输出
    return 0;
}
```

注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。
2024-07-17 23:52:18.539 | DEBUG    | __main__:get_slider_value:32 - [slider_value_now]算法交流模式
2024-07-17 23:52:53.842 | DEBUG    | __main__:algorithm_chat:42 - [message]详细说一下ne数组的作用
2024-07-17 23:52:53.842 | DEBUG    | __main__:algorithm_chat:43 - [history][['可以快速判断字符串是否为子串', '这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 预定义常量，N 是数组大小，通常比输入字符串大一些\nconst int N = 1e6 + 7;\n\n// 字符数组用于存储模式串和文本\nchar p[N], s[N]; \n\n// ne数组用于存储部分匹配表（Next数组）\nint ne[N];\n\nint main() {\n    int n; // 模式串的长度\n    cin >> n; // 读取模式串长度\n    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性\n    \n    int m; // 文本字符串的长度\n    cin >> m; // 读取文本字符串长度\n    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储\n    \n    // 计算模式串的部分匹配表\n    for (int i = 2, j = 0; i <= n; i++) {\n        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置\n        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度\n        ne[i] = j; // 存储当前位置的部分匹配表值\n    }\n    \n    // 使用部分匹配表在文本字符串中搜索模式串\n    for (int i = 1, j = 0; i <= m; i++) {\n        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置\n        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度\n        \n        // 如果完全匹配，j 应该等于模式串长度 n\n        if (j == n) {\n            cout << i - n << " "; // 输出匹配位置（从1开始计数）\n            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配\n        }\n    }\n    cout << endl; // 输出换行符，结束输出\n    return 0;\n}\n```\n\n注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。'], ['可以快速判断字符串是否为子串', '这段代码看起来是一个用于字符串匹配的简单程序，它使用了部分匹配表（也称为Next数组或KMP算法中的失败函数）来加速模式匹配。下面我将重新排版代码并逐行添加注释。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 预定义常量，N 是数组大小，通常比输入字符串大一些\nconst int N = 1e6 + 7;\n\n// 字符数组用于存储模式串和文本\nchar p[N], s[N]; \n\n// ne数组用于存储部分匹配表（Next数组）\nint ne[N];\n\nint main() {\n    int n; // 模式串的长度\n    cin >> n; // 读取模式串长度\n    cin >> p + 1; // 读取模式串，从数组的第二个位置开始存储，以避免下标0的复杂性\n    \n    int m; // 文本字符串的长度\n    cin >> m; // 读取文本字符串长度\n    cin >> s + 1; // 读取文本字符串，同样从数组的第二个位置开始存储\n    \n    // 计算模式串的部分匹配表\n    for (int i = 2, j = 0; i <= n; i++) {\n        while (j && p[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置\n        if (p[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度\n        ne[i] = j; // 存储当前位置的部分匹配表值\n    }\n    \n    // 使用部分匹配表在文本字符串中搜索模式串\n    for (int i = 1, j = 0; i <= m; i++) {\n        while (j && s[i] != p[j + 1]) j = ne[j]; // 如果不匹配，回退到上一个匹配位置\n        if (s[i] == p[j + 1]) j++; // 如果匹配，增加匹配长度\n        \n        // 如果完全匹配，j 应该等于模式串长度 n\n        if (j == n) {\n            cout << i - n << " "; // 输出匹配位置（从1开始计数）\n            j = ne[j]; // 回退到上一个匹配位置，以寻找下一个可能的匹配\n        }\n    }\n    cout << endl; // 输出换行符，结束输出\n    return 0;\n}\n```\n\n注意：代码中有两处使用了`cout << i - n << " ";`，这假设模式串的长度`n`是已知的，并且匹配是从文本字符串的索引`i`开始的。因此，输出的是模式串在文本中起始位置的索引（从1开始计数）。此外，由于没有`#include <iostream>`，代码可能无法直接编译，我已添加了必要的头文件。最后，我添加了一个`cout << endl;`以确保在程序结束时输出一个换行符。']]
2024-07-17 23:52:53.842 | DEBUG    | __main__:algorithm_chat:44 - [slider_value_now]0.1
2024-07-17 23:52:53.842 | DEBUG    | __main__:algorithm_chat:45 - [bot_model_now]算法模板模式
2024-07-17 23:52:53.842 | DEBUG    | __main__:algorithm_chat:48 - [message after noise removal]详细说一下ne数组作用
2024-07-17 23:53:05.788 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n该算法使用动态规划的思想，通过构建一个二维数组 \nC 来存储组合数 C(n,k)。基本递推关系为 C(n,k)=C(n−1,k)+C(n−1,k−1)，边界条件为 C(n,0)=1。通过初始化边界和逐步填充数组，可以高效计算出所需的组合数。\n\n应用场景: \n在 combinatorial problems、概率论、统计学等领域中广泛应用，特别是在需要计算组合数的算法设计和优化中，如动态规划、分治法等。\n\n时间复杂度: \nO(N×K)，其中 N 为组合数的第一个参数，K 为第二个参数。这是因为我们需要填充一个大小为 N×K 的数组。\n\n[回答]\n(递归法求组合数)')]
2024-07-17 23:53:05.788 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]在提供的信息中，并没有直接解释“ne数组”的作用。但是，根据常见的计算机科学和编程语境，我们可以推测这里“ne数组”可能是指与AC自动机（Aho-Corasick算法）相关的一个数据结构，其中“ne”可能代表“next element”或“next state”。

在AC自动机中，每个状态都有一个“ne数组”，通常用于存储在匹配失败时自动机应该跳转到的下一个状态。这个“ne数组”或“失败函数”是AC自动机的一个关键组成部分，其作用如下：

1. **失败跳转**：当当前状态不能匹配文本字符串中的下一个字符时，自动机通过“ne数组”来跳转到另一个状态，从而尝试继续匹配。这个机制使得AC自动机能够在发生不匹配时快速回到一个可能继续成功匹配的状态。

2. **避免重新匹配**：由于“ne数组”的存在，AC自动机在匹配过程中不需要重新从起始状态开始匹配，而是可以直接跳过已经成功匹配的前缀，这样可以大大提高匹配效率。

3. **后缀模式匹配**：“ne数组”实际上记录了当前状态的最长可匹配后缀模式串，使得自动机可以在不完整匹配的情况下，利用之前匹配的信息。

综合上述信息，虽然“ne数组”在提供的信息中并没有直接描述，但根据上下文推测，它很可能是指AC自动机中的一个关键数据结构，用于优化字符串匹配的效率和性能。
2024-07-17 23:53:07.189 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]66
2024-07-17 23:53:07.189 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
2024-07-17 23:53:07.197 | DEBUG    | chatbot.chatbot:CodeAnalysis:59 - chatbot:
[code]```
void insert(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) son[p][u] = ++idx;
p = son[p][u];
}
cnt[p]++;
}

int query(char *str)
{
int p = 0;
for (int i = 0; str[i]; i++)
{
int u = str[i] - '0';
if (!son[p][u]) return 0;
p = son[p][u];
}
return cnt[p];
}
```
[statue]1
[id]66
2024-07-17 23:53:22.550 | DEBUG    | chatbot.chatbot:CodeAnalysis:63 - [chatbot : Algorithm analysis results already exist]这段代码似乎是使用Trie（字典树）的数据结构来进行字符串的插入和查询操作。下面我将重新排版并添加逐行注释，以使其更加清晰。

```c
// 声明Trie树节点结构体或者相关变量，这里假设有如下全局变量：
// int son[N][10]; // N是一个足够大的数，存储子节点指针，这里假设字符串只包含数字
// int cnt[N];     // 存储每个节点对应的字符串数量
// int idx;        // 用于为新的节点分配索引

// insert函数用于向Trie树中插入字符串
void insert(char *str) {
    int p = 0; // p用于跟踪当前节点
    // 遍历字符串直到遇到结束符'\0'
    for (int i = 0; str[i]; i++) {
        int u = str[i] - '0'; // 将字符转换为数字，假设str中的字符是'0'到'9'
        // 如果当前节点的子节点u不存在，则创建一个新的节点
        if (!son[p][u]) son[p][u] = ++idx;
        // 移动到下一个节点
        p = son[p][u];
    }
    // 增加当前节点的计数，表示该字符串出现次数增加1
    cnt[p]++;
}

// query函数用于查询Trie树中某个字符串的出现次数
int query(char *str) {
    int p = 0; // 同样用于跟踪当前节点
    // 遍历字符串直到遇到结束符'\0'
    for (int i = 0; str[i]; i++) {
        int u = str[i] - '0'; // 将字符转换为数字
        // 如果当前节点的子节点u不存在，说明字符串不在Trie树中
        if (!son[p][u]) return 0;
        // 移动到下一个节点
        p = son[p][u];
    }
    // 返回当前节点的计数，即字符串在Trie树中的出现次数
    return cnt[p];
}
```

请注意，这里假设了一些全局变量的声明和初始化，它们是Trie结构所必需的。代码中没有提供这部分信息，所以我根据常见的Trie实现做了假设。如果代码中有不同的变量名或结构，需要相应地调整这些注释。
2024-07-17 23:53:22.555 | DEBUG    | __main__:algorithm_chat:54 - [result]这段代码似乎是使用Trie（字典树）的数据结构来进行字符串的插入和查询操作。下面我将重新排版并添加逐行注释，以使其更加清晰。

```c
// 声明Trie树节点结构体或者相关变量，这里假设有如下全局变量：
// int son[N][10]; // N是一个足够大的数，存储子节点指针，这里假设字符串只包含数字
// int cnt[N];     // 存储每个节点对应的字符串数量
// int idx;        // 用于为新的节点分配索引

// insert函数用于向Trie树中插入字符串
void insert(char *str) {
    int p = 0; // p用于跟踪当前节点
    // 遍历字符串直到遇到结束符'\0'
    for (int i = 0; str[i]; i++) {
        int u = str[i] - '0'; // 将字符转换为数字，假设str中的字符是'0'到'9'
        // 如果当前节点的子节点u不存在，则创建一个新的节点
        if (!son[p][u]) son[p][u] = ++idx;
        // 移动到下一个节点
        p = son[p][u];
    }
    // 增加当前节点的计数，表示该字符串出现次数增加1
    cnt[p]++;
}

// query函数用于查询Trie树中某个字符串的出现次数
int query(char *str) {
    int p = 0; // 同样用于跟踪当前节点
    // 遍历字符串直到遇到结束符'\0'
    for (int i = 0; str[i]; i++) {
        int u = str[i] - '0'; // 将字符转换为数字
        // 如果当前节点的子节点u不存在，说明字符串不在Trie树中
        if (!son[p][u]) return 0;
        // 移动到下一个节点
        p = son[p][u];
    }
    // 返回当前节点的计数，即字符串在Trie树中的出现次数
    return cnt[p];
}
```

请注意，这里假设了一些全局变量的声明和初始化，它们是Trie结构所必需的。代码中没有提供这部分信息，所以我根据常见的Trie实现做了假设。如果代码中有不同的变量名或结构，需要相应地调整这些注释。
[statue]1
[id]66
2024-07-17 23:53:22.572 | DEBUG    | __main__:algorithm_chat:57 - Insert successful
2024-07-18 00:00:32.233 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-18 00:01:29.778 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]0.1
2024-07-18 00:01:30.392 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]算法模板模式
2024-07-18 00:02:50.611 | DEBUG    | __main__:algorithm_chat:44 - [message]二分图的最大匹配问题
2024-07-18 00:02:50.612 | DEBUG    | __main__:algorithm_chat:45 - [history][]
2024-07-18 00:02:50.612 | DEBUG    | __main__:algorithm_chat:46 - [slider_value_now]算法模板模式
2024-07-18 00:02:50.612 | DEBUG    | __main__:algorithm_chat:47 - [bot_model_now]算法模板模式
2024-07-18 00:02:51.297 | DEBUG    | __main__:algorithm_chat:50 - [message after noise removal]二分图最大匹配问题
2024-07-18 00:02:51.298 | ERROR    | chatbot.algorithm_describe:GetAlgorithmChaoName:83 - Retrieval failed: 1 validation error for VectorStoreRetriever
__root__
  `score_threshold` is not specified with a float value(0~1) in `search_kwargs`. (type=value_error)
2024-07-18 00:02:51.299 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]An error occurred during retrieval
2024-07-18 00:02:51.299 | ERROR    | chatbot.chatbot:CodeAnalysis:70 - chatbot : Retrieval failed: not enough values to unpack (expected 3, got 2)
2024-07-18 00:02:51.300 | ERROR    | __main__:algorithm_chat:69 - Error invoking retrieval chain: too many values to unpack (expected 3)
2024-07-18 00:03:50.541 | DEBUG    | __main__:algorithm_chat:44 - [message]二分图的最大匹配问题
2024-07-18 00:03:50.541 | DEBUG    | __main__:algorithm_chat:45 - [history][['二分图的最大匹配问题', 'An error occurred. Please try again.']]
2024-07-18 00:03:50.541 | DEBUG    | __main__:algorithm_chat:46 - [slider_value_now]算法模板模式
2024-07-18 00:03:50.541 | DEBUG    | __main__:algorithm_chat:47 - [bot_model_now]算法模板模式
2024-07-18 00:03:50.541 | DEBUG    | __main__:algorithm_chat:50 - [message after noise removal]二分图最大匹配问题
2024-07-18 00:03:50.541 | ERROR    | chatbot.algorithm_describe:GetAlgorithmChaoName:83 - Retrieval failed: 1 validation error for VectorStoreRetriever
__root__
  `score_threshold` is not specified with a float value(0~1) in `search_kwargs`. (type=value_error)
2024-07-18 00:03:50.541 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name]An error occurred during retrieval
2024-07-18 00:03:50.541 | ERROR    | chatbot.chatbot:CodeAnalysis:70 - chatbot : Retrieval failed: not enough values to unpack (expected 3, got 2)
2024-07-18 00:03:50.541 | ERROR    | __main__:algorithm_chat:69 - Error invoking retrieval chain: too many values to unpack (expected 3)
2024-07-18 00:07:02.104 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-18 00:07:40.949 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]0.1
2024-07-18 00:07:41.555 | DEBUG    | __main__:get_slider_value:33 - [slider_value_now]算法模板模式
2024-07-18 00:09:09.964 | DEBUG    | chatbot.algorithm_code:__init__:40 - [name_list_prompt]
你是国际信息学奥林匹克竞赛冠军,并且也是国际大学生程序设计大赛ICPC-WF冠军。
你将获得一段关于某个算法的大致描述。
请你在以下关键词中选取最相关的一个对应的序号整数作为输出:
__int128读写模板子:1
快速排序:2
归并排序:3
整数二分:4
浮点数二分:5
整数三分:6
浮点数三分:7
高精度加法:8
高精度减法:9
高精度乘低精度:10
高精度除以低精度:11
子矩阵的和:12
差分矩阵:13
双指针算法:14
数据离散化_保序离散化:15
数据离散化_非保序离散化:16
RMQ:17
试除法判定质数:18
试除法分解质因数:19
朴素素数筛法:20
线性素数筛法:21
区间素数筛法:22
Min_25:23
试除法求约数:24
欧几里得算法:25
欧拉函数:26
筛法求欧拉函数:27
卡特兰数求模:28
快速求第n位卡特兰数:29
Java大数打表卡特兰数:30
快速幂:31
位运算处理大数相乘:32
扩展欧几里得算法:33
高斯消元:34
递归法求组合数:35
预处理逆元的方式求组合数:36
Lucas定理:37
有向图的拓扑序:38
树的直径:39
堆优化版Dijkstra:40
朴素版spfa:41
SFA优化版的spfa:42
SPFA判负环正环:43
loyd算法 O(n^3):44
prim算法:45
kruskal算法:46
最小生成森林:47
倍增在线算法:48
targin离线算法:49
有向图的强连通分量:50
无向图的点双连通分量:51
二分图:52
匈牙利算法:53
单链表:54
双链表:55
单调栈:56
单调队列:57
朴素并查集:58
维护size的并查集:59
维护到祖宗节点距离的并查集:60
字符串哈希:61
KMP:62
线段树(单点修改):63
线段树(区间修改):64
树状数组:65
Trie树:66

2024-07-18 00:10:31.910 | DEBUG    | __main__:algorithm_chat:44 - [message]二分图的最大匹配问题
2024-07-18 00:10:31.910 | DEBUG    | __main__:algorithm_chat:45 - [history][]
2024-07-18 00:10:31.911 | DEBUG    | __main__:algorithm_chat:46 - [slider_value_now]0.1
2024-07-18 00:10:31.911 | DEBUG    | __main__:algorithm_chat:47 - [bot_model_now]算法模板模式
2024-07-18 00:10:32.659 | DEBUG    | __main__:algorithm_chat:50 - [message after noise removal]二分图最大匹配问题
2024-07-18 00:10:33.667 | DEBUG    | chatbot.algorithm_describe:GetAlgorithmChaoName:80 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm_describe.txt'}, page_content='[问题]\n过程: \n匈牙利算法用于解决二分图的最大匹配问题。其基本思想是通过深度优先搜索（DFS）寻找增广路径，从而增加匹配数。算法步骤如下：\n对于每个未匹配的节点，尝试找到一个增广路径。\n如果找到一条增广路径，则更新匹配关系。\n重复此过程，直到无法找到新的增广路径为止。\n\n应用场景: \n常用于解决工作分配、资源分配、任务调度等问题，其中涉及到的对象可以分为两类，并且要求每个对象只能与另一个对象匹配。\n\n时间复杂度: \n匈牙利算法的时间复杂度为 O(E⋅V)，其中 E 是边的数量，V 是节点的数量。对于稀疏图，通常认为其性能良好。\n该算法是处理二分图匹配问题的经典方法，适用于多种实际应用场景。\n\n[回答]\n(匈牙利算法)')]
2024-07-18 00:10:33.668 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:53 - [algorithm_chao_name](匈牙利算法)
2024-07-18 00:10:34.725 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:68 - [algorithm_id]53
2024-07-18 00:10:34.725 | DEBUG    | chatbot.algorithm_code:GetAlgorithmCode:78 - [algorithm_code : The algorithm analysis result does not exist, and the return code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
2024-07-18 00:10:34.725 | DEBUG    | chatbot.chatbot:CodeAnalysis:59 - chatbot:
[code]```
bool find(int x)
{
for (int i = h[x]; i != -1; i = ne[i])
{
int j = e[i];
if (!st[j])
{
st[j] = true;
if (match[j] == 0 || find(match[j]))
{
match[j] = x;
return true;
}
}
}

return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
memset(st, false, sizeof st);
if (find(i)) res ++ ;
}
```
[statue]1
[id]53
2024-07-18 00:10:49.896 | DEBUG    | chatbot.chatbot:CodeAnalysis:63 - [chatbot : Algorithm analysis results already exist]以下是重新排版并添加逐行注释的代码。这段代码看起来是一个图的匹配算法，可能是匈牙利算法的一部分，用于寻找最大匹配。

```cpp
// 定义函数find，用于寻找与节点x匹配的节点
bool find(int x) {
    // 从头节点h[x]开始，遍历所有与节点x相连的边
    for (int i = h[x]; i != -1; i = ne[i]) {
        int j = e[i]; // 获取与边i相连的另一个节点编号
        // 如果节点j没有被访问过
        if (!st[j]) {
            st[j] = true; // 标记节点j为已访问
            // 如果节点j没有被匹配，或者它的匹配节点可以找到一个新匹配
            if (match[j] == 0 || find(match[j])) {
                match[j] = x; // 将节点j与节点x匹配
                return true; // 返回找到匹配的结果
            }
        }
    }
    // 如果没有找到匹配，返回false
    return false;
}

// 初始化结果计数器
int res = 0;
// 遍历所有节点
for (int i = 1; i <= n1; i++) {
    // 每次遍历前重置访问数组
    memset(st, false, sizeof st);
    // 尝试为每个节点找到匹配
    if (find(i)) res++; // 如果找到匹配，结果计数器增加
}
```

以下是每个部分的详细注释：

- `h[x]`：可能是一个数组，表示节点x在邻接表中的头节点。
- `i != -1`：使用-1作为邻接表中的结束标记。
- `ne[i]`：可能是一个数组，表示与节点x相连的边i的下一个边。
- `e[i]`：可能是一个数组，存储边i的另一端的节点编号。
- `st[j]`：一个布尔数组，用于记录节点是否被访问过。
- `match[j]`：一个数组，用于存储每个节点的匹配节点。
- `n1`：可能是一个变量，表示图的一个部分中的节点数量。

这段代码中使用了几个未定义的变量和数组，它们在完整的代码中应该有相应的定义。
2024-07-18 00:10:49.898 | DEBUG    | __main__:algorithm_chat:56 - [result]以下是重新排版并添加逐行注释的代码。这段代码看起来是一个图的匹配算法，可能是匈牙利算法的一部分，用于寻找最大匹配。

```cpp
// 定义函数find，用于寻找与节点x匹配的节点
bool find(int x) {
    // 从头节点h[x]开始，遍历所有与节点x相连的边
    for (int i = h[x]; i != -1; i = ne[i]) {
        int j = e[i]; // 获取与边i相连的另一个节点编号
        // 如果节点j没有被访问过
        if (!st[j]) {
            st[j] = true; // 标记节点j为已访问
            // 如果节点j没有被匹配，或者它的匹配节点可以找到一个新匹配
            if (match[j] == 0 || find(match[j])) {
                match[j] = x; // 将节点j与节点x匹配
                return true; // 返回找到匹配的结果
            }
        }
    }
    // 如果没有找到匹配，返回false
    return false;
}

// 初始化结果计数器
int res = 0;
// 遍历所有节点
for (int i = 1; i <= n1; i++) {
    // 每次遍历前重置访问数组
    memset(st, false, sizeof st);
    // 尝试为每个节点找到匹配
    if (find(i)) res++; // 如果找到匹配，结果计数器增加
}
```

以下是每个部分的详细注释：

- `h[x]`：可能是一个数组，表示节点x在邻接表中的头节点。
- `i != -1`：使用-1作为邻接表中的结束标记。
- `ne[i]`：可能是一个数组，表示与节点x相连的边i的下一个边。
- `e[i]`：可能是一个数组，存储边i的另一端的节点编号。
- `st[j]`：一个布尔数组，用于记录节点是否被访问过。
- `match[j]`：一个数组，用于存储每个节点的匹配节点。
- `n1`：可能是一个变量，表示图的一个部分中的节点数量。

这段代码中使用了几个未定义的变量和数组，它们在完整的代码中应该有相应的定义。
[statue]1
[id]53
2024-07-18 00:10:49.911 | DEBUG    | __main__:algorithm_chat:59 - Insert successful
2024-07-18 00:12:09.159 | DEBUG    | __main__:get_bot_model:39 - [bot_model_now]算法交流模式
2024-07-18 00:12:51.413 | DEBUG    | __main__:algorithm_chat:44 - [message]详细的帮我分析match数组的作用
2024-07-18 00:12:51.414 | DEBUG    | __main__:algorithm_chat:45 - [history][['二分图的最大匹配问题', '以下是重新排版并添加逐行注释的代码。这段代码看起来是一个图的匹配算法，可能是匈牙利算法的一部分，用于寻找最大匹配。\n\n```cpp\n// 定义函数find，用于寻找与节点x匹配的节点\nbool find(int x) {\n    // 从头节点h[x]开始，遍历所有与节点x相连的边\n    for (int i = h[x]; i != -1; i = ne[i]) {\n        int j = e[i]; // 获取与边i相连的另一个节点编号\n        // 如果节点j没有被访问过\n        if (!st[j]) {\n            st[j] = true; // 标记节点j为已访问\n            // 如果节点j没有被匹配，或者它的匹配节点可以找到一个新匹配\n            if (match[j] == 0 || find(match[j])) {\n                match[j] = x; // 将节点j与节点x匹配\n                return true; // 返回找到匹配的结果\n            }\n        }\n    }\n    // 如果没有找到匹配，返回false\n    return false;\n}\n\n// 初始化结果计数器\nint res = 0;\n// 遍历所有节点\nfor (int i = 1; i <= n1; i++) {\n    // 每次遍历前重置访问数组\n    memset(st, false, sizeof st);\n    // 尝试为每个节点找到匹配\n    if (find(i)) res++; // 如果找到匹配，结果计数器增加\n}\n```\n\n以下是每个部分的详细注释：\n\n- `h[x]`：可能是一个数组，表示节点x在邻接表中的头节点。\n- `i != -1`：使用-1作为邻接表中的结束标记。\n- `ne[i]`：可能是一个数组，表示与节点x相连的边i的下一个边。\n- `e[i]`：可能是一个数组，存储边i的另一端的节点编号。\n- `st[j]`：一个布尔数组，用于记录节点是否被访问过。\n- `match[j]`：一个数组，用于存储每个节点的匹配节点。\n- `n1`：可能是一个变量，表示图的一个部分中的节点数量。\n\n这段代码中使用了几个未定义的变量和数组，它们在完整的代码中应该有相应的定义。']]
2024-07-18 00:12:51.414 | DEBUG    | __main__:algorithm_chat:46 - [slider_value_now]0.1
2024-07-18 00:12:51.414 | DEBUG    | __main__:algorithm_chat:47 - [bot_model_now]算法交流模式
2024-07-18 00:12:51.414 | DEBUG    | __main__:algorithm_chat:50 - [message after noise removal]详细帮分析match数组作用
