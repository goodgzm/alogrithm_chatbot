2024-07-15 11:10:53.199 | DEBUG    | __main__:algorithm_chat:18 - [message]整数二分
2024-07-15 11:10:53.200 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 11:11:09.939 | DEBUG    | __main__:algorithm_chat:26 - [input]整数二分
2024-07-15 11:11:09.940 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm_test.txt'}, page_content='[问题] 整数二分模板\n[回答]\n```\nbool check(int x) {/* ... */} \n \n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid; \n        else l = mid + 1;\n    }\n    return l;\n}\nint bsearch_2(int l, int r)\n{\n    while (l < r)\n    {\n        int mid = l + r + 1 >> 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n```')]
2024-07-15 11:11:09.941 | DEBUG    | __main__:algorithm_chat:28 - [answer]整数二分查找是一种在有序数组中查找某一特定元素的位置，或者满足特定条件的元素值的方法。在二分查找中，每次将搜索区间减半，这样可以显著减少搜索次数。

以下是提供的代码模板及其逐行注释：

```cpp
// 定义一个函数用于检查在特定的x点上的条件是否成立，这需要根据具体问题来定义
bool check(int x) {/* ... */} 

// 第一个二分查找模板，用于找到满足条件的最大值（即条件首次为真的位置）
int bsearch_1(int l, int r)
{
    while (l < r) // 当左边界小于右边界时继续循环
    {
        int mid = l + r >> 1; // 计算中点，等价于 (l + r) / 2，使用位运算提高效率
        if (check(mid)) r = mid; // 如果check函数在mid点为真，则搜索区间缩小到[l, mid]
        else l = mid + 1; // 否则搜索区间变为[mid + 1, r]
    }
    return l; // 循环结束后，l就是满足条件的最大值
}

// 第二个二分查找模板，用于找到满足条件的最小值（即条件最后为真的位置）
int bsearch_2(int l, int r)
{
    while (l < r) // 当左边界小于右边界时继续循环
    {
        int mid = l + r + 1 >> 1; // 计算中点，这里+1是为了防止死循环，确保在l=r-1时能够正确计算中点
        if (check(mid)) l = mid; // 如果check函数在mid点为真，则搜索区间缩小到[mid, r]
        else r = mid - 1; // 否则搜索区间变为[l, mid - 1]
    }
    return l; // 循环结束后，l就是满足条件的最小值
}
```

这个模板的关键在于：

1. `check` 函数：它用于检查在当前的二分点`mid`是否满足题目给定的条件。
2. `bsearch_1` 函数：当找到满足条件的点时，保留左半部分，寻找最大满足条件的点。
3. `bsearch_2` 函数：当找到满足条件的点时，保留右半部分，寻找最小满足条件的点。

注意：二分查找的前提是数组必须是有序的。此外，二分查找模板有多种变体，这里给出的是两种常见的形式。
2024-07-15 11:21:51.800 | DEBUG    | __main__:algorithm_chat:18 - [message]线性筛求素数
2024-07-15 11:21:51.801 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 11:22:09.154 | DEBUG    | __main__:algorithm_chat:26 - [input]线性筛求素数
2024-07-15 11:22:09.154 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm_test.txt'}, page_content='[问题] 线性筛法求素数\n[回答] \n```\nint primes[N], cnt;  \nbool st[N];    \nvoid get_primes(int n)\n{\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n```')]
2024-07-15 11:22:09.155 | DEBUG    | __main__:algorithm_chat:28 - [answer]线性筛法（也称为欧拉筛）是一种高效的算法，用于找出小于等于给定整数n的所有素数。它的效率之所以高，是因为它确保了每个合数只被它的最小质因数筛除一次，从而保证了算法的时间复杂度为O(n)。

下面是对提供的代码的逐行注释：

```c
int primes[N], cnt;  // primes数组用来存放找到的素数，N为定义的大小，通常取n的值；cnt用来记录找到的素数的数量
bool st[N];  // st数组用于标记数字是否为合数，如果st[i]为true，表示i是合数

void get_primes(int n)
{
    for (int i = 2; i <= n; i++)  // 从2开始遍历到n
    {
        if (!st[i]) primes[cnt++] = i;  // 如果i没有被标记为合数，那么它是素数，将其加入primes数组，并增加素数计数
        for (int j = 0; primes[j] <= n / i; j++)  // 对于每个找到的素数，只考虑它乘以i小于等于n的情况
        {
            st[primes[j] * i] = true;  // 将当前素数与i的乘积标记为合数
            if (i % primes[j] == 0) break;  // 如果i能够被当前素数整除，那么这个素数是i的最小质因数，停止内循环，避免重复标记
        }
    }
}
```

这段代码中，`st[primes[j] * i] = true;`这行表示将所有`i`的倍数标记为合数，但是通过`if (i % primes[j] == 0) break;`保证了每个合数只被它的最小质因数筛除一次。这样，每个合数只会在它第一次被筛除时被标记，从而实现了线性筛法的高效性。

这个算法的优越性在于它避免了每个合数被多次标记，确保了每个合数只被其最小质因数筛除，因此达到了O(n)的时间复杂度。
2024-07-15 11:55:31.388 | DEBUG    | __main__:algorithm_chat:18 - [message]整数二分
2024-07-15 11:55:31.389 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 11:55:42.508 | DEBUG    | __main__:algorithm_chat:26 - [input]整数二分
2024-07-15 11:55:42.508 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm_test.txt'}, page_content='[问题] 差分矩阵\n[回答]\n简单的区间差分插入操作：\n```\nvoid insert(int l,int r,int x)\n{\n    b[l]+=x,b[r+1]-=x;\n}\n```\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：\nS[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n\n\n-----\\d+-----\n[问题] 双指针算法\n[回答]\n```\nfor (int i = 0, j = 0; i < n; i ++ )\n{\n    while (j < i && check(i, j)) j ++ ;\n}\n```')]
2024-07-15 11:55:42.509 | DEBUG    | __main__:algorithm_chat:28 - [answer]整数二分算法是一种在有序数组中查找特定元素或者满足特定条件的元素位置的经典算法。该算法通过不断将数组分成两半来缩小查找范围，从而提高查找效率。下面是一个标准的整数二分查找算法的代码示例，我将会逐行进行注释。

```cpp
// 二分查找模板，在有序数组中查找target，如果找到则返回其索引，否则返回-1
int binary_search(int nums[], int n, int target) {
    int left = 0; // 查找范围的左边界
    int right = n - 1; // 查找范围的右边界，初始为数组长度减1

    while (left <= right) { // 当左边界不大于右边界时，继续查找
        int mid = left + (right - left) / 2; // 计算中点，防止直接相加导致整数溢出
        if (nums[mid] == target) { // 如果中点元素等于目标值，返回中点索引
            return mid;
        } else if (nums[mid] < target) { // 如果中点元素小于目标值，则在右半段继续查找
            left = mid + 1;
        } else { // 如果中点元素大于目标值，则在左半段继续查找
            right = mid - 1;
        }
    }

    return -1; // 查找失败，返回-1
}
```

这个模板适用于查找单一目标值，如果需要查找满足某个条件的最左侧或最右侧位置，则需要对模板进行适当的修改。
2024-07-15 11:57:03.484 | DEBUG    | __main__:algorithm_chat:18 - [message]高精度加法
2024-07-15 11:57:03.485 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 11:57:16.117 | DEBUG    | __main__:algorithm_chat:26 - [input]高精度加法
2024-07-15 11:57:16.117 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm_test.txt'}, page_content='[问题] 高精度加法\n[回答]\n```\nvector<int> add(vector<int> &A, vector<int> &B)\n{\n    if (A.size() < B.size()) return add(B, A);\n \n    vector<int> C;\n    int t = 0;\n    for (int i = 0; i < A.size(); i ++ )\n    {\n        t += A[i];\n        if (i < B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n \n    if (t) C.push_back(t);\n    return C;\n}\n```')]
2024-07-15 11:57:16.118 | DEBUG    | __main__:algorithm_chat:28 - [answer]这是一个用于实现两个大整数相加的C++函数，这两个大整数通过`vector<int>`类型存储，其中`vector`的每一个元素存储大整数的相应位数值（个位、十位等），从低位到高位排列。

下面是对这段代码的逐行注释：

```cpp
vector<int> add(vector<int> &A, vector<int> &B)
{
    // 如果A的长度小于B的长度，那么交换A和B，确保加法是从较长的数字开始
    if (A.size() < B.size()) return add(B, A);
 
    // 声明一个vector<int>类型的变量C用于存放结果
    vector<int> C;
    // t用于存储进位
    int t = 0;

    // 遍历A中的每个元素，确保覆盖A和B中较短数字的所有位数
    for (int i = 0; i < A.size(); i ++ )
    {
        // 将A的当前位的值加到t上
        t += A[i];
        // 如果B当前位存在，将B的当前位的值也加到t上
        if (i < B.size()) t += B[i];
        // 将t的个位数作为当前位的结果加入到结果集C中
        C.push_back(t % 10);
        // 计算进位，用于下一次迭代
        t /= 10;
    }
 
    // 如果最高位有进位，需要将进位添加到结果集C的末尾
    if (t) C.push_back(t);
    // 返回结果集C
    return C;
}
```

该函数返回一个`vector<int>`类型的变量，其中存储了A和B两个大整数相加的结果。由于每个元素只存储了0到9的数字，因此确保了高精度的整数计算。
2024-07-15 12:07:07.773 | DEBUG    | __main__:algorithm_chat:18 - [message]整数二分
2024-07-15 12:07:07.774 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 12:07:08.528 | ERROR    | __main__:algorithm_chat:23 - Error invoking retrieval chain: You have not yet added your payment method in the billing page and will have reduced rate limits of 3 RPM and 10K TPM.  Please add your payment method in the billing page (https://dash.voyageai.com/billing/payment-methods) to unlock our standard rate limits (https://docs.voyageai.com/docs/rate-limits).  Even with payment methods entered, the free tokens (50M tokens per model) will still apply.
2024-07-15 12:08:23.692 | DEBUG    | __main__:algorithm_chat:18 - [message]整数二分
2024-07-15 12:08:23.693 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 12:08:46.035 | DEBUG    | __main__:algorithm_chat:26 - [input]整数二分
2024-07-15 12:08:46.035 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm_test.txt'}, page_content='[问题] 整数三分模板。\n[回答]\n三分整数求极值的时候，往往不在 最后l  或者 r的地方取，而是遍历l~r之后取极值\n```\n//以凸函数位例子 \nint check(x){.....} \t//返回判断当前点对应的函数值 \nint bsearch_1(int l, int r)\n{\n    while (l < r-1)\n    {\n    \t//三分的两个中点有两种写法\n\t\t// m1 = l+(r-l)/3;\n\t\t// m2 = r-(r-l)/3;\n        m1 = l+r>>1;\n        m2 = m1+r>>1;\n        if(check(m1) > check(m2)) r=m2;\n        else l=m1;\n    }\n    return l;\n}\n```')]
2024-07-15 12:08:46.036 | DEBUG    | __main__:algorithm_chat:28 - [answer]在编程中，整数三分是一种用于寻找函数极值（最大值或最小值）的算法技巧，特别是当函数在一个区间内是凸的（或凹的）时。在三分搜索中，我们不是将搜索区间二分，而是将其分为三部分，并基于函数在这三个点的值来确定下一步的搜索区间。

下面是您提供的整数三分模板的代码，我将为您逐行添加注释：

```cpp
// 定义一个用于检查特定x点函数值的函数，返回值可能是函数在该点的输出
int check(int x) {
    // 函数的具体实现，用于评估点x处的函数值
    // .....
}

// 三分搜索算法实现
int bsearch_1(int l, int r) {
    while (l < r - 1) { // 当搜索区间超过一个元素时继续
        // 三分的中点计算方法，这里使用了位运算来简化计算
        // m1是区间左端点和中点的中点
        int m1 = l + (r - l) / 3; // 传统写法，下面是等效的位运算写法
        int m2 = (l + r) >> 1;    // m2是区间中点和右端点的中点
        
        // 根据check函数返回的m1和m2点的函数值来更新搜索区间
        // 如果m1处的函数值大于m2处的函数值，说明极值在m1的右侧
        if (check(m1) > check(m2)) {
            r = m2; // 缩小搜索区间到左边的三分之二部分
        } else {
            l = m1; // 缩小搜索区间到右边的三分之二部分
        }
    }
    // 循环结束后，l和r相差1，返回函数值较大的那个点，或者是两个点取平均也可以
    return l;
}
```

注意：这里代码的逻辑有点问题，它使用`m1`和`m2`来表示三分点，但是计算`m2`的方式实际上是二分的中点，而不是三分的中点。正确的三分点计算应该是这样的：

```cpp
int m1 = l + (r - l) / 3; // 区间左端点的三分之二处
int m2 = r - (r - l) / 3; // 区间右端点的三分之二处
```

或者使用位运算来简化：

```cpp
int m1 = (2 * l + r) / 3; // 位运算中，(2*l + r) >> 1 是三分的中点之一
int m2 = (l + 2 * r) / 3; // 位运算中，(l + 2*r) >> 1 是三分的中点之二
```

然后在循环中，我们比较`m1`和`m2`的函数值，并相应地调整搜索区间。这样，我们最终可以找到极值点。
2024-07-15 12:09:30.051 | DEBUG    | __main__:algorithm_chat:18 - [message]高精度加法
2024-07-15 12:09:30.051 | DEBUG    | __main__:algorithm_chat:19 - [history][['整数二分', '在编程中，整数三分是一种用于寻找函数极值（最大值或最小值）的算法技巧，特别是当函数在一个区间内是凸的（或凹的）时。在三分搜索中，我们不是将搜索区间二分，而是将其分为三部分，并基于函数在这三个点的值来确定下一步的搜索区间。\n\n下面是您提供的整数三分模板的代码，我将为您逐行添加注释：\n\n```cpp\n// 定义一个用于检查特定x点函数值的函数，返回值可能是函数在该点的输出\nint check(int x) {\n    // 函数的具体实现，用于评估点x处的函数值\n    // .....\n}\n\n// 三分搜索算法实现\nint bsearch_1(int l, int r) {\n    while (l < r - 1) { // 当搜索区间超过一个元素时继续\n        // 三分的中点计算方法，这里使用了位运算来简化计算\n        // m1是区间左端点和中点的中点\n        int m1 = l + (r - l) / 3; // 传统写法，下面是等效的位运算写法\n        int m2 = (l + r) >> 1;    // m2是区间中点和右端点的中点\n        \n        // 根据check函数返回的m1和m2点的函数值来更新搜索区间\n        // 如果m1处的函数值大于m2处的函数值，说明极值在m1的右侧\n        if (check(m1) > check(m2)) {\n            r = m2; // 缩小搜索区间到左边的三分之二部分\n        } else {\n            l = m1; // 缩小搜索区间到右边的三分之二部分\n        }\n    }\n    // 循环结束后，l和r相差1，返回函数值较大的那个点，或者是两个点取平均也可以\n    return l;\n}\n```\n\n注意：这里代码的逻辑有点问题，它使用`m1`和`m2`来表示三分点，但是计算`m2`的方式实际上是二分的中点，而不是三分的中点。正确的三分点计算应该是这样的：\n\n```cpp\nint m1 = l + (r - l) / 3; // 区间左端点的三分之二处\nint m2 = r - (r - l) / 3; // 区间右端点的三分之二处\n```\n\n或者使用位运算来简化：\n\n```cpp\nint m1 = (2 * l + r) / 3; // 位运算中，(2*l + r) >> 1 是三分的中点之一\nint m2 = (l + 2 * r) / 3; // 位运算中，(l + 2*r) >> 1 是三分的中点之二\n```\n\n然后在循环中，我们比较`m1`和`m2`的函数值，并相应地调整搜索区间。这样，我们最终可以找到极值点。']]
2024-07-15 12:09:44.022 | DEBUG    | __main__:algorithm_chat:26 - [input]高精度加法
2024-07-15 12:09:44.023 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm_test.txt'}, page_content='[问题] 高精度加法\n[回答]\n```\nvector<int> add(vector<int> &A, vector<int> &B)\n{\n    if (A.size() < B.size()) return add(B, A);\n \n    vector<int> C;\n    int t = 0;\n    for (int i = 0; i < A.size(); i ++ )\n    {\n        t += A[i];\n        if (i < B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n \n    if (t) C.push_back(t);\n    return C;\n}\n```')]
2024-07-15 12:09:44.023 | DEBUG    | __main__:algorithm_chat:28 - [answer]这是一种用于实现两个大整数相加的算法，通常用于解决超出标准数据类型（如`int`或`long long`）所能表示的范围的数值计算问题。以下是提供的代码及其逐行注释：

```cpp
// 定义一个函数add，它接受两个整数数组（以向量表示）A和B作为引用，返回一个整数数组（向量）C。
vector<int> add(vector<int> &A, vector<int> &B) {
    // 如果A的长度小于B的长度，交换A和B，保证A是最长的数字，这样可以减少后续循环的次数。
    if (A.size() < B.size()) return add(B, A);

    // 创建一个空向量C，用于存放最终的结果。
    vector<int> C;
    // 定义变量t用于进位。
    int t = 0;

    // 遍历数组A的每个元素。
    for (int i = 0; i < A.size(); i++) {
        // 将A的当前元素加到t上。
        t += A[i];
        // 如果B还有当前索引的元素，也加到t上。
        if (i < B.size()) t += B[i];
        // 将t的个位数放到结果向量C中。
        C.push_back(t % 10);
        // 更新t为进位，即t除以10的商。
        t /= 10;
    }

    // 循环结束后，如果t还有值（即还有进位），将进位加到C的末尾。
    if (t) C.push_back(t);
    // 返回计算结果C。
    return C;
}
```

这个函数实现了两个大整数的逐位相加，并将结果存储在一个新的整数向量中，向量中的每个元素表示一个数字（从个位到最高位）。
2024-07-15 12:49:08.976 | DEBUG    | __main__:algorithm_chat:18 - [message]有向图的拓扑序
2024-07-15 12:49:08.976 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 12:49:27.939 | DEBUG    | __main__:algorithm_chat:26 - [input]有向图的拓扑序
2024-07-15 12:49:27.939 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}, page_content='[问题]有向图的拓扑序\n[回答] \n```\nbool topsort()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(inv[i]==0) q.push(i);\n    }\n    while(!q.empty())\n    {\n        int res=q.front();\n        q.pop();\n        p.push(res);\n        for(int i=h[res];i!=-1;i=ne[i])\n        {\n            int j=e[i];\n            inv[j]--;\n            if(inv[j]==0) q.push(j);\n        }\n    }\n    if(p.size()==n) return true; \n    else return false;\n}\n```')]
2024-07-15 12:49:27.940 | DEBUG    | __main__:algorithm_chat:28 - [answer]在有向图中，拓扑序指的是一种对所有顶点进行排序的方式，使得对于图中的每一条边 (u, v)，顶点 u 都会在顶点 v 之前被访问。这样的排序通常用于任务调度等场景，其中某些任务必须在其他任务完成后才能开始。

下面是对您提供的代码的逐行注释，该代码用于在有向无环图（DAG）中实现拓扑排序。

```cpp
bool topsort()
{
    // 初始化一个队列 q，将所有入度为 0 的顶点入队
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }

    // 当队列非空时，处理队列中的顶点
    while(!q.empty())
    {
        int res=q.front(); // 获取队列的第一个顶点
        q.pop(); // 将该顶点出队
        p.push(res); // 将该顶点加入到结果序列中

        // 遍历该顶点的所有出边
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i]; // 获取到当前顶点指向的顶点
            inv[j]--; // 减少该顶点的入度（因为其前驱已经处理）
            if(inv[j]==0) q.push(j); // 如果新的入度为 0，则将该顶点入队
        }
    }

    // 如果结果序列中顶点的数量等于图中顶点的数量，说明拓扑排序成功
    if(p.size()==n) return true; 
    else return false; // 否则，返回失败（可能是图中存在环）
}
```

其中：
- `n` 是图中顶点的数量。
- `inv[i]` 是顶点 `i` 的入度。
- `h[res]` 是顶点 `res` 的第一条出边在数组中的位置。
- `ne[i]` 是边 `i` 的下一条边。
- `e[i]` 是边 `i` 的终点。
- `q` 是一个辅助队列，用于存储所有入度为 0 的顶点。
- `p` 是一个存储拓扑排序结果的容器。

这个代码假设了所有的图都是可以通过拓扑排序进行排序的（即没有环）。如果图中有环，那么算法将无法成功完成拓扑排序，因为队列最终将不会包含所有的顶点。
2024-07-15 12:50:36.757 | DEBUG    | chatbot.chatbot:__init__:44 - [len of docs_list]47
2024-07-15 12:51:01.145 | DEBUG    | __main__:algorithm_chat:18 - [message]拓扑排序
2024-07-15 12:51:01.146 | DEBUG    | __main__:algorithm_chat:19 - [history][]
2024-07-15 12:51:23.150 | DEBUG    | __main__:algorithm_chat:26 - [input]拓扑排序
2024-07-15 12:51:23.150 | DEBUG    | __main__:algorithm_chat:27 - [context][Document(metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}, page_content='[问题]有向图的拓扑序\n[回答] \n```\nbool topsort()\n{\n    for(int i=1;i<=n;i++)\n    {\n        if(inv[i]==0) q.push(i);\n    }\n    while(!q.empty())\n    {\n        int res=q.front();\n        q.pop();\n        p.push(res);\n        for(int i=h[res];i!=-1;i=ne[i])\n        {\n            int j=e[i];\n            inv[j]--;\n            if(inv[j]==0) q.push(j);\n        }\n    }\n    if(p.size()==n) return true; \n    else return false;\n}\n```')]
2024-07-15 12:51:23.151 | DEBUG    | __main__:algorithm_chat:28 - [answer]拓扑排序是一种针对有向无环图（DAG）的排序算法，下面是对您提供的代码的逐行注释：

```cpp
bool topsort() {
    // 初始化一个队列q，用于存储所有入度为0的节点
    for(int i=1;i<=n;i++) {
        if(inv[i]==0) q.push(i);
    }
    // 当队列不为空时，执行以下操作
    while(!q.empty()) {
        // 取出队列中的第一个节点（即入度为0的节点）
        int res=q.front();
        q.pop();
        // 将此节点存入结果栈p中，这里可以用vector等代替栈
        p.push(res);
        // 遍历该节点的所有出边
        for(int i=h[res];i!=-1;i=ne[i]) {
            int j=e[i]; // e[i]存储了节点res指向的节点编号
            inv[j]--; // 将节点j的入度减1
            // 如果节点j的入度变为0，说明它所有的前驱节点已经处理完毕，将其加入队列
            if(inv[j]==0) q.push(j);
        }
    }
    // 如果结果栈的大小等于节点总数，说明所有的节点都被处理过，即存在一个有效的拓扑排序
    if(p.size()==n) return true; 
    // 否则，说明图中存在环，不能进行拓扑排序
    else return false;
}
```

代码中的一些变量和概念解释：
- `n`: 图中的节点总数。
- `inv[i]`: 表示节点i的入度（即有多少条边指向节点i）。
- `q`: 一个队列，用于存储所有当前入度为0的节点。
- `p`: 一个栈，用于存储拓扑排序的结果。
- `h[res]`: 表示节点res在邻接表中的起始位置。
- `ne[i]`: 邻接表中，与节点i相连的下一个节点。
- `e[i]`: 邻接表中，节点i指向的目标节点。

此代码的主要逻辑是：
1. 初始化队列q，将所有入度为0的节点加入队列。
2. 循环处理队列中的节点，每次取出一个节点，将其加入结果栈，并减少它的所有邻接节点的入度。
3. 如果某个邻接节点的入度变为0，则将其加入队列。
4. 如果最后结果栈的大小等于节点总数，说明存在有效的拓扑排序，否则图中有环，无法完成拓扑排序。
2024-07-15 12:53:27.790 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]506
2024-07-15 12:53:27.793 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]479
2024-07-15 12:53:27.796 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]457
2024-07-15 12:53:27.798 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]469
2024-07-15 12:53:27.798 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]507
2024-07-15 12:53:27.800 | DEBUG    | chatbot.chatbot:__init__:49 - [len of docs_list]47
2024-07-15 12:53:56.786 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]506
2024-07-15 12:53:56.789 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]479
2024-07-15 12:53:56.792 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]457
2024-07-15 12:53:56.794 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]469
2024-07-15 12:53:56.795 | ERROR    | chatbot.chatbot:__init__:47 - [tokens of doc]507
2024-07-15 12:53:56.796 | DEBUG    | chatbot.chatbot:__init__:49 - [len of docs_list]56
2024-07-15 12:54:55.930 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='-----\d+-----
[问题]__int128读写模板子
[回答]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.149 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 快速排序
[回答]
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.151 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 归并排序
[回答]
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.152 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数二分模板
[回答]
```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.153 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数二分模板
[回答] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.155 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数三分模板。
[回答]
三分整数求极值的时候，往往不在 最后l  或者 r的地方取，而是遍历l~r之后取极值
```
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.156 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数三分模板
[回答]
```
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.157 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度加法
[回答]
```
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
 
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
 
    if (t) C.push_back(t);
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.158 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度减法
[回答]
```
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
 
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.159 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度乘低精度
[回答]
```
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
 
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.160 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度除以低精度
[回答]
```
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```


-----\d+-----
[问题] 位运算模板
[回答]
求n的二进制的第k位数字: n >> k & 1
返回n的二进制最后一位1所代表的十进制数：lowbit(n) = n & -n
###
当枚举状态时假设有n个点，每个点有两种状态，那么一共就有2^n个状态，所以可以用位运算来枚举每种方案里面的状态；1~2^n-1里面的所有的数都可以作为一种方案，比如n=5，那么枚举1~31，假设枚举到12，它的二进制为
01100 ，利用位运算判断12的哪一位是1，就证明对第几个点进行了相应的操作；' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.161 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 子矩阵的和
[回答]
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]


-----\d+-----
[问题] 差分矩阵
[回答]
简单的区间差分插入操作：
```
void insert(int l,int r,int x)
{
    b[l]+=x,b[r+1]-=x;
}
```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c


-----\d+-----
[问题] 双指针算法
[回答]
```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.162 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 数据离散化/保序离散化
[回答]
```
vector<int> alls; 
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end()); 
 
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
```

-----\d+-----
[问题] 数据离散化/非保序离散化
[回答]
```
unordered_map<int,int> mp;
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.164 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] RMQ（ST表查询区间最值）
[回答] 
const int N=2e5+7,M=20;
```
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```

-----\d+-----
[问题] 试除法判定质数
[回答] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.166 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法分解质因数
[回答] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

-----\d+-----
[问题] 朴素筛法求素数（质数）
[回答] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.167 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 线性筛法求素数
[回答] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.168 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 区间素数筛
[回答] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.169 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] Min_25求1~n质数和 
[回答] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.171 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]506
2024-07-15 12:54:56.171 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法求约数（求一个数的所有因子）
[回答] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```


-----\d+-----
[问题] 欧几里得算法
[回答] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.172 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 欧拉函数
[回答] 
1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
```
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.173 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 筛法求欧拉函数
[回答] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.174 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]卡特兰数求模模板 
[回答] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.176 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速求第n位卡特兰数模板（mod1e9+7版）
[回答] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.177 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Java大数打表卡特兰数模板 
[回答] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.179 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速幂
[回答] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```


-----\d+-----
[问题]位运算处理大数相乘(1e18) 
[回答] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.181 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]扩展欧几里得算法
[回答] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.182 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]高斯消元
[回答] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.184 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]递归法求组合数（数据规模小）
[回答] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.185 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]通过预处理逆元的方式求组合数（数据规模上万）
[回答] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.186 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Lucas定理（数据规模上亿）
[回答] 
 ```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.188 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的拓扑序
[回答] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.189 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]树的直径 
[回答] 
树的直径求法有很多：
两次BFS或者两次DFS；树形DP 
树形DP的基本思路：
```
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.191 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版Dijkstra  O(n^2)
[回答] 
时间复杂是 O(n^2+m), n 表示点数，m 表示边数
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[问题]最短路算法模板:堆优化版Dijkstra  O(mlogn)
[回答] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.193 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版spfa：
[回答] 
``
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.195 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SFA优化版的spfa
[回答] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.196 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SPFA判负环正环
[回答] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.197 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]多源最短路算法模板: loyd算法 O(n^3)
[回答] 
 ```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.199 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: prim算法
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.200 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: ruskal算法
[回答] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.202 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: 最小生成森林
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.203 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: 倍增在线算法
[回答] 
``
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.205 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: targin离线算法
[回答] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.207 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的强连通分量
[回答] 
 ```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.209 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 无向图的点双连通分量
[回答] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.212 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 二分图  时间复杂度是 O(n+m)
[回答] 
 ```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.214 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 匈牙利算法
[回答] 
 ```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.215 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  单链表
[回答] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```


-----\d+-----
[问题]   双链表
[回答] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.217 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    单调栈, 找出每个数左边离它最近的比它大/小的数
[回答]
```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```


-----\d+-----
[问题]    单调队列
[回答]
```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.218 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最大子段和（限制区间长度） 
[回答]
```
    for (int i = 1; i <= n; i ++ ) scanf("%d", &s[i]), s[i] += s[i - 1];
 
    int res = -INF;
    int hh = 0, tt = 0;
 
    for (int i = 1; i <= n; i ++ )//核心代码
    {
        if (q[hh] < i - m) hh ++ ;
        res = max(res, s[i] - s[q[hh]]);
        while (hh <= tt && s[q[tt]] >= s[i]) tt -- ;
        q[ ++ tt] = i;
    }
```


-----\d+-----
[问题]   朴素并查集：
[回答]
```
    int p[N]; 
 
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;
 
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.219 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护size的并查集：
[回答]
```
    int p[N], size[N];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
 
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.221 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护到祖宗节点距离的并查集：
[回答]
```
    int p[N], d[N];
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
 
    p[find(a)] = find(b);
    d[find(a)] = distance; 
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.222 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    字符串哈希
[回答]
```
typedef unsigned long long ULL;
ULL h[N], p[N]; 
 
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}
 
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.223 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    KMP——字符串匹配
[回答]
```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
	int n;cin >>n>>p+1; 
	int m;cin >>m>>s+1;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1]) j++;
		ne[i]=j;
	} 
	for(int i=1,j=0;i<=m;i++)
	{
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1]) j++;
		//max_p=max(max_p,j);
		if(j==n)
		{
			cout <<i-n<<" ";
			j=ne[j];
		} 
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.224 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（单点修改）
[回答]
int n,m;
 
struct node
{
	int l,r;  
	int sum;   
	int lmax; 
	int rmax; 
	int tmax;  
}tr[N*4];
 
void pushup(node &u,node &l,node &r)
{
	u.sum=l.sum+r.sum;
	u.lmax=max(l.lmax,l.sum+r.lmax); 
	u.rmax=max(r.rmax,r.sum+l.rmax);
	u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
 
void pushup(int u)
{
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
 
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
	else
	{	tr[u]={l,r};
		int mid=l+r>>1;	
		build(u<<1,l,mid);	
		build(u<<1|1,mid+1,r);
		pushup(u);
	}
}
 
void modify(int u,int x,int v)
{
	if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v}; 
	else 
	{
		int mid=tr[u].l+tr[u].r>>1;	
		if(x<=mid) modify(u<<1,x,v);
		else modify(u<<1|1,x,v);	
		pushup(u);	
	}
}
 
node query(int u,int l,int r) 
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u]; 
	else
	{	
		int mid=tr[u].l+tr[u].r>>1;  
		if(r<=mid) return query(u<<1,l,r);
		else if(l>mid) return query(u<<1|1,l,r); 
		else 
		{
			auto left=query(u<<1,l,r);   
			auto right=query(u<<1|1,l,r);	
			node res;
			pushup(res,left,right);  
			return res;
		}	
	}
}' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.227 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（区间修改）
[回答]
```
struct node
{
	ll l,r;  
	ll sum;
	ll add;	
	ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
    root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
    root.mul=root.mul*mul%p;
    root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
	tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
    eval(tr[u<<1],tr[u].add,tr[u].mul);
    eval(tr[u<<1|1],tr[u].add,tr[u].mul);
    tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],0,1};
	else
	{	tr[u]={l,r,0,0,1};	
		int mid=l+r>>1;	
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);	
		pushup(u);	
	}
}
 
void modify(int u,int l,int r,int add,int mul)
{
	if(tr[u].l>=l&&tr[u].r<=r)
	{
		eval(tr[u],add,mul);
	}
	else 
	{
		pushdown(u);
		int mid=tr[u].l+tr[u].r>>1;	
		if(l<=mid) modify(u<<1,l,r,add,mul); 
		if(r>mid) modify(u<<1|1,l,r,add,mul);	
		pushup(u);
	}
}
 
node query(int u,int l,int r)   
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	else
	{	
	    pushdown(u);
		node res;
		res.sum=0;
		int mid=tr[u].l+tr[u].r>>1; 
		if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
		if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
		pushup(u);
		return res;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.230 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]507
2024-07-15 12:54:56.230 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    树状数组
[回答]
```
int lowbit(int x)
{
	return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
	return res; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.231 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   Trie树（字典树）
[回答]
```
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
 
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.233 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长上升子序列模型
[回答]

```
O(N^2)
for(int i=1;i<=n;i++)
{
    f[i]=1
    for(int j=1;j<=i;j++)
    {
        if(a[j]<a[i]) f[i]=max(f[i],f[j]+1);
        ans=max(ans,f[i]);
    }
}
O(NlogN)
int len=0;
for(int i=1;i<n;i++)
{
    int pos=lower_bound(f, f+len, a[i]) - f;
    len=max(len,pos+1);
    f[pos]=a[i];
}
cout <<len<<endl;
 ```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.234 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长公共序列模型 
[回答]
```
int main()
{
    int n,m;
    cin >>n>>m;
    for(int i=1;i<=n;i++) cin >>a[i];
    for(int i=1;i<=m;i++) cin >>b[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
        }
    }
    cout <<f[n][m]<<endl;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.235 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  最长公共上升序列模型
[回答]
 ```
int ans=0;
for(int i=1;i<=n;i++)
{
    int temp=1;
    for(int j=1;j<=n;j++)
    {
        f[i][j]=max(f[i-1][j],f[i][j]);
        if(a[i]==b[j]) f[i][j]=max(temp,f[i][j]);
        if(a[i]>b[j]) temp=max(temp,f[i-1][j]+1);
    }
}
for(int i=1;i<=n;i++) ans=max(ans,f[n][i]);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.236 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  编辑距离模型
[回答]
 ```
cin >>n>>a+1;
cin >>m>>b+1;
for(int i=1;i<=n;i++) f[i][0]=i;
for(int i=1;i<=m;i++) f[0][i]=i;
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=m;j++)
    {
        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);//添加或者删除
        if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]);
        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//修改
    }
}
cout <<f[n][m]<<endl;
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:54:56.238 | DEBUG    | chatbot.chatbot:__init__:50 - [len of docs_list]59
2024-07-15 12:55:12.765 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='-----\d+-----
[问题]__int128读写模板子
[回答]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.982 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 快速排序
[回答]
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.984 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 归并排序
[回答]
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.985 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数二分模板
[回答]
```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.987 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数二分模板
[回答] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.987 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数三分模板。
[回答]
三分整数求极值的时候，往往不在 最后l  或者 r的地方取，而是遍历l~r之后取极值
```
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.988 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数三分模板
[回答]
```
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.989 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度加法
[回答]
```
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
 
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
 
    if (t) C.push_back(t);
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.990 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度减法
[回答]
```
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
 
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.991 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度乘低精度
[回答]
```
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
 
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.992 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度除以低精度
[回答]
```
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```


-----\d+-----
[问题] 位运算模板
[回答]
求n的二进制的第k位数字: n >> k & 1
返回n的二进制最后一位1所代表的十进制数：lowbit(n) = n & -n
###
当枚举状态时假设有n个点，每个点有两种状态，那么一共就有2^n个状态，所以可以用位运算来枚举每种方案里面的状态；1~2^n-1里面的所有的数都可以作为一种方案，比如n=5，那么枚举1~31，假设枚举到12，它的二进制为
01100 ，利用位运算判断12的哪一位是1，就证明对第几个点进行了相应的操作；' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.993 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 子矩阵的和
[回答]
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]


-----\d+-----
[问题] 差分矩阵
[回答]
简单的区间差分插入操作：
```
void insert(int l,int r,int x)
{
    b[l]+=x,b[r+1]-=x;
}
```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c


-----\d+-----
[问题] 双指针算法
[回答]
```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.995 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 数据离散化/保序离散化
[回答]
```
vector<int> alls; 
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end()); 
 
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
```

-----\d+-----
[问题] 数据离散化/非保序离散化
[回答]
```
unordered_map<int,int> mp;
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:12.997 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] RMQ（ST表查询区间最值）
[回答] 
const int N=2e5+7,M=20;
```
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```

-----\d+-----
[问题] 试除法判定质数
[回答] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.000 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法分解质因数
[回答] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

-----\d+-----
[问题] 朴素筛法求素数（质数）
[回答] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.001 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 线性筛法求素数
[回答] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.002 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 区间素数筛
[回答] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.004 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] Min_25求1~n质数和 
[回答] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.007 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]506
2024-07-15 12:55:13.007 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法求约数（求一个数的所有因子）
[回答] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```


-----\d+-----
[问题] 欧几里得算法
[回答] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.009 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 欧拉函数
[回答] 
1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
```
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.009 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 筛法求欧拉函数
[回答] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.012 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]卡特兰数求模模板 
[回答] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.013 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速求第n位卡特兰数模板（mod1e9+7版）
[回答] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.014 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Java大数打表卡特兰数模板 
[回答] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.015 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速幂
[回答] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```


-----\d+-----
[问题]位运算处理大数相乘(1e18) 
[回答] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.017 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]扩展欧几里得算法
[回答] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.018 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]高斯消元
[回答] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.020 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]递归法求组合数（数据规模小）
[回答] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.021 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]通过预处理逆元的方式求组合数（数据规模上万）
[回答] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.021 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Lucas定理（数据规模上亿）
[回答] 
 ```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.023 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的拓扑序
[回答] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.025 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]树的直径 
[回答] 
树的直径求法有很多：
两次BFS或者两次DFS；树形DP 
树形DP的基本思路：
```
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.026 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版Dijkstra  O(n^2)
[回答] 
时间复杂是 O(n^2+m), n 表示点数，m 表示边数
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[问题]最短路算法模板:堆优化版Dijkstra  O(mlogn)
[回答] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.030 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]479
2024-07-15 12:55:13.030 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版spfa：
[回答] 
``
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.032 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SFA优化版的spfa
[回答] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.034 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SPFA判负环正环
[回答] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.036 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]多源最短路算法模板: loyd算法 O(n^3)
[回答] 
 ```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.037 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: prim算法
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.039 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: ruskal算法
[回答] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.041 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: 最小生成森林
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.043 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: 倍增在线算法
[回答] 
``
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.045 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: targin离线算法
[回答] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.048 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的强连通分量
[回答] 
 ```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.051 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 无向图的点双连通分量
[回答] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.054 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 二分图  时间复杂度是 O(n+m)
[回答] 
 ```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.056 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 匈牙利算法
[回答] 
 ```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.058 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  单链表
[回答] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```


-----\d+-----
[问题]   双链表
[回答] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.061 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    单调栈, 找出每个数左边离它最近的比它大/小的数
[回答]
```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```


-----\d+-----
[问题]    单调队列
[回答]
```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.062 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最大子段和（限制区间长度） 
[回答]
```
    for (int i = 1; i <= n; i ++ ) scanf("%d", &s[i]), s[i] += s[i - 1];
 
    int res = -INF;
    int hh = 0, tt = 0;
 
    for (int i = 1; i <= n; i ++ )//核心代码
    {
        if (q[hh] < i - m) hh ++ ;
        res = max(res, s[i] - s[q[hh]]);
        while (hh <= tt && s[q[tt]] >= s[i]) tt -- ;
        q[ ++ tt] = i;
    }
```


-----\d+-----
[问题]   朴素并查集：
[回答]
```
    int p[N]; 
 
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;
 
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.064 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护size的并查集：
[回答]
```
    int p[N], size[N];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
 
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.066 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护到祖宗节点距离的并查集：
[回答]
```
    int p[N], d[N];
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
 
    p[find(a)] = find(b);
    d[find(a)] = distance; 
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.067 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    字符串哈希
[回答]
```
typedef unsigned long long ULL;
ULL h[N], p[N]; 
 
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}
 
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.069 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    KMP——字符串匹配
[回答]
```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
	int n;cin >>n>>p+1; 
	int m;cin >>m>>s+1;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1]) j++;
		ne[i]=j;
	} 
	for(int i=1,j=0;i<=m;i++)
	{
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1]) j++;
		//max_p=max(max_p,j);
		if(j==n)
		{
			cout <<i-n<<" ";
			j=ne[j];
		} 
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.071 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（单点修改）
[回答]
int n,m;
 
struct node
{
	int l,r;  
	int sum;   
	int lmax; 
	int rmax; 
	int tmax;  
}tr[N*4];
 
void pushup(node &u,node &l,node &r)
{
	u.sum=l.sum+r.sum;
	u.lmax=max(l.lmax,l.sum+r.lmax); 
	u.rmax=max(r.rmax,r.sum+l.rmax);
	u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
 
void pushup(int u)
{
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
 
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
	else
	{	tr[u]={l,r};
		int mid=l+r>>1;	
		build(u<<1,l,mid);	
		build(u<<1|1,mid+1,r);
		pushup(u);
	}
}
 
void modify(int u,int x,int v)
{
	if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v}; 
	else 
	{
		int mid=tr[u].l+tr[u].r>>1;	
		if(x<=mid) modify(u<<1,x,v);
		else modify(u<<1|1,x,v);	
		pushup(u);	
	}
}
 
node query(int u,int l,int r) 
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u]; 
	else
	{	
		int mid=tr[u].l+tr[u].r>>1;  
		if(r<=mid) return query(u<<1,l,r);
		else if(l>mid) return query(u<<1|1,l,r); 
		else 
		{
			auto left=query(u<<1,l,r);   
			auto right=query(u<<1|1,l,r);	
			node res;
			pushup(res,left,right);  
			return res;
		}	
	}
}' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.075 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（区间修改）
[回答]
```
struct node
{
	ll l,r;  
	ll sum;
	ll add;	
	ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
    root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
    root.mul=root.mul*mul%p;
    root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
	tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
    eval(tr[u<<1],tr[u].add,tr[u].mul);
    eval(tr[u<<1|1],tr[u].add,tr[u].mul);
    tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],0,1};
	else
	{	tr[u]={l,r,0,0,1};	
		int mid=l+r>>1;	
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);	
		pushup(u);	
	}
}
 
void modify(int u,int l,int r,int add,int mul)
{
	if(tr[u].l>=l&&tr[u].r<=r)
	{
		eval(tr[u],add,mul);
	}
	else 
	{
		pushdown(u);
		int mid=tr[u].l+tr[u].r>>1;	
		if(l<=mid) modify(u<<1,l,r,add,mul); 
		if(r>mid) modify(u<<1|1,l,r,add,mul);	
		pushup(u);
	}
}
 
node query(int u,int l,int r)   
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	else
	{	
	    pushdown(u);
		node res;
		res.sum=0;
		int mid=tr[u].l+tr[u].r>>1; 
		if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
		if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
		pushup(u);
		return res;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.079 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]507
2024-07-15 12:55:13.080 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    树状数组
[回答]
```
int lowbit(int x)
{
	return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
	return res; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.081 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   Trie树（字典树）
[回答]
```
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
 
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.083 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长上升子序列模型
[回答]

```
O(N^2)
for(int i=1;i<=n;i++)
{
    f[i]=1
    for(int j=1;j<=i;j++)
    {
        if(a[j]<a[i]) f[i]=max(f[i],f[j]+1);
        ans=max(ans,f[i]);
    }
}
O(NlogN)
int len=0;
for(int i=1;i<n;i++)
{
    int pos=lower_bound(f, f+len, a[i]) - f;
    len=max(len,pos+1);
    f[pos]=a[i];
}
cout <<len<<endl;
 ```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.084 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长公共序列模型 
[回答]
```
int main()
{
    int n,m;
    cin >>n>>m;
    for(int i=1;i<=n;i++) cin >>a[i];
    for(int i=1;i<=m;i++) cin >>b[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
        }
    }
    cout <<f[n][m]<<endl;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.085 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  最长公共上升序列模型
[回答]
 ```
int ans=0;
for(int i=1;i<=n;i++)
{
    int temp=1;
    for(int j=1;j<=n;j++)
    {
        f[i][j]=max(f[i-1][j],f[i][j]);
        if(a[i]==b[j]) f[i][j]=max(temp,f[i][j]);
        if(a[i]>b[j]) temp=max(temp,f[i-1][j]+1);
    }
}
for(int i=1;i<=n;i++) ans=max(ans,f[n][i]);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.087 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  编辑距离模型
[回答]
 ```
cin >>n>>a+1;
cin >>m>>b+1;
for(int i=1;i<=n;i++) f[i][0]=i;
for(int i=1;i<=m;i++) f[0][i]=i;
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=m;j++)
    {
        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);//添加或者删除
        if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]);
        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//修改
    }
}
cout <<f[n][m]<<endl;
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:55:13.088 | DEBUG    | chatbot.chatbot:__init__:50 - [len of docs_list]58
2024-07-15 12:56:04.659 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='-----\d+-----
[问题]__int128读写模板子
[回答]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.875 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 快速排序
[回答]
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.876 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 归并排序
[回答]
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.877 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数二分模板
[回答]
```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.878 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数二分模板
[回答] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.879 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数三分模板。
[回答]
三分整数求极值的时候，往往不在 最后l  或者 r的地方取，而是遍历l~r之后取极值
```
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.880 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数三分模板
[回答]
```
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.881 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度加法
[回答]
```
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
 
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
 
    if (t) C.push_back(t);
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.882 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度减法
[回答]
```
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
 
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.884 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度乘低精度
[回答]
```
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
 
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.885 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度除以低精度
[回答]
```
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```


-----\d+-----
[问题] 位运算模板
[回答]
求n的二进制的第k位数字: n >> k & 1
返回n的二进制最后一位1所代表的十进制数：lowbit(n) = n & -n
###
当枚举状态时假设有n个点，每个点有两种状态，那么一共就有2^n个状态，所以可以用位运算来枚举每种方案里面的状态；1~2^n-1里面的所有的数都可以作为一种方案，比如n=5，那么枚举1~31，假设枚举到12，它的二进制为
01100 ，利用位运算判断12的哪一位是1，就证明对第几个点进行了相应的操作；' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.886 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 子矩阵的和
[回答]
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]


-----\d+-----
[问题] 差分矩阵
[回答]
简单的区间差分插入操作：
```
void insert(int l,int r,int x)
{
    b[l]+=x,b[r+1]-=x;
}
```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c


-----\d+-----
[问题] 双指针算法
[回答]
```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.888 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 数据离散化/保序离散化
[回答]
```
vector<int> alls; 
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end()); 
 
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
```

-----\d+-----
[问题] 数据离散化/非保序离散化
[回答]
```
unordered_map<int,int> mp;
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.889 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] RMQ（ST表查询区间最值）
[回答] 
const int N=2e5+7,M=20;
```
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```

-----\d+-----
[问题] 试除法判定质数
[回答] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.890 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法分解质因数
[回答] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

-----\d+-----
[问题] 朴素筛法求素数（质数）
[回答] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.892 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 线性筛法求素数
[回答] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.893 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 区间素数筛
[回答] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.894 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] Min_25求1~n质数和 
[回答] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.896 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]506
2024-07-15 12:56:04.896 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法求约数（求一个数的所有因子）
[回答] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```


-----\d+-----
[问题] 欧几里得算法
[回答] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.898 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 欧拉函数
[回答] 
1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
```
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.899 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 筛法求欧拉函数
[回答] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.900 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]卡特兰数求模模板 
[回答] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.901 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速求第n位卡特兰数模板（mod1e9+7版）
[回答] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.903 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Java大数打表卡特兰数模板 
[回答] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.904 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速幂
[回答] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```


-----\d+-----
[问题]位运算处理大数相乘(1e18) 
[回答] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.906 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]扩展欧几里得算法
[回答] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.907 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]高斯消元
[回答] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.909 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]递归法求组合数（数据规模小）
[回答] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.910 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]通过预处理逆元的方式求组合数（数据规模上万）
[回答] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.911 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Lucas定理（数据规模上亿）
[回答] 
 ```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.913 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的拓扑序
[回答] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.915 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]树的直径 
[回答] 
树的直径求法有很多：
两次BFS或者两次DFS；树形DP 
树形DP的基本思路：
```
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.916 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版Dijkstra  O(n^2)
[回答] 
时间复杂是 O(n^2+m), n 表示点数，m 表示边数
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[问题]最短路算法模板:堆优化版Dijkstra  O(mlogn)
[回答] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.920 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]479
2024-07-15 12:56:04.921 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版spfa：
[回答] 
``
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.923 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SFA优化版的spfa
[回答] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.924 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SPFA判负环正环
[回答] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.926 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]多源最短路算法模板: loyd算法 O(n^3)
[回答] 
 ```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.929 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: prim算法
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.930 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: ruskal算法
[回答] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.932 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: 最小生成森林
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.934 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: 倍增在线算法
[回答] 
``
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.936 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: targin离线算法
[回答] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.938 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的强连通分量
[回答] 
 ```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.941 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 无向图的点双连通分量
[回答] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.944 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]457
2024-07-15 12:56:04.945 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 二分图  时间复杂度是 O(n+m)
[回答] 
 ```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.946 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 匈牙利算法
[回答] 
 ```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.948 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  单链表
[回答] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```


-----\d+-----
[问题]   双链表
[回答] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.950 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    单调栈, 找出每个数左边离它最近的比它大/小的数
[回答]
```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```


-----\d+-----
[问题]    单调队列
[回答]
```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.951 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最大子段和（限制区间长度） 
[回答]
```
    for (int i = 1; i <= n; i ++ ) scanf("%d", &s[i]), s[i] += s[i - 1];
 
    int res = -INF;
    int hh = 0, tt = 0;
 
    for (int i = 1; i <= n; i ++ )//核心代码
    {
        if (q[hh] < i - m) hh ++ ;
        res = max(res, s[i] - s[q[hh]]);
        while (hh <= tt && s[q[tt]] >= s[i]) tt -- ;
        q[ ++ tt] = i;
    }
```


-----\d+-----
[问题]   朴素并查集：
[回答]
```
    int p[N]; 
 
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;
 
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.953 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护size的并查集：
[回答]
```
    int p[N], size[N];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
 
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.955 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护到祖宗节点距离的并查集：
[回答]
```
    int p[N], d[N];
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
 
    p[find(a)] = find(b);
    d[find(a)] = distance; 
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.956 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    字符串哈希
[回答]
```
typedef unsigned long long ULL;
ULL h[N], p[N]; 
 
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}
 
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.957 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    KMP——字符串匹配
[回答]
```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
	int n;cin >>n>>p+1; 
	int m;cin >>m>>s+1;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1]) j++;
		ne[i]=j;
	} 
	for(int i=1,j=0;i<=m;i++)
	{
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1]) j++;
		//max_p=max(max_p,j);
		if(j==n)
		{
			cout <<i-n<<" ";
			j=ne[j];
		} 
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.958 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（单点修改）
[回答]
int n,m;
 
struct node
{
	int l,r;  
	int sum;   
	int lmax; 
	int rmax; 
	int tmax;  
}tr[N*4];
 
void pushup(node &u,node &l,node &r)
{
	u.sum=l.sum+r.sum;
	u.lmax=max(l.lmax,l.sum+r.lmax); 
	u.rmax=max(r.rmax,r.sum+l.rmax);
	u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
 
void pushup(int u)
{
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
 
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
	else
	{	tr[u]={l,r};
		int mid=l+r>>1;	
		build(u<<1,l,mid);	
		build(u<<1|1,mid+1,r);
		pushup(u);
	}
}
 
void modify(int u,int x,int v)
{
	if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v}; 
	else 
	{
		int mid=tr[u].l+tr[u].r>>1;	
		if(x<=mid) modify(u<<1,x,v);
		else modify(u<<1|1,x,v);	
		pushup(u);	
	}
}
 
node query(int u,int l,int r) 
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u]; 
	else
	{	
		int mid=tr[u].l+tr[u].r>>1;  
		if(r<=mid) return query(u<<1,l,r);
		else if(l>mid) return query(u<<1|1,l,r); 
		else 
		{
			auto left=query(u<<1,l,r);   
			auto right=query(u<<1|1,l,r);	
			node res;
			pushup(res,left,right);  
			return res;
		}	
	}
}' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.963 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]469
2024-07-15 12:56:04.963 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（区间修改）
[回答]
```
struct node
{
	ll l,r;  
	ll sum;
	ll add;	
	ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
    root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
    root.mul=root.mul*mul%p;
    root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
	tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
    eval(tr[u<<1],tr[u].add,tr[u].mul);
    eval(tr[u<<1|1],tr[u].add,tr[u].mul);
    tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],0,1};
	else
	{	tr[u]={l,r,0,0,1};	
		int mid=l+r>>1;	
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);	
		pushup(u);	
	}
}
 
void modify(int u,int l,int r,int add,int mul)
{
	if(tr[u].l>=l&&tr[u].r<=r)
	{
		eval(tr[u],add,mul);
	}
	else 
	{
		pushdown(u);
		int mid=tr[u].l+tr[u].r>>1;	
		if(l<=mid) modify(u<<1,l,r,add,mul); 
		if(r>mid) modify(u<<1|1,l,r,add,mul);	
		pushup(u);
	}
}
 
node query(int u,int l,int r)   
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	else
	{	
	    pushdown(u);
		node res;
		res.sum=0;
		int mid=tr[u].l+tr[u].r>>1; 
		if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
		if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
		pushup(u);
		return res;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.965 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]507
2024-07-15 12:56:04.965 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    树状数组
[回答]
```
int lowbit(int x)
{
	return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
	return res; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.967 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   Trie树（字典树）
[回答]
```
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
 
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.968 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长上升子序列模型
[回答]

```
O(N^2)
for(int i=1;i<=n;i++)
{
    f[i]=1
    for(int j=1;j<=i;j++)
    {
        if(a[j]<a[i]) f[i]=max(f[i],f[j]+1);
        ans=max(ans,f[i]);
    }
}
O(NlogN)
int len=0;
for(int i=1;i<n;i++)
{
    int pos=lower_bound(f, f+len, a[i]) - f;
    len=max(len,pos+1);
    f[pos]=a[i];
}
cout <<len<<endl;
 ```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.969 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长公共序列模型 
[回答]
```
int main()
{
    int n,m;
    cin >>n>>m;
    for(int i=1;i<=n;i++) cin >>a[i];
    for(int i=1;i<=m;i++) cin >>b[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
        }
    }
    cout <<f[n][m]<<endl;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.970 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  最长公共上升序列模型
[回答]
 ```
int ans=0;
for(int i=1;i<=n;i++)
{
    int temp=1;
    for(int j=1;j<=n;j++)
    {
        f[i][j]=max(f[i-1][j],f[i][j]);
        if(a[i]==b[j]) f[i][j]=max(temp,f[i][j]);
        if(a[i]>b[j]) temp=max(temp,f[i-1][j]+1);
    }
}
for(int i=1;i<=n;i++) ans=max(ans,f[n][i]);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.971 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  编辑距离模型
[回答]
 ```
cin >>n>>a+1;
cin >>m>>b+1;
for(int i=1;i<=n;i++) f[i][0]=i;
for(int i=1;i<=m;i++) f[0][i]=i;
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=m;j++)
    {
        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);//添加或者删除
        if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]);
        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//修改
    }
}
cout <<f[n][m]<<endl;
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 12:56:04.972 | DEBUG    | chatbot.chatbot:__init__:50 - [len of docs_list]56
2024-07-15 13:33:00.030 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='-----\d+-----
[问题]__int128读写模板子
[回答]
```
inline __int128 read(){
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
```
``` 
inline void print(__int128 x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.274 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 快速排序
[回答]
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.276 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 归并排序
[回答]
```
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
 
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] < q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
 
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
 
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.277 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数二分模板
[回答]
```
bool check(int x) {/* ... */} 
 
// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; 
        else l = mid + 1;
    }
    return l;
}
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.278 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数二分模板
[回答] 
```
const double eps=1e-6;
bool check(double x) {/* ... */} 
 
double bsearch_3(double l,double r)
{
	while (r-l>eps)
	{
		double mid = (l + r) / 2;
		if (check(mid))  r = mid;
		else l = mid;
	}
	return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.279 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 整数三分模板。
[回答]
三分整数求极值的时候，往往不在 最后l  或者 r的地方取，而是遍历l~r之后取极值
```
//以凸函数位例子 
int check(x){.....} 	//返回判断当前点对应的函数值 
int bsearch_1(int l, int r)
{
    while (l < r-1)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = l+r>>1;
        m2 = m1+r>>1;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.280 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 浮点数三分模板
[回答]
```
//以凸函数位例子 
double check(x){.....} 	//返回判断当前点对应的函数值 
double bsearch_1(double l, double r)
{
    while (r-l>eps)
    {
    	//三分的两个中点有两种写法
		// m1 = l+(r-l)/3;
		// m2 = r-(r-l)/3;
        m1 = (l+r)/2;
        m2 = (m1+r)/2;
        if(check(m1) > check(m2)) r=m2;
        else l=m1;
    }
    return l;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.282 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度加法
[回答]
```
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);
 
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
 
    if (t) C.push_back(t);
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.283 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度减法
[回答]
```
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
 
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.284 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度乘低精度
[回答]
```
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
 
    return C;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.285 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 高精度除以低精度
[回答]
```
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```


-----\d+-----
[问题] 位运算模板
[回答]
求n的二进制的第k位数字: n >> k & 1
返回n的二进制最后一位1所代表的十进制数：lowbit(n) = n & -n
###
当枚举状态时假设有n个点，每个点有两种状态，那么一共就有2^n个状态，所以可以用位运算来枚举每种方案里面的状态；1~2^n-1里面的所有的数都可以作为一种方案，比如n=5，那么枚举1~31，假设枚举到12，它的二进制为
01100 ，利用位运算判断12的哪一位是1，就证明对第几个点进行了相应的操作；' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.287 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 子矩阵的和
[回答]
S[i, j] = 第i行j列格子左上部分所有元素的和（也就是矩阵前缀和）
矩阵前缀和的求法：S[i, j] = S[i-1, j] + s[i, j-1] -s[i-1, j-1]
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]


-----\d+-----
[问题] 差分矩阵
[回答]
简单的区间差分插入操作：
```
void insert(int l,int r,int x)
{
    b[l]+=x,b[r+1]-=x;
}
```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c


-----\d+-----
[问题] 双指针算法
[回答]
```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.288 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 数据离散化/保序离散化
[回答]
```
vector<int> alls; 
sort(alls.begin(), alls.end()); 
alls.erase(unique(alls.begin(), alls.end()), alls.end()); 
 
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
```

-----\d+-----
[问题] 数据离散化/非保序离散化
[回答]
```
unordered_map<int,int> mp;
int res;
int find(int x)
{
	if(mp.count(x)==0) return mp[x]=++res;
	return mp[x];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.289 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] RMQ（ST表查询区间最值）
[回答] 
const int N=2e5+7,M=20;
```
int dp[N][M];
int a[N];
for(int j=0;j<M;j++)
{
    for(int i=1;i+(1<<j)-1<=n;i++)
    {
        if(!j) dp[i][j]=a[i];
        else dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
    }
}
int res=log(b-a+1)/log(2);
cout <<max(dp[a][res],dp[b-(1<<res)+1][res])<<endl;
```

-----\d+-----
[问题] 试除法判定质数
[回答] 
```
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.291 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法分解质因数
[回答] 
```
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

-----\d+-----
[问题] 朴素筛法求素数（质数）
[回答] 
```
int primes[N], cnt; 
bool st[N];  
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.293 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 线性筛法求素数
[回答] 
```
int primes[N], cnt;  
bool st[N];    
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.294 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 区间素数筛
[回答] 
```
#define MAX_L 1000007
#define MAX_SORT_B 1000007
 
bool is_prime[MAX_L];
bool is_prime_small[MAX_SORT_B];
 
void segment_sieve(LL a,LL b)
{
    for(int i=0; (LL)i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; (LL)i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i; (LL)j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            for(LL j=max(2LL, (a+i-1)/i)*i ; j<b; j+=i) 
            {
                is_prime[j - a] =false;
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.296 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] Min_25求1~n质数和 
[回答] 
```
const int N=1000010;
 
namespace Min25 {
    int prime[N], id1[N], id2[N], flag[N], ncnt, m;
    ll g[N], sum[N], a[N], T, n;
    inline int ID(ll x) {
        return x <= T ? id1[x] : id2[n / x];
    }
    inline ll calc(ll x) {
        return x * (x + 1) / 2 - 1;
    }
    inline ll f(ll x) {
        return x;
    }
    inline void init() {
    	//for(int i=0;i<=N;i++) prime[i]=id1[i]=id2[i]=flag[i]=g[i]=sum[i]=a[i]=0,ncnt=0,m=0;
    	ncnt=m=0;
        T = sqrt(n + 0.5);
        for (int i = 2; i <= T; i++) {
            if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = sum[ncnt - 1] + i;
            for (int j = 1; j <= ncnt && i * prime[j] <= T; j++) {
                flag[i * prime[j]] = 1;
                if (i % prime[j] == 0) break;
            }
        }
        for (ll l = 1; l <= n; l = n / (n / l) + 1) {
            a[++m] = n / l;
            if (a[m] <= T) id1[a[m]] = m; else id2[n / a[m]] = m;
            g[m] = calc(a[m]);
        }
        for (int i = 1; i <= ncnt; i++) 
            for (int j = 1; j <= m && (ll)prime[i] * prime[i] <= a[j]; j++) 
                g[j] = g[j] - (ll)prime[i] * (g[ID(a[j] / prime[i])] - sum[i - 1]);
    }
 
    inline ll solve(ll x) {
        if (x <= 1) return x;
        return n = x, init(), g[ID(n)];
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.298 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]506
2024-07-15 13:33:00.298 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 试除法求约数（求一个数的所有因子）
[回答] 
```
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```


-----\d+-----
[问题] 欧几里得算法
[回答] 
```
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.300 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 欧拉函数
[回答] 
1 ~ N 中与 N 互质的数的个数被称为欧拉函数，记为ϕ(N)；
```
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.302 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 筛法求欧拉函数
[回答] 
```
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.303 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]卡特兰数求模模板 
[回答] 
```
const int C_maxn = 1e4 + 10;
LL CatalanNum[C_maxn];
LL inv[C_maxn];
inline void Catalan_Mod(int N, LL mod)
{
    inv[1] = 1;
    for(int i=2; i<=N+1; i++)
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
 
    CatalanNum[0] = CatalanNum[1] = 1;
 
    for(int i=2; i<=N; i++)
        CatalanNum[i] = CatalanNum[i-1] * (4 * i - 2) %mod * inv[i+1] %mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.305 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速求第n位卡特兰数模板（mod1e9+7版）
[回答] 
```
const long long M=1000000007;
long long inv[1000010];
long long last,now=1;
 
void init()
{
    inv[1]=1;
    for(int i=2;i<=n+1;i++)inv[i]=(M-M/i)*inv[M%i]%M;
}
 
int main()
{
    scanf("%lld",&n);
    init();
    for(int i=2;i<=n;i++)
    {
        last=now;
        now=last*(4*i-2)%M*inv[i+1]%M;
    }
    printf("%lld\n",last);
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.307 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Java大数打表卡特兰数模板 
[回答] 
```
import java.io.*;  
import java.math.BigInteger;  
import java.util.*; 
 
public class Main {
	
    public static void main(String[] args) {
    	Scanner cin=new Scanner(System.in);
    	BigInteger s[]=new BigInteger[105];
    	s[1]=BigInteger.ONE;
    	for(int i=2;i<105;i++){
    		s[i]=s[i-1].multiply(BigInteger.valueOf((4*i-2))).divide(BigInteger.valueOf(i+1));
    	}
    	while(cin.hasNext()){
    		int n=cin.nextInt();
    		System.out.println(s[n]);
    	}
     }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.309 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]快速幂
[回答] 
```
long long pow(long long m, long long k, long long p){
        long long res = 1 % p, t = m;
        while (k>0)
        {
            if ((k&1)>0) res = res * t % p;
            t = t * t % p;
            k >>= 1;
        }
        return res%p;
}
```


-----\d+-----
[问题]位运算处理大数相乘(1e18) 
[回答] 
```
ll quick_add(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.311 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]扩展欧几里得算法
[回答] 
```
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.312 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]高斯消元
[回答] 
```
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ ) 
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]); 
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c]; 
        for (int i = r + 1; i < n; i ++ ) 
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
 
        r ++ ;
    }
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; 
        return 1;
    }
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.314 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]递归法求组合数（数据规模小）
[回答] 
```
void init(int x,int y)
{
	C[0][0]=C[1][0] = C[1][1] = 1;
	for (int i = 2; i <=x; i++)
	{
		C[i][0] = 1;
		for (int j = 1; j <=y; j++)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1])%mod;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.315 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]通过预处理逆元的方式求组合数（数据规模上万）
[回答] 
```
int qmi(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.317 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]Lucas定理（数据规模上亿）
[回答] 
 ```
int qmi(int a, int k)       // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
 
int C(int a, int b)     // 通过定理求组合数C(a, b)
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j -- )
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
 
 
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.319 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的拓扑序
[回答] 
```
bool topsort()
{
    for(int i=1;i<=n;i++)
    {
        if(inv[i]==0) q.push(i);
    }
    while(!q.empty())
    {
        int res=q.front();
        q.pop();
        p.push(res);
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            inv[j]--;
            if(inv[j]==0) q.push(j);
        }
    }
    if(p.size()==n) return true; 
    else return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.322 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]树的直径 
[回答] 
树的直径求法有很多：
两次BFS或者两次DFS；树形DP 
树形DP的基本思路：
```
int h[N],e[N<<1],ne[N<<1],w[N<<1],idx;
int d[2][N],dmax;
void add(int a,int b,int c)
{
	e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;
}
void dfs(int u,int fa)
{
	for(int i=h[u];~i;i=ne[i])
	{		int j=e[i];
		if(j==fa) continue;
		dfs(j,u);
		if(d[0][u]<d[0][j]+w[i]) d[1][u]=d[0][u],d[0][u]=d[0][j]+w[i];
		else if(d[1][u]<d[0][j]+w[i]) d[1][u]=d[0][j]+w[i];
		dmax=max(dmax,d[0][u]+d[1][u]);
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.323 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版Dijkstra  O(n^2)
[回答] 
时间复杂是 O(n^2+m), n 表示点数，m 表示边数
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
 
    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
 
        st[t] = true;
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```


-----43---
[问题]最短路算法模板:堆优化版Dijkstra  O(mlogn)
[回答] 
```
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});   
 
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();
 
        int ver = t.second, distance = t.first;
 
        if (st[ver]) continue;
        st[ver] = true;
 
        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
 
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.327 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]479
2024-07-15 13:33:00.328 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板:朴素版spfa：
[回答] 
``
void spfa()
{
    int hh = 0, tt = 0;
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    q[tt++] = 1, st[1] = 1;
    while (hh != tt)
    {
        int t = q[hh++];
        st[t] = 0;
        if (hh == n) hh = 0;
        for (int i = h[t]; i != -1; i = ne[i])
            if (dist[e[i]] > dist[t] + v[i])
            {
                dist[e[i]] = dist[t] + v[i];
                if (!st[e[i]])
                {
                    st[e[i]] = 1;
                    q[tt++] = e[i];
                    if (tt == n) tt = 0;
                }
            }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.330 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SFA优化版的spfa
[回答] 
```
void spfa(int root,int dist[])
{
    memset(dist,0x3f,sizeof dis);
    dist[root] = 0;
    memset(st, false, sizeof st);
    deque<int> q;
    q.push_back(root);
    st[root]=true;
    while (q.size())
    {
        int res=q.front();
        q.pop_front();
        st[res]=false;
        for(int i=h[res];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dist[j]>dist[res]+w[i])
            {
                dist[j]=dist[res]+w[i];
                if(!st[j])
                {
                    st[j]=true;
                    if(dist[j]>dist[q.front()]) q.push_back(j);
                    else q.push_front(j);
                }
            }
        }
    }
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.332 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最短路算法模板: SPFA判负环正环
[回答] 
```
bool spfa()
{
    memset(dis,0,sizeof dis);
    memset(st,false,sizeof st);
    memset(cnt,0,sizeof cnt);
    queue<int> q;
    for(int i=0;i<=n;i++) q.push(i),st[i]=true;
    int count=0;
    while(q.size())
    {
        int t=q.front();
        st[t]=false;
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i])
        {
            int j=e[i];
            if(dis[j]>dis[t]+w[i])
            {
                dis[j]=dis[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>=n) return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.335 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]多源最短路算法模板: loyd算法 O(n^3)
[回答] 
 ```
int main()
{
    cin >> m >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = i == j ? 0 : INF;
    for (int i = 0; i < m; i++)
    {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = d[b][a] = min(c, d[a][b]);
    }
    // floyd 算法核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    cout << d[1][n] << endl;
    return 0;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.337 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: prim算法
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
 
        if (i && dist[t] == INF) return INF;
 
        if (i) res += dist[t];
        st[t] = true;
 
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.338 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: ruskal算法
[回答] 
```
struct Edge 
{
    int a, b, w;
 
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
 
int find(int x)    
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
 
int kruskal()
{
    sort(edges, edges + m);
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;  
 
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
 
        a = find(a), b = find(b);
        if (a != b)     
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
 
    if (cnt < n - 1) return INF;
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.341 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最小生成树算法模板: 最小生成森林
[回答] 
```
int prim()
{
    memset(dist, 0x3f, sizeof dist);
 
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        st[t] = true;
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
        if(i&&dist[t]==0x3f3f3f3f) continue;
        if (i) res += dist[t];
    }
 
    return res;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.343 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: 倍增在线算法
[回答] 
``
void bfs(int root)
{
    memset(depth,0x3f,sizeof depth);
    queue<int> q;
    q.push(root);
    depth[0]=0,depth[root]=1;
    while(q.size())
    {
        int t=q.front();
        q.pop();
        for(int i=h[t];~i;i=ne[i])
        {
            int j=e[i];
            if(depth[j]>depth[t]+1)
            {
                depth[j]=depth[t]+1;
                fa[j][0]=t;
                q.push(j);
                for(int k=1;k<16;k++)
                    fa[j][k]=fa[fa[j][k-1]][k-1];
            }
        }
    }
}
int lca(int a,int b)
{
    if(depth[a]<depth[b]) swap(a,b);
    for(int k=15;k>=0;k--)
        if(depth[fa[a][k]]>=depth[b]) 
            a=fa[a][k];
    if(a==b) return a;
    for(int k=15;k>=0;k--)
    {
        if(fa[a][k]!=fa[b][k])
        {
            a=fa[a][k];
            b=fa[b][k];
        }
    }
    return fa[a][0];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.346 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]最近公共祖先: targin离线算法
[回答] 
```
vector<PII> query[N];  
 
void dfs(int u,int fa)
{
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(j==fa) continue;
        dis[j]=dis[u]+w[i];
        dfs(j,u);
    }
}
int find(int x)
{
    if(x!=p[x]) p[x]=find(p[x]);
    return p[x];
}
void targin(int u)
{
    st[u]=1;    
    for(int i=h[u];~i;i=ne[i])
    {
        int j=e[i];
        if(!st[j])    
        {
            targin(j);
            p[j]=u;   
        }
    }
    for(auto it : quiry[u]) 
    {
        int x=u,y=it.first,id=it.second;
        if(st[y]==2)
        {
            int lca=find(y);
            ans[id]=dis[x]+dis[y]-2*dis[lca];
        }
    }
    st[u]=2; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.349 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]有向图的强连通分量
[回答] 
 ```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u, in_stk[u] = true;
 
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        }
        else if (in_stk[j])
            low[u] = min(low[u], dfn[j]);
    }
 
    if (dfn[u] == low[u])
    {
        ++ scc_cnt;
        int y;
        do {
            y = stk[top -- ];
            in_stk[y] = false;
            id[y] = scc_cnt;
            //size_scc[scc_cnt]++;
        } while (y != u);
    }
}
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++;
        }
    }
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.352 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 无向图的点双连通分量
[回答] 
```
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
 
void tarjan(int u)
{
    dfn[u] = low[u] = ++ timestamp;
    stk[ ++ top] = u;
 
    if (u == root && h[u] == -1)
    {
        dcc_cnt ++ ;
        dcc[dcc_cnt].push_back(u);
        return;
    }
 
    int cnt = 0;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (!dfn[j])
        {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (dfn[u] <= low[j])
            {
                cnt ++ ;
                if (u != root || cnt > 1) cut[u] = true;
                ++ dcc_cnt;
                int y;
                do {
                    y = stk[top -- ];
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        }
        else low[u] = min(low[u], dfn[j]);
    }
}
 
int main()
{
    int T = 1;
    while (cin >> m, m)
    {
        for (int i = 1; i <= dcc_cnt; i ++ ) dcc[i].clear();
        idx = n = timestamp = top = dcc_cnt = 0;
        memset(h, -1, sizeof h);
        memset(dfn, 0, sizeof dfn);
        memset(cut, 0, sizeof cut);
        while (m -- )
        {
            int a, b;
            cin >> a >> b;
            n = max(n, a), n = max(n, b);
            add(a, b), add(b, a);
        }
 
        for (root = 1; root <= n; root ++ )
            if (!dfn[root])
                tarjan(root);
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.357 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]457
2024-07-15 13:33:00.357 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 二分图  时间复杂度是 O(n+m)
[回答] 
 ```
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
 
    return true;
}
 
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.359 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题] 匈牙利算法
[回答] 
 ```
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
 
    return false;
}

int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.362 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  单链表
[回答] 
```
int head, e[N], ne[N], idx;
void init()
{
    head = -1;
    idx = 0;
}
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
void remove()
{
    head = ne[head];
}
```


-----\d+-----
[问题]   双链表
[回答] 
```
void init()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
}
 
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}
 
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.364 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    单调栈, 找出每个数左边离它最近的比它大/小的数
[回答]
```
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```


-----\d+-----
[问题]    单调队列
[回答]
```
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.366 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最大子段和（限制区间长度） 
[回答]
```
    for (int i = 1; i <= n; i ++ ) scanf("%d", &s[i]), s[i] += s[i - 1];
 
    int res = -INF;
    int hh = 0, tt = 0;
 
    for (int i = 1; i <= n; i ++ )//核心代码
    {
        if (q[hh] < i - m) hh ++ ;
        res = max(res, s[i] - s[q[hh]]);
        while (hh <= tt && s[q[tt]] >= s[i]) tt -- ;
        q[ ++ tt] = i;
    }
```


-----\d+-----
[问题]   朴素并查集：
[回答]
```
    int p[N]; 
 
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ ) p[i] = i;
 
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.369 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护size的并查集：
[回答]
```
    int p[N], size[N];
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }
 
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.370 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   维护到祖宗节点距离的并查集：
[回答]
```
    int p[N], d[N];
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }
 
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }
 
    p[find(a)] = find(b);
    d[find(a)] = distance; 
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.372 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    字符串哈希
[回答]
```
typedef unsigned long long ULL;
ULL h[N], p[N]; 
 
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}
 
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.374 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    KMP——字符串匹配
[回答]
```
const int N=1e6+7;
char p[N],s[N];
int ne[N];int main()
{
	int n;cin >>n>>p+1; 
	int m;cin >>m>>s+1;
	for(int i=2,j=0;i<=n;i++)
	{
		while(j&&p[i]!=p[j+1]) j=ne[j];
		if(p[i]==p[j+1]) j++;
		ne[i]=j;
	} 
	for(int i=1,j=0;i<=m;i++)
	{
		while(j&&s[i]!=p[j+1]) j=ne[j];
		if(s[i]==p[j+1]) j++;
		//max_p=max(max_p,j);
		if(j==n)
		{
			cout <<i-n<<" ";
			j=ne[j];
		} 
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.377 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（单点修改）
[回答]
int n,m;
 
struct node
{
	int l,r;  
	int sum;   
	int lmax; 
	int rmax; 
	int tmax;  
}tr[N*4];
 
void pushup(node &u,node &l,node &r)
{
	u.sum=l.sum+r.sum;
	u.lmax=max(l.lmax,l.sum+r.lmax); 
	u.rmax=max(r.rmax,r.sum+l.rmax);
	u.tmax=max(max(l.tmax,r.tmax),l.rmax+r.lmax);
}
 
void pushup(int u)
{
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
 
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],w[r],w[r],w[r]};
	else
	{	tr[u]={l,r};
		int mid=l+r>>1;	
		build(u<<1,l,mid);	
		build(u<<1|1,mid+1,r);
		pushup(u);
	}
}
 
void modify(int u,int x,int v)
{
	if(tr[u].l==x&&tr[u].r==x)  tr[u] = {x,x,v,v,v,v}; 
	else 
	{
		int mid=tr[u].l+tr[u].r>>1;	
		if(x<=mid) modify(u<<1,x,v);
		else modify(u<<1|1,x,v);	
		pushup(u);	
	}
}
 
node query(int u,int l,int r) 
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u]; 
	else
	{	
		int mid=tr[u].l+tr[u].r>>1;  
		if(r<=mid) return query(u<<1,l,r);
		else if(l>mid) return query(u<<1|1,l,r); 
		else 
		{
			auto left=query(u<<1,l,r);   
			auto right=query(u<<1|1,l,r);	
			node res;
			pushup(res,left,right);  
			return res;
		}	
	}
}' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.379 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]469
2024-07-15 13:33:00.380 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    线段树（区间修改）
[回答]
```
struct node
{
	ll l,r;  
	ll sum;
	ll add;	
	ll mul;
}tr[N*4];
void eval(node &root,int add,int mul)
{
    root.sum=(root.sum*mul+(root.r-root.l+1)*add)%p;
    root.mul=root.mul*mul%p;
    root.add=(root.add*mul+add)%p;
}
void pushup(int u)
{
	tr[u].sum=(tr[u<<1].sum+tr[u<<1|1].sum)%p;
}
void pushdown(int u)
{
    eval(tr[u<<1],tr[u].add,tr[u].mul);
    eval(tr[u<<1|1],tr[u].add,tr[u].mul);
    tr[u].add=0,tr[u].mul=1;
}
void build(int u,int l,int r)
{
	if(l==r) tr[u]={l,r,w[r],0,1};
	else
	{	tr[u]={l,r,0,0,1};	
		int mid=l+r>>1;	
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);	
		pushup(u);	
	}
}
 
void modify(int u,int l,int r,int add,int mul)
{
	if(tr[u].l>=l&&tr[u].r<=r)
	{
		eval(tr[u],add,mul);
	}
	else 
	{
		pushdown(u);
		int mid=tr[u].l+tr[u].r>>1;	
		if(l<=mid) modify(u<<1,l,r,add,mul); 
		if(r>mid) modify(u<<1|1,l,r,add,mul);	
		pushup(u);
	}
}
 
node query(int u,int l,int r)   
{
	if(tr[u].l>=l&&tr[u].r<=r) return tr[u];
	else
	{	
	    pushdown(u);
		node res;
		res.sum=0;
		int mid=tr[u].l+tr[u].r>>1; 
		if(l<=mid) res.sum+=query(u<<1,l,r).sum%p;
		if(r>mid) res.sum+=query(u<<1|1,l,r).sum%p;
		pushup(u);
		return res;
	}
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.383 | ERROR    | chatbot.chatbot:__init__:48 - [tokens of doc]507
2024-07-15 13:33:00.384 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]    树状数组
[回答]
```
int lowbit(int x)
{
	return x&-x;
}
void modify(int x,int c)//修改树状数组x位置的值
{
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=c;
}
int query(int x)//查询区间1~x的区间和；
{
	int res=0;
	for(int i=x;i>=1;i-=lowbit(i)) res+=tr[i];
	return res; 
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.385 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   Trie树（字典树）
[回答]
```
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
 
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - '0';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.386 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长上升子序列模型
[回答]

```
O(N^2)
for(int i=1;i<=n;i++)
{
    f[i]=1
    for(int j=1;j<=i;j++)
    {
        if(a[j]<a[i]) f[i]=max(f[i],f[j]+1);
        ans=max(ans,f[i]);
    }
}
O(NlogN)
int len=0;
for(int i=1;i<n;i++)
{
    int pos=lower_bound(f, f+len, a[i]) - f;
    len=max(len,pos+1);
    f[pos]=a[i];
}
cout <<len<<endl;
 ```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.388 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]   最长公共序列模型 
[回答]
```
int main()
{
    int n,m;
    cin >>n>>m;
    for(int i=1;i<=n;i++) cin >>a[i];
    for(int i=1;i<=m;i++) cin >>b[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
        }
    }
    cout <<f[n][m]<<endl;
}
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.390 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  最长公共上升序列模型
[回答]
 ```
int ans=0;
for(int i=1;i<=n;i++)
{
    int temp=1;
    for(int j=1;j<=n;j++)
    {
        f[i][j]=max(f[i-1][j],f[i][j]);
        if(a[i]==b[j]) f[i][j]=max(temp,f[i][j]);
        if(a[i]>b[j]) temp=max(temp,f[i-1][j]+1);
    }
}
for(int i=1;i<=n;i++) ans=max(ans,f[n][i]);
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.392 | DEBUG    | chatbot.chatbot:__init__:43 - [doc]page_content='[问题]  编辑距离模型
[回答]
 ```
cin >>n>>a+1;
cin >>m>>b+1;
for(int i=1;i<=n;i++) f[i][0]=i;
for(int i=1;i<=m;i++) f[0][i]=i;
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=m;j++)
    {
        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);//添加或者删除
        if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]);
        else f[i][j]=min(f[i][j],f[i-1][j-1]+1);//修改
    }
}
cout <<f[n][m]<<endl;
```' metadata={'source': 'D://jupyter//OI_WIKI_ChatRot//algorithm.txt'}
2024-07-15 13:33:00.393 | DEBUG    | chatbot.chatbot:__init__:50 - [len of docs_list]56
2024-07-15 16:06:37.642 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:06:37.644 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:06:37.647 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:06:37.649 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:06:37.649 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:06:37.651 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 16:07:35.491 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:07:35.493 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:07:35.496 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:07:35.498 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:07:35.499 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:07:35.500 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 16:10:12.880 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:10:12.884 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:10:12.887 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:10:12.889 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:10:12.890 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:10:12.891 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 16:16:57.655 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:16:57.659 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:16:57.661 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:16:57.663 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:16:57.664 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:16:57.665 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 16:17:46.871 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:17:46.874 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:17:46.877 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:17:46.879 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:17:46.880 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:17:46.881 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 16:18:48.185 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:18:48.188 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:18:48.190 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:18:48.192 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:18:48.193 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:18:48.194 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 16:24:18.724 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:24:18.727 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:24:18.730 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:24:18.732 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:24:18.732 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:24:18.734 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 16:32:15.246 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]506
2024-07-15 16:32:15.250 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]479
2024-07-15 16:32:15.252 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]457
2024-07-15 16:32:15.254 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]469
2024-07-15 16:32:15.255 | ERROR    | chatbot.chatbot:__init__:49 - [tokens of doc]507
2024-07-15 16:32:15.256 | DEBUG    | chatbot.chatbot:__init__:51 - [len of docs_list]56
2024-07-15 22:10:47.067 | DEBUG    | __main__:algorithm_chat:19 - [message]强连通分量
2024-07-15 22:10:47.070 | DEBUG    | __main__:algorithm_chat:20 - [history][]
2024-07-15 22:11:13.948 | DEBUG    | __main__:algorithm_chat:27 - [input]强连通分量
2024-07-15 22:11:13.948 | DEBUG    | __main__:algorithm_chat:28 - [context][Document(metadata={'source': 'D://jupyter//alogrithm_chatbot//algorithm.txt'}, page_content='[问题]有向图的强连通分量\n[回答] \n ```\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n \nvoid tarjan(int u)\n{\n    dfn[u] = low[u] = ++ timestamp;\n    stk[ ++ top] = u, in_stk[u] = true;\n \n    for (int i = h[u]; ~i; i = ne[i])\n    {\n        int j = e[i];\n        if (!dfn[j])\n        {\n            tarjan(j);\n            low[u] = min(low[u], low[j]);\n        }\n        else if (in_stk[j])\n            low[u] = min(low[u], dfn[j]);\n    }\n \n    if (dfn[u] == low[u])\n    {\n        ++ scc_cnt;\n        int y;\n        do {\n            y = stk[top -- ];\n            in_stk[y] = false;\n            id[y] = scc_cnt;\n            //size_scc[scc_cnt]++;\n        } while (y != u);\n    }\n}\nfor(int i=1;i<=n;i++)\n    {\n        if(!dfn[i])\n            tarjan(i);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=h[i];~j;j=ne[j])\n        {\n            int k=e[j];\n            int a=id[i],b=id[k];\n            if(a!=b) dout[a]++;\n        }\n    }\n```')]
2024-07-15 22:11:13.949 | DEBUG    | __main__:algorithm_chat:29 - [answer]在图论中，特别是在有向图的领域里，强连通分量是一个重要的概念。以下是对您提供的代码的逐行注释，该代码用于在有向图中寻找强连通分量，它使用了经典的Tarjan算法。

```c
// 定义添加边的操作，这里使用了邻接表来存储图
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; // 将b节点添加到a节点的邻接链表中
}

// Tarjan算法主过程，用于寻找强连通分量
void tarjan(int u) {
    dfn[u] = low[u] = ++ timestamp; // dfn记录节点u的访问时间戳，low记录u或其子孙通过非父子边能回溯到的最早的祖先的时间戳
    stk[ ++ top] = u, in_stk[u] = true; // 将u压入栈中，表示u在栈中

    for (int i = h[u]; ~i; i = ne[i]) { // 遍历u的所有邻接点
        int j = e[i]; // e[i]表示i对应的邻接点
        if (!dfn[j]) { // 如果j未被访问过
            tarjan(j); // 递归访问j
            low[u] = min(low[u], low[j]); // 更新u的low值
        }
        else if (in_stk[j]) // 如果j在栈中
            low[u] = min(low[u], dfn[j]); // 更新u的low值
    }

    if (dfn[u] == low[u]) { // 如果dfn[u]等于low[u]，说明u是一个强连通分量的根
        ++ scc_cnt; // 强连通分量数量加1
        int y;
        do {
            y = stk[top -- ]; // 弹出栈顶元素，即当前强连通分量中的一个节点
            in_stk[y] = false; // 标记y不在栈中
            id[y] = scc_cnt; // 标记y属于第scc_cnt个强连通分量
            //size_scc[scc_cnt]++; // 如果需要，可以统计每个强连通分量的节点数
        } while (y != u); // 继续弹出，直到回到u
    }
}

// 对每个节点调用tarjan函数，确保图中的每个节点都被访问
for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }

// 统计每个强连通分量的出度
for(int i=1;i<=n;i++)
    {
        for(int j=h[i];~j;j=ne[j])
        {
            int k=e[j];
            int a=id[i],b=id[k];
            if(a!=b) dout[a]++; // 如果边(i,k)不属于同一个强连通分量，则分量a的出度增加
        }
    }
```

这段代码是Tarjan算法的实现，用于在一个有向图中找到所有的强连通分量。每个强连通分量中的节点都是相互可达的。算法使用了深度优先搜索（DFS）和栈来追踪访问过的节点，并确定每个节点的low值，从而找到强连通分量的边界。最后，代码还统计了每个强连通分量的出度，这在某些应用场景下是有用的信息。
